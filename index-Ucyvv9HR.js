var nm = t => {
    throw TypeError(t)
}
;
var Ru = (t, e, r) => e.has(t) || nm("Cannot " + r);
var E = (t, e, r) => (Ru(t, e, "read from private field"),
r ? r.call(t) : e.get(t))
  , X = (t, e, r) => e.has(t) ? nm("Cannot add the same private member more than once") : e instanceof WeakSet ? e.add(t) : e.set(t, r)
  , V = (t, e, r, n) => (Ru(t, e, "write to private field"),
n ? n.call(t, r) : e.set(t, r),
r)
  , de = (t, e, r) => (Ru(t, e, "access private method"),
r);
var Ya = (t, e, r, n) => ({
    set _(s) {
        V(t, e, s, r)
    },
    get _() {
        return E(t, e, n)
    }
});
function kS(t, e) {
    for (var r = 0; r < e.length; r++) {
        const n = e[r];
        if (typeof n != "string" && !Array.isArray(n)) {
            for (const s in n)
                if (s !== "default" && !(s in t)) {
                    const i = Object.getOwnPropertyDescriptor(n, s);
                    i && Object.defineProperty(t, s, i.get ? i : {
                        enumerable: !0,
                        get: () => n[s]
                    })
                }
        }
    }
    return Object.freeze(Object.defineProperty(t, Symbol.toStringTag, {
        value: "Module"
    }))
}
(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const s of document.querySelectorAll('link[rel="modulepreload"]'))
        n(s);
    new MutationObserver(s => {
        for (const i of s)
            if (i.type === "childList")
                for (const o of i.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && n(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function r(s) {
        const i = {};
        return s.integrity && (i.integrity = s.integrity),
        s.referrerPolicy && (i.referrerPolicy = s.referrerPolicy),
        s.crossOrigin === "use-credentials" ? i.credentials = "include" : s.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin",
        i
    }
    function n(s) {
        if (s.ep)
            return;
        s.ep = !0;
        const i = r(s);
        fetch(s.href, i)
    }
}
)();
function ay(t) {
    return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t
}
var ly = {
    exports: {}
}
  , Fc = {}
  , cy = {
    exports: {}
}
  , ue = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Da = Symbol.for("react.element")
  , ES = Symbol.for("react.portal")
  , CS = Symbol.for("react.fragment")
  , TS = Symbol.for("react.strict_mode")
  , RS = Symbol.for("react.profiler")
  , NS = Symbol.for("react.provider")
  , PS = Symbol.for("react.context")
  , AS = Symbol.for("react.forward_ref")
  , jS = Symbol.for("react.suspense")
  , OS = Symbol.for("react.memo")
  , IS = Symbol.for("react.lazy")
  , sm = Symbol.iterator;
function LS(t) {
    return t === null || typeof t != "object" ? null : (t = sm && t[sm] || t["@@iterator"],
    typeof t == "function" ? t : null)
}
var uy = {
    isMounted: function() {
        return !1
    },
    enqueueForceUpdate: function() {},
    enqueueReplaceState: function() {},
    enqueueSetState: function() {}
}
  , dy = Object.assign
  , hy = {};
function ho(t, e, r) {
    this.props = t,
    this.context = e,
    this.refs = hy,
    this.updater = r || uy
}
ho.prototype.isReactComponent = {};
ho.prototype.setState = function(t, e) {
    if (typeof t != "object" && typeof t != "function" && t != null)
        throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
    this.updater.enqueueSetState(this, t, e, "setState")
}
;
ho.prototype.forceUpdate = function(t) {
    this.updater.enqueueForceUpdate(this, t, "forceUpdate")
}
;
function fy() {}
fy.prototype = ho.prototype;
function bf(t, e, r) {
    this.props = t,
    this.context = e,
    this.refs = hy,
    this.updater = r || uy
}
var _f = bf.prototype = new fy;
_f.constructor = bf;
dy(_f, ho.prototype);
_f.isPureReactComponent = !0;
var im = Array.isArray
  , py = Object.prototype.hasOwnProperty
  , Sf = {
    current: null
}
  , my = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function gy(t, e, r) {
    var n, s = {}, i = null, o = null;
    if (e != null)
        for (n in e.ref !== void 0 && (o = e.ref),
        e.key !== void 0 && (i = "" + e.key),
        e)
            py.call(e, n) && !my.hasOwnProperty(n) && (s[n] = e[n]);
    var a = arguments.length - 2;
    if (a === 1)
        s.children = r;
    else if (1 < a) {
        for (var l = Array(a), c = 0; c < a; c++)
            l[c] = arguments[c + 2];
        s.children = l
    }
    if (t && t.defaultProps)
        for (n in a = t.defaultProps,
        a)
            s[n] === void 0 && (s[n] = a[n]);
    return {
        $$typeof: Da,
        type: t,
        key: i,
        ref: o,
        props: s,
        _owner: Sf.current
    }
}
function $S(t, e) {
    return {
        $$typeof: Da,
        type: t.type,
        key: e,
        ref: t.ref,
        props: t.props,
        _owner: t._owner
    }
}
function kf(t) {
    return typeof t == "object" && t !== null && t.$$typeof === Da
}
function DS(t) {
    var e = {
        "=": "=0",
        ":": "=2"
    };
    return "$" + t.replace(/[=:]/g, function(r) {
        return e[r]
    })
}
var om = /\/+/g;
function Nu(t, e) {
    return typeof t == "object" && t !== null && t.key != null ? DS("" + t.key) : e.toString(36)
}
function Al(t, e, r, n, s) {
    var i = typeof t;
    (i === "undefined" || i === "boolean") && (t = null);
    var o = !1;
    if (t === null)
        o = !0;
    else
        switch (i) {
        case "string":
        case "number":
            o = !0;
            break;
        case "object":
            switch (t.$$typeof) {
            case Da:
            case ES:
                o = !0
            }
        }
    if (o)
        return o = t,
        s = s(o),
        t = n === "" ? "." + Nu(o, 0) : n,
        im(s) ? (r = "",
        t != null && (r = t.replace(om, "$&/") + "/"),
        Al(s, e, r, "", function(c) {
            return c
        })) : s != null && (kf(s) && (s = $S(s, r + (!s.key || o && o.key === s.key ? "" : ("" + s.key).replace(om, "$&/") + "/") + t)),
        e.push(s)),
        1;
    if (o = 0,
    n = n === "" ? "." : n + ":",
    im(t))
        for (var a = 0; a < t.length; a++) {
            i = t[a];
            var l = n + Nu(i, a);
            o += Al(i, e, r, l, s)
        }
    else if (l = LS(t),
    typeof l == "function")
        for (t = l.call(t),
        a = 0; !(i = t.next()).done; )
            i = i.value,
            l = n + Nu(i, a++),
            o += Al(i, e, r, l, s);
    else if (i === "object")
        throw e = String(t),
        Error("Objects are not valid as a React child (found: " + (e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e) + "). If you meant to render a collection of children, use an array instead.");
    return o
}
function Xa(t, e, r) {
    if (t == null)
        return t;
    var n = []
      , s = 0;
    return Al(t, n, "", "", function(i) {
        return e.call(r, i, s++)
    }),
    n
}
function MS(t) {
    if (t._status === -1) {
        var e = t._result;
        e = e(),
        e.then(function(r) {
            (t._status === 0 || t._status === -1) && (t._status = 1,
            t._result = r)
        }, function(r) {
            (t._status === 0 || t._status === -1) && (t._status = 2,
            t._result = r)
        }),
        t._status === -1 && (t._status = 0,
        t._result = e)
    }
    if (t._status === 1)
        return t._result.default;
    throw t._result
}
var yt = {
    current: null
}
  , jl = {
    transition: null
}
  , FS = {
    ReactCurrentDispatcher: yt,
    ReactCurrentBatchConfig: jl,
    ReactCurrentOwner: Sf
};
function vy() {
    throw Error("act(...) is not supported in production builds of React.")
}
ue.Children = {
    map: Xa,
    forEach: function(t, e, r) {
        Xa(t, function() {
            e.apply(this, arguments)
        }, r)
    },
    count: function(t) {
        var e = 0;
        return Xa(t, function() {
            e++
        }),
        e
    },
    toArray: function(t) {
        return Xa(t, function(e) {
            return e
        }) || []
    },
    only: function(t) {
        if (!kf(t))
            throw Error("React.Children.only expected to receive a single React element child.");
        return t
    }
};
ue.Component = ho;
ue.Fragment = CS;
ue.Profiler = RS;
ue.PureComponent = bf;
ue.StrictMode = TS;
ue.Suspense = jS;
ue.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = FS;
ue.act = vy;
ue.cloneElement = function(t, e, r) {
    if (t == null)
        throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + t + ".");
    var n = dy({}, t.props)
      , s = t.key
      , i = t.ref
      , o = t._owner;
    if (e != null) {
        if (e.ref !== void 0 && (i = e.ref,
        o = Sf.current),
        e.key !== void 0 && (s = "" + e.key),
        t.type && t.type.defaultProps)
            var a = t.type.defaultProps;
        for (l in e)
            py.call(e, l) && !my.hasOwnProperty(l) && (n[l] = e[l] === void 0 && a !== void 0 ? a[l] : e[l])
    }
    var l = arguments.length - 2;
    if (l === 1)
        n.children = r;
    else if (1 < l) {
        a = Array(l);
        for (var c = 0; c < l; c++)
            a[c] = arguments[c + 2];
        n.children = a
    }
    return {
        $$typeof: Da,
        type: t.type,
        key: s,
        ref: i,
        props: n,
        _owner: o
    }
}
;
ue.createContext = function(t) {
    return t = {
        $$typeof: PS,
        _currentValue: t,
        _currentValue2: t,
        _threadCount: 0,
        Provider: null,
        Consumer: null,
        _defaultValue: null,
        _globalName: null
    },
    t.Provider = {
        $$typeof: NS,
        _context: t
    },
    t.Consumer = t
}
;
ue.createElement = gy;
ue.createFactory = function(t) {
    var e = gy.bind(null, t);
    return e.type = t,
    e
}
;
ue.createRef = function() {
    return {
        current: null
    }
}
;
ue.forwardRef = function(t) {
    return {
        $$typeof: AS,
        render: t
    }
}
;
ue.isValidElement = kf;
ue.lazy = function(t) {
    return {
        $$typeof: IS,
        _payload: {
            _status: -1,
            _result: t
        },
        _init: MS
    }
}
;
ue.memo = function(t, e) {
    return {
        $$typeof: OS,
        type: t,
        compare: e === void 0 ? null : e
    }
}
;
ue.startTransition = function(t) {
    var e = jl.transition;
    jl.transition = {};
    try {
        t()
    } finally {
        jl.transition = e
    }
}
;
ue.unstable_act = vy;
ue.useCallback = function(t, e) {
    return yt.current.useCallback(t, e)
}
;
ue.useContext = function(t) {
    return yt.current.useContext(t)
}
;
ue.useDebugValue = function() {}
;
ue.useDeferredValue = function(t) {
    return yt.current.useDeferredValue(t)
}
;
ue.useEffect = function(t, e) {
    return yt.current.useEffect(t, e)
}
;
ue.useId = function() {
    return yt.current.useId()
}
;
ue.useImperativeHandle = function(t, e, r) {
    return yt.current.useImperativeHandle(t, e, r)
}
;
ue.useInsertionEffect = function(t, e) {
    return yt.current.useInsertionEffect(t, e)
}
;
ue.useLayoutEffect = function(t, e) {
    return yt.current.useLayoutEffect(t, e)
}
;
ue.useMemo = function(t, e) {
    return yt.current.useMemo(t, e)
}
;
ue.useReducer = function(t, e, r) {
    return yt.current.useReducer(t, e, r)
}
;
ue.useRef = function(t) {
    return yt.current.useRef(t)
}
;
ue.useState = function(t) {
    return yt.current.useState(t)
}
;
ue.useSyncExternalStore = function(t, e, r) {
    return yt.current.useSyncExternalStore(t, e, r)
}
;
ue.useTransition = function() {
    return yt.current.useTransition()
}
;
ue.version = "18.3.1";
cy.exports = ue;
var y = cy.exports;
const j = ay(y)
  , Ef = kS({
    __proto__: null,
    default: j
}, [y]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var US = y
  , BS = Symbol.for("react.element")
  , zS = Symbol.for("react.fragment")
  , VS = Object.prototype.hasOwnProperty
  , WS = US.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner
  , HS = {
    key: !0,
    ref: !0,
    __self: !0,
    __source: !0
};
function yy(t, e, r) {
    var n, s = {}, i = null, o = null;
    r !== void 0 && (i = "" + r),
    e.key !== void 0 && (i = "" + e.key),
    e.ref !== void 0 && (o = e.ref);
    for (n in e)
        VS.call(e, n) && !HS.hasOwnProperty(n) && (s[n] = e[n]);
    if (t && t.defaultProps)
        for (n in e = t.defaultProps,
        e)
            s[n] === void 0 && (s[n] = e[n]);
    return {
        $$typeof: BS,
        type: t,
        key: i,
        ref: o,
        props: s,
        _owner: WS.current
    }
}
Fc.Fragment = zS;
Fc.jsx = yy;
Fc.jsxs = yy;
ly.exports = Fc;
var d = ly.exports
  , wy = {
    exports: {}
}
  , Bt = {}
  , xy = {
    exports: {}
}
  , by = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(t) {
    function e(R, N) {
        var D = R.length;
        R.push(N);
        e: for (; 0 < D; ) {
            var ee = D - 1 >>> 1
              , q = R[ee];
            if (0 < s(q, N))
                R[ee] = N,
                R[D] = q,
                D = ee;
            else
                break e
        }
    }
    function r(R) {
        return R.length === 0 ? null : R[0]
    }
    function n(R) {
        if (R.length === 0)
            return null;
        var N = R[0]
          , D = R.pop();
        if (D !== N) {
            R[0] = D;
            e: for (var ee = 0, q = R.length, oe = q >>> 1; ee < oe; ) {
                var se = 2 * (ee + 1) - 1
                  , Te = R[se]
                  , Me = se + 1
                  , M = R[Me];
                if (0 > s(Te, D))
                    Me < q && 0 > s(M, Te) ? (R[ee] = M,
                    R[Me] = D,
                    ee = Me) : (R[ee] = Te,
                    R[se] = D,
                    ee = se);
                else if (Me < q && 0 > s(M, D))
                    R[ee] = M,
                    R[Me] = D,
                    ee = Me;
                else
                    break e
            }
        }
        return N
    }
    function s(R, N) {
        var D = R.sortIndex - N.sortIndex;
        return D !== 0 ? D : R.id - N.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var i = performance;
        t.unstable_now = function() {
            return i.now()
        }
    } else {
        var o = Date
          , a = o.now();
        t.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = []
      , c = []
      , u = 1
      , h = null
      , p = 3
      , f = !1
      , b = !1
      , m = !1
      , x = typeof setTimeout == "function" ? setTimeout : null
      , w = typeof clearTimeout == "function" ? clearTimeout : null
      , g = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);
    function v(R) {
        for (var N = r(c); N !== null; ) {
            if (N.callback === null)
                n(c);
            else if (N.startTime <= R)
                n(c),
                N.sortIndex = N.expirationTime,
                e(l, N);
            else
                break;
            N = r(c)
        }
    }
    function _(R) {
        if (m = !1,
        v(R),
        !b)
            if (r(l) !== null)
                b = !0,
                U(S);
            else {
                var N = r(c);
                N !== null && Q(_, N.startTime - R)
            }
    }
    function S(R, N) {
        b = !1,
        m && (m = !1,
        w(T),
        T = -1),
        f = !0;
        var D = p;
        try {
            for (v(N),
            h = r(l); h !== null && (!(h.expirationTime > N) || R && !B()); ) {
                var ee = h.callback;
                if (typeof ee == "function") {
                    h.callback = null,
                    p = h.priorityLevel;
                    var q = ee(h.expirationTime <= N);
                    N = t.unstable_now(),
                    typeof q == "function" ? h.callback = q : h === r(l) && n(l),
                    v(N)
                } else
                    n(l);
                h = r(l)
            }
            if (h !== null)
                var oe = !0;
            else {
                var se = r(c);
                se !== null && Q(_, se.startTime - N),
                oe = !1
            }
            return oe
        } finally {
            h = null,
            p = D,
            f = !1
        }
    }
    var k = !1
      , C = null
      , T = -1
      , A = 5
      , P = -1;
    function B() {
        return !(t.unstable_now() - P < A)
    }
    function L() {
        if (C !== null) {
            var R = t.unstable_now();
            P = R;
            var N = !0;
            try {
                N = C(!0, R)
            } finally {
                N ? G() : (k = !1,
                C = null)
            }
        } else
            k = !1
    }
    var G;
    if (typeof g == "function")
        G = function() {
            g(L)
        }
        ;
    else if (typeof MessageChannel < "u") {
        var $ = new MessageChannel
          , Y = $.port2;
        $.port1.onmessage = L,
        G = function() {
            Y.postMessage(null)
        }
    } else
        G = function() {
            x(L, 0)
        }
        ;
    function U(R) {
        C = R,
        k || (k = !0,
        G())
    }
    function Q(R, N) {
        T = x(function() {
            R(t.unstable_now())
        }, N)
    }
    t.unstable_IdlePriority = 5,
    t.unstable_ImmediatePriority = 1,
    t.unstable_LowPriority = 4,
    t.unstable_NormalPriority = 3,
    t.unstable_Profiling = null,
    t.unstable_UserBlockingPriority = 2,
    t.unstable_cancelCallback = function(R) {
        R.callback = null
    }
    ,
    t.unstable_continueExecution = function() {
        b || f || (b = !0,
        U(S))
    }
    ,
    t.unstable_forceFrameRate = function(R) {
        0 > R || 125 < R ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : A = 0 < R ? Math.floor(1e3 / R) : 5
    }
    ,
    t.unstable_getCurrentPriorityLevel = function() {
        return p
    }
    ,
    t.unstable_getFirstCallbackNode = function() {
        return r(l)
    }
    ,
    t.unstable_next = function(R) {
        switch (p) {
        case 1:
        case 2:
        case 3:
            var N = 3;
            break;
        default:
            N = p
        }
        var D = p;
        p = N;
        try {
            return R()
        } finally {
            p = D
        }
    }
    ,
    t.unstable_pauseExecution = function() {}
    ,
    t.unstable_requestPaint = function() {}
    ,
    t.unstable_runWithPriority = function(R, N) {
        switch (R) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
            break;
        default:
            R = 3
        }
        var D = p;
        p = R;
        try {
            return N()
        } finally {
            p = D
        }
    }
    ,
    t.unstable_scheduleCallback = function(R, N, D) {
        var ee = t.unstable_now();
        switch (typeof D == "object" && D !== null ? (D = D.delay,
        D = typeof D == "number" && 0 < D ? ee + D : ee) : D = ee,
        R) {
        case 1:
            var q = -1;
            break;
        case 2:
            q = 250;
            break;
        case 5:
            q = 1073741823;
            break;
        case 4:
            q = 1e4;
            break;
        default:
            q = 5e3
        }
        return q = D + q,
        R = {
            id: u++,
            callback: N,
            priorityLevel: R,
            startTime: D,
            expirationTime: q,
            sortIndex: -1
        },
        D > ee ? (R.sortIndex = D,
        e(c, R),
        r(l) === null && R === r(c) && (m ? (w(T),
        T = -1) : m = !0,
        Q(_, D - ee))) : (R.sortIndex = q,
        e(l, R),
        b || f || (b = !0,
        U(S))),
        R
    }
    ,
    t.unstable_shouldYield = B,
    t.unstable_wrapCallback = function(R) {
        var N = p;
        return function() {
            var D = p;
            p = N;
            try {
                return R.apply(this, arguments)
            } finally {
                p = D
            }
        }
    }
}
)(by);
xy.exports = by;
var KS = xy.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qS = y
  , Ft = KS;
function O(t) {
    for (var e = "https://reactjs.org/docs/error-decoder.html?invariant=" + t, r = 1; r < arguments.length; r++)
        e += "&args[]=" + encodeURIComponent(arguments[r]);
    return "Minified React error #" + t + "; visit " + e + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
}
var _y = new Set
  , ea = {};
function Fs(t, e) {
    Ji(t, e),
    Ji(t + "Capture", e)
}
function Ji(t, e) {
    for (ea[t] = e,
    t = 0; t < e.length; t++)
        _y.add(e[t])
}
var qr = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u")
  , Rd = Object.prototype.hasOwnProperty
  , GS = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/
  , am = {}
  , lm = {};
function QS(t) {
    return Rd.call(lm, t) ? !0 : Rd.call(am, t) ? !1 : GS.test(t) ? lm[t] = !0 : (am[t] = !0,
    !1)
}
function JS(t, e, r, n) {
    if (r !== null && r.type === 0)
        return !1;
    switch (typeof e) {
    case "function":
    case "symbol":
        return !0;
    case "boolean":
        return n ? !1 : r !== null ? !r.acceptsBooleans : (t = t.toLowerCase().slice(0, 5),
        t !== "data-" && t !== "aria-");
    default:
        return !1
    }
}
function ZS(t, e, r, n) {
    if (e === null || typeof e > "u" || JS(t, e, r, n))
        return !0;
    if (n)
        return !1;
    if (r !== null)
        switch (r.type) {
        case 3:
            return !e;
        case 4:
            return e === !1;
        case 5:
            return isNaN(e);
        case 6:
            return isNaN(e) || 1 > e
        }
    return !1
}
function wt(t, e, r, n, s, i, o) {
    this.acceptsBooleans = e === 2 || e === 3 || e === 4,
    this.attributeName = n,
    this.attributeNamespace = s,
    this.mustUseProperty = r,
    this.propertyName = t,
    this.type = e,
    this.sanitizeURL = i,
    this.removeEmptyString = o
}
var ot = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(t) {
    ot[t] = new wt(t,0,!1,t,null,!1,!1)
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(t) {
    var e = t[0];
    ot[e] = new wt(e,1,!1,t[1],null,!1,!1)
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(t) {
    ot[t] = new wt(t,2,!1,t.toLowerCase(),null,!1,!1)
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(t) {
    ot[t] = new wt(t,2,!1,t,null,!1,!1)
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(t) {
    ot[t] = new wt(t,3,!1,t.toLowerCase(),null,!1,!1)
});
["checked", "multiple", "muted", "selected"].forEach(function(t) {
    ot[t] = new wt(t,3,!0,t,null,!1,!1)
});
["capture", "download"].forEach(function(t) {
    ot[t] = new wt(t,4,!1,t,null,!1,!1)
});
["cols", "rows", "size", "span"].forEach(function(t) {
    ot[t] = new wt(t,6,!1,t,null,!1,!1)
});
["rowSpan", "start"].forEach(function(t) {
    ot[t] = new wt(t,5,!1,t.toLowerCase(),null,!1,!1)
});
var Cf = /[\-:]([a-z])/g;
function Tf(t) {
    return t[1].toUpperCase()
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(t) {
    var e = t.replace(Cf, Tf);
    ot[e] = new wt(e,1,!1,t,null,!1,!1)
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(t) {
    var e = t.replace(Cf, Tf);
    ot[e] = new wt(e,1,!1,t,"http://www.w3.org/1999/xlink",!1,!1)
});
["xml:base", "xml:lang", "xml:space"].forEach(function(t) {
    var e = t.replace(Cf, Tf);
    ot[e] = new wt(e,1,!1,t,"http://www.w3.org/XML/1998/namespace",!1,!1)
});
["tabIndex", "crossOrigin"].forEach(function(t) {
    ot[t] = new wt(t,1,!1,t.toLowerCase(),null,!1,!1)
});
ot.xlinkHref = new wt("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1);
["src", "href", "action", "formAction"].forEach(function(t) {
    ot[t] = new wt(t,1,!1,t.toLowerCase(),null,!0,!0)
});
function Rf(t, e, r, n) {
    var s = ot.hasOwnProperty(e) ? ot[e] : null;
    (s !== null ? s.type !== 0 : n || !(2 < e.length) || e[0] !== "o" && e[0] !== "O" || e[1] !== "n" && e[1] !== "N") && (ZS(e, r, s, n) && (r = null),
    n || s === null ? QS(e) && (r === null ? t.removeAttribute(e) : t.setAttribute(e, "" + r)) : s.mustUseProperty ? t[s.propertyName] = r === null ? s.type === 3 ? !1 : "" : r : (e = s.attributeName,
    n = s.attributeNamespace,
    r === null ? t.removeAttribute(e) : (s = s.type,
    r = s === 3 || s === 4 && r === !0 ? "" : "" + r,
    n ? t.setAttributeNS(n, e, r) : t.setAttribute(e, r))))
}
var en = qS.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED
  , el = Symbol.for("react.element")
  , ui = Symbol.for("react.portal")
  , di = Symbol.for("react.fragment")
  , Nf = Symbol.for("react.strict_mode")
  , Nd = Symbol.for("react.profiler")
  , Sy = Symbol.for("react.provider")
  , ky = Symbol.for("react.context")
  , Pf = Symbol.for("react.forward_ref")
  , Pd = Symbol.for("react.suspense")
  , Ad = Symbol.for("react.suspense_list")
  , Af = Symbol.for("react.memo")
  , fn = Symbol.for("react.lazy")
  , Ey = Symbol.for("react.offscreen")
  , cm = Symbol.iterator;
function So(t) {
    return t === null || typeof t != "object" ? null : (t = cm && t[cm] || t["@@iterator"],
    typeof t == "function" ? t : null)
}
var De = Object.assign, Pu;
function Oo(t) {
    if (Pu === void 0)
        try {
            throw Error()
        } catch (r) {
            var e = r.stack.trim().match(/\n( *(at )?)/);
            Pu = e && e[1] || ""
        }
    return `
` + Pu + t
}
var Au = !1;
function ju(t, e) {
    if (!t || Au)
        return "";
    Au = !0;
    var r = Error.prepareStackTrace;
    Error.prepareStackTrace = void 0;
    try {
        if (e)
            if (e = function() {
                throw Error()
            }
            ,
            Object.defineProperty(e.prototype, "props", {
                set: function() {
                    throw Error()
                }
            }),
            typeof Reflect == "object" && Reflect.construct) {
                try {
                    Reflect.construct(e, [])
                } catch (c) {
                    var n = c
                }
                Reflect.construct(t, [], e)
            } else {
                try {
                    e.call()
                } catch (c) {
                    n = c
                }
                t.call(e.prototype)
            }
        else {
            try {
                throw Error()
            } catch (c) {
                n = c
            }
            t()
        }
    } catch (c) {
        if (c && n && typeof c.stack == "string") {
            for (var s = c.stack.split(`
`), i = n.stack.split(`
`), o = s.length - 1, a = i.length - 1; 1 <= o && 0 <= a && s[o] !== i[a]; )
                a--;
            for (; 1 <= o && 0 <= a; o--,
            a--)
                if (s[o] !== i[a]) {
                    if (o !== 1 || a !== 1)
                        do
                            if (o--,
                            a--,
                            0 > a || s[o] !== i[a]) {
                                var l = `
` + s[o].replace(" at new ", " at ");
                                return t.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", t.displayName)),
                                l
                            }
                        while (1 <= o && 0 <= a);
                    break
                }
        }
    } finally {
        Au = !1,
        Error.prepareStackTrace = r
    }
    return (t = t ? t.displayName || t.name : "") ? Oo(t) : ""
}
function YS(t) {
    switch (t.tag) {
    case 5:
        return Oo(t.type);
    case 16:
        return Oo("Lazy");
    case 13:
        return Oo("Suspense");
    case 19:
        return Oo("SuspenseList");
    case 0:
    case 2:
    case 15:
        return t = ju(t.type, !1),
        t;
    case 11:
        return t = ju(t.type.render, !1),
        t;
    case 1:
        return t = ju(t.type, !0),
        t;
    default:
        return ""
    }
}
function jd(t) {
    if (t == null)
        return null;
    if (typeof t == "function")
        return t.displayName || t.name || null;
    if (typeof t == "string")
        return t;
    switch (t) {
    case di:
        return "Fragment";
    case ui:
        return "Portal";
    case Nd:
        return "Profiler";
    case Nf:
        return "StrictMode";
    case Pd:
        return "Suspense";
    case Ad:
        return "SuspenseList"
    }
    if (typeof t == "object")
        switch (t.$$typeof) {
        case ky:
            return (t.displayName || "Context") + ".Consumer";
        case Sy:
            return (t._context.displayName || "Context") + ".Provider";
        case Pf:
            var e = t.render;
            return t = t.displayName,
            t || (t = e.displayName || e.name || "",
            t = t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef"),
            t;
        case Af:
            return e = t.displayName || null,
            e !== null ? e : jd(t.type) || "Memo";
        case fn:
            e = t._payload,
            t = t._init;
            try {
                return jd(t(e))
            } catch {}
        }
    return null
}
function XS(t) {
    var e = t.type;
    switch (t.tag) {
    case 24:
        return "Cache";
    case 9:
        return (e.displayName || "Context") + ".Consumer";
    case 10:
        return (e._context.displayName || "Context") + ".Provider";
    case 18:
        return "DehydratedFragment";
    case 11:
        return t = e.render,
        t = t.displayName || t.name || "",
        e.displayName || (t !== "" ? "ForwardRef(" + t + ")" : "ForwardRef");
    case 7:
        return "Fragment";
    case 5:
        return e;
    case 4:
        return "Portal";
    case 3:
        return "Root";
    case 6:
        return "Text";
    case 16:
        return jd(e);
    case 8:
        return e === Nf ? "StrictMode" : "Mode";
    case 22:
        return "Offscreen";
    case 12:
        return "Profiler";
    case 21:
        return "Scope";
    case 13:
        return "Suspense";
    case 19:
        return "SuspenseList";
    case 25:
        return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
        if (typeof e == "function")
            return e.displayName || e.name || null;
        if (typeof e == "string")
            return e
    }
    return null
}
function Wn(t) {
    switch (typeof t) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
        return t;
    case "object":
        return t;
    default:
        return ""
    }
}
function Cy(t) {
    var e = t.type;
    return (t = t.nodeName) && t.toLowerCase() === "input" && (e === "checkbox" || e === "radio")
}
function e1(t) {
    var e = Cy(t) ? "checked" : "value"
      , r = Object.getOwnPropertyDescriptor(t.constructor.prototype, e)
      , n = "" + t[e];
    if (!t.hasOwnProperty(e) && typeof r < "u" && typeof r.get == "function" && typeof r.set == "function") {
        var s = r.get
          , i = r.set;
        return Object.defineProperty(t, e, {
            configurable: !0,
            get: function() {
                return s.call(this)
            },
            set: function(o) {
                n = "" + o,
                i.call(this, o)
            }
        }),
        Object.defineProperty(t, e, {
            enumerable: r.enumerable
        }),
        {
            getValue: function() {
                return n
            },
            setValue: function(o) {
                n = "" + o
            },
            stopTracking: function() {
                t._valueTracker = null,
                delete t[e]
            }
        }
    }
}
function tl(t) {
    t._valueTracker || (t._valueTracker = e1(t))
}
function Ty(t) {
    if (!t)
        return !1;
    var e = t._valueTracker;
    if (!e)
        return !0;
    var r = e.getValue()
      , n = "";
    return t && (n = Cy(t) ? t.checked ? "true" : "false" : t.value),
    t = n,
    t !== r ? (e.setValue(t),
    !0) : !1
}
function Ql(t) {
    if (t = t || (typeof document < "u" ? document : void 0),
    typeof t > "u")
        return null;
    try {
        return t.activeElement || t.body
    } catch {
        return t.body
    }
}
function Od(t, e) {
    var r = e.checked;
    return De({}, e, {
        defaultChecked: void 0,
        defaultValue: void 0,
        value: void 0,
        checked: r ?? t._wrapperState.initialChecked
    })
}
function um(t, e) {
    var r = e.defaultValue == null ? "" : e.defaultValue
      , n = e.checked != null ? e.checked : e.defaultChecked;
    r = Wn(e.value != null ? e.value : r),
    t._wrapperState = {
        initialChecked: n,
        initialValue: r,
        controlled: e.type === "checkbox" || e.type === "radio" ? e.checked != null : e.value != null
    }
}
function Ry(t, e) {
    e = e.checked,
    e != null && Rf(t, "checked", e, !1)
}
function Id(t, e) {
    Ry(t, e);
    var r = Wn(e.value)
      , n = e.type;
    if (r != null)
        n === "number" ? (r === 0 && t.value === "" || t.value != r) && (t.value = "" + r) : t.value !== "" + r && (t.value = "" + r);
    else if (n === "submit" || n === "reset") {
        t.removeAttribute("value");
        return
    }
    e.hasOwnProperty("value") ? Ld(t, e.type, r) : e.hasOwnProperty("defaultValue") && Ld(t, e.type, Wn(e.defaultValue)),
    e.checked == null && e.defaultChecked != null && (t.defaultChecked = !!e.defaultChecked)
}
function dm(t, e, r) {
    if (e.hasOwnProperty("value") || e.hasOwnProperty("defaultValue")) {
        var n = e.type;
        if (!(n !== "submit" && n !== "reset" || e.value !== void 0 && e.value !== null))
            return;
        e = "" + t._wrapperState.initialValue,
        r || e === t.value || (t.value = e),
        t.defaultValue = e
    }
    r = t.name,
    r !== "" && (t.name = ""),
    t.defaultChecked = !!t._wrapperState.initialChecked,
    r !== "" && (t.name = r)
}
function Ld(t, e, r) {
    (e !== "number" || Ql(t.ownerDocument) !== t) && (r == null ? t.defaultValue = "" + t._wrapperState.initialValue : t.defaultValue !== "" + r && (t.defaultValue = "" + r))
}
var Io = Array.isArray;
function Ei(t, e, r, n) {
    if (t = t.options,
    e) {
        e = {};
        for (var s = 0; s < r.length; s++)
            e["$" + r[s]] = !0;
        for (r = 0; r < t.length; r++)
            s = e.hasOwnProperty("$" + t[r].value),
            t[r].selected !== s && (t[r].selected = s),
            s && n && (t[r].defaultSelected = !0)
    } else {
        for (r = "" + Wn(r),
        e = null,
        s = 0; s < t.length; s++) {
            if (t[s].value === r) {
                t[s].selected = !0,
                n && (t[s].defaultSelected = !0);
                return
            }
            e !== null || t[s].disabled || (e = t[s])
        }
        e !== null && (e.selected = !0)
    }
}
function $d(t, e) {
    if (e.dangerouslySetInnerHTML != null)
        throw Error(O(91));
    return De({}, e, {
        value: void 0,
        defaultValue: void 0,
        children: "" + t._wrapperState.initialValue
    })
}
function hm(t, e) {
    var r = e.value;
    if (r == null) {
        if (r = e.children,
        e = e.defaultValue,
        r != null) {
            if (e != null)
                throw Error(O(92));
            if (Io(r)) {
                if (1 < r.length)
                    throw Error(O(93));
                r = r[0]
            }
            e = r
        }
        e == null && (e = ""),
        r = e
    }
    t._wrapperState = {
        initialValue: Wn(r)
    }
}
function Ny(t, e) {
    var r = Wn(e.value)
      , n = Wn(e.defaultValue);
    r != null && (r = "" + r,
    r !== t.value && (t.value = r),
    e.defaultValue == null && t.defaultValue !== r && (t.defaultValue = r)),
    n != null && (t.defaultValue = "" + n)
}
function fm(t) {
    var e = t.textContent;
    e === t._wrapperState.initialValue && e !== "" && e !== null && (t.value = e)
}
function Py(t) {
    switch (t) {
    case "svg":
        return "http://www.w3.org/2000/svg";
    case "math":
        return "http://www.w3.org/1998/Math/MathML";
    default:
        return "http://www.w3.org/1999/xhtml"
    }
}
function Dd(t, e) {
    return t == null || t === "http://www.w3.org/1999/xhtml" ? Py(e) : t === "http://www.w3.org/2000/svg" && e === "foreignObject" ? "http://www.w3.org/1999/xhtml" : t
}
var rl, Ay = function(t) {
    return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function(e, r, n, s) {
        MSApp.execUnsafeLocalFunction(function() {
            return t(e, r, n, s)
        })
    }
    : t
}(function(t, e) {
    if (t.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML"in t)
        t.innerHTML = e;
    else {
        for (rl = rl || document.createElement("div"),
        rl.innerHTML = "<svg>" + e.valueOf().toString() + "</svg>",
        e = rl.firstChild; t.firstChild; )
            t.removeChild(t.firstChild);
        for (; e.firstChild; )
            t.appendChild(e.firstChild)
    }
});
function ta(t, e) {
    if (e) {
        var r = t.firstChild;
        if (r && r === t.lastChild && r.nodeType === 3) {
            r.nodeValue = e;
            return
        }
    }
    t.textContent = e
}
var zo = {
    animationIterationCount: !0,
    aspectRatio: !0,
    borderImageOutset: !0,
    borderImageSlice: !0,
    borderImageWidth: !0,
    boxFlex: !0,
    boxFlexGroup: !0,
    boxOrdinalGroup: !0,
    columnCount: !0,
    columns: !0,
    flex: !0,
    flexGrow: !0,
    flexPositive: !0,
    flexShrink: !0,
    flexNegative: !0,
    flexOrder: !0,
    gridArea: !0,
    gridRow: !0,
    gridRowEnd: !0,
    gridRowSpan: !0,
    gridRowStart: !0,
    gridColumn: !0,
    gridColumnEnd: !0,
    gridColumnSpan: !0,
    gridColumnStart: !0,
    fontWeight: !0,
    lineClamp: !0,
    lineHeight: !0,
    opacity: !0,
    order: !0,
    orphans: !0,
    tabSize: !0,
    widows: !0,
    zIndex: !0,
    zoom: !0,
    fillOpacity: !0,
    floodOpacity: !0,
    stopOpacity: !0,
    strokeDasharray: !0,
    strokeDashoffset: !0,
    strokeMiterlimit: !0,
    strokeOpacity: !0,
    strokeWidth: !0
}
  , t1 = ["Webkit", "ms", "Moz", "O"];
Object.keys(zo).forEach(function(t) {
    t1.forEach(function(e) {
        e = e + t.charAt(0).toUpperCase() + t.substring(1),
        zo[e] = zo[t]
    })
});
function jy(t, e, r) {
    return e == null || typeof e == "boolean" || e === "" ? "" : r || typeof e != "number" || e === 0 || zo.hasOwnProperty(t) && zo[t] ? ("" + e).trim() : e + "px"
}
function Oy(t, e) {
    t = t.style;
    for (var r in e)
        if (e.hasOwnProperty(r)) {
            var n = r.indexOf("--") === 0
              , s = jy(r, e[r], n);
            r === "float" && (r = "cssFloat"),
            n ? t.setProperty(r, s) : t[r] = s
        }
}
var r1 = De({
    menuitem: !0
}, {
    area: !0,
    base: !0,
    br: !0,
    col: !0,
    embed: !0,
    hr: !0,
    img: !0,
    input: !0,
    keygen: !0,
    link: !0,
    meta: !0,
    param: !0,
    source: !0,
    track: !0,
    wbr: !0
});
function Md(t, e) {
    if (e) {
        if (r1[t] && (e.children != null || e.dangerouslySetInnerHTML != null))
            throw Error(O(137, t));
        if (e.dangerouslySetInnerHTML != null) {
            if (e.children != null)
                throw Error(O(60));
            if (typeof e.dangerouslySetInnerHTML != "object" || !("__html"in e.dangerouslySetInnerHTML))
                throw Error(O(61))
        }
        if (e.style != null && typeof e.style != "object")
            throw Error(O(62))
    }
}
function Fd(t, e) {
    if (t.indexOf("-") === -1)
        return typeof e.is == "string";
    switch (t) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
        return !1;
    default:
        return !0
    }
}
var Ud = null;
function jf(t) {
    return t = t.target || t.srcElement || window,
    t.correspondingUseElement && (t = t.correspondingUseElement),
    t.nodeType === 3 ? t.parentNode : t
}
var Bd = null
  , Ci = null
  , Ti = null;
function pm(t) {
    if (t = Ua(t)) {
        if (typeof Bd != "function")
            throw Error(O(280));
        var e = t.stateNode;
        e && (e = Wc(e),
        Bd(t.stateNode, t.type, e))
    }
}
function Iy(t) {
    Ci ? Ti ? Ti.push(t) : Ti = [t] : Ci = t
}
function Ly() {
    if (Ci) {
        var t = Ci
          , e = Ti;
        if (Ti = Ci = null,
        pm(t),
        e)
            for (t = 0; t < e.length; t++)
                pm(e[t])
    }
}
function $y(t, e) {
    return t(e)
}
function Dy() {}
var Ou = !1;
function My(t, e, r) {
    if (Ou)
        return t(e, r);
    Ou = !0;
    try {
        return $y(t, e, r)
    } finally {
        Ou = !1,
        (Ci !== null || Ti !== null) && (Dy(),
        Ly())
    }
}
function ra(t, e) {
    var r = t.stateNode;
    if (r === null)
        return null;
    var n = Wc(r);
    if (n === null)
        return null;
    r = n[e];
    e: switch (e) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
        (n = !n.disabled) || (t = t.type,
        n = !(t === "button" || t === "input" || t === "select" || t === "textarea")),
        t = !n;
        break e;
    default:
        t = !1
    }
    if (t)
        return null;
    if (r && typeof r != "function")
        throw Error(O(231, e, typeof r));
    return r
}
var zd = !1;
if (qr)
    try {
        var ko = {};
        Object.defineProperty(ko, "passive", {
            get: function() {
                zd = !0
            }
        }),
        window.addEventListener("test", ko, ko),
        window.removeEventListener("test", ko, ko)
    } catch {
        zd = !1
    }
function n1(t, e, r, n, s, i, o, a, l) {
    var c = Array.prototype.slice.call(arguments, 3);
    try {
        e.apply(r, c)
    } catch (u) {
        this.onError(u)
    }
}
var Vo = !1
  , Jl = null
  , Zl = !1
  , Vd = null
  , s1 = {
    onError: function(t) {
        Vo = !0,
        Jl = t
    }
};
function i1(t, e, r, n, s, i, o, a, l) {
    Vo = !1,
    Jl = null,
    n1.apply(s1, arguments)
}
function o1(t, e, r, n, s, i, o, a, l) {
    if (i1.apply(this, arguments),
    Vo) {
        if (Vo) {
            var c = Jl;
            Vo = !1,
            Jl = null
        } else
            throw Error(O(198));
        Zl || (Zl = !0,
        Vd = c)
    }
}
function Us(t) {
    var e = t
      , r = t;
    if (t.alternate)
        for (; e.return; )
            e = e.return;
    else {
        t = e;
        do
            e = t,
            e.flags & 4098 && (r = e.return),
            t = e.return;
        while (t)
    }
    return e.tag === 3 ? r : null
}
function Fy(t) {
    if (t.tag === 13) {
        var e = t.memoizedState;
        if (e === null && (t = t.alternate,
        t !== null && (e = t.memoizedState)),
        e !== null)
            return e.dehydrated
    }
    return null
}
function mm(t) {
    if (Us(t) !== t)
        throw Error(O(188))
}
function a1(t) {
    var e = t.alternate;
    if (!e) {
        if (e = Us(t),
        e === null)
            throw Error(O(188));
        return e !== t ? null : t
    }
    for (var r = t, n = e; ; ) {
        var s = r.return;
        if (s === null)
            break;
        var i = s.alternate;
        if (i === null) {
            if (n = s.return,
            n !== null) {
                r = n;
                continue
            }
            break
        }
        if (s.child === i.child) {
            for (i = s.child; i; ) {
                if (i === r)
                    return mm(s),
                    t;
                if (i === n)
                    return mm(s),
                    e;
                i = i.sibling
            }
            throw Error(O(188))
        }
        if (r.return !== n.return)
            r = s,
            n = i;
        else {
            for (var o = !1, a = s.child; a; ) {
                if (a === r) {
                    o = !0,
                    r = s,
                    n = i;
                    break
                }
                if (a === n) {
                    o = !0,
                    n = s,
                    r = i;
                    break
                }
                a = a.sibling
            }
            if (!o) {
                for (a = i.child; a; ) {
                    if (a === r) {
                        o = !0,
                        r = i,
                        n = s;
                        break
                    }
                    if (a === n) {
                        o = !0,
                        n = i,
                        r = s;
                        break
                    }
                    a = a.sibling
                }
                if (!o)
                    throw Error(O(189))
            }
        }
        if (r.alternate !== n)
            throw Error(O(190))
    }
    if (r.tag !== 3)
        throw Error(O(188));
    return r.stateNode.current === r ? t : e
}
function Uy(t) {
    return t = a1(t),
    t !== null ? By(t) : null
}
function By(t) {
    if (t.tag === 5 || t.tag === 6)
        return t;
    for (t = t.child; t !== null; ) {
        var e = By(t);
        if (e !== null)
            return e;
        t = t.sibling
    }
    return null
}
var zy = Ft.unstable_scheduleCallback
  , gm = Ft.unstable_cancelCallback
  , l1 = Ft.unstable_shouldYield
  , c1 = Ft.unstable_requestPaint
  , He = Ft.unstable_now
  , u1 = Ft.unstable_getCurrentPriorityLevel
  , Of = Ft.unstable_ImmediatePriority
  , Vy = Ft.unstable_UserBlockingPriority
  , Yl = Ft.unstable_NormalPriority
  , d1 = Ft.unstable_LowPriority
  , Wy = Ft.unstable_IdlePriority
  , Uc = null
  , Ar = null;
function h1(t) {
    if (Ar && typeof Ar.onCommitFiberRoot == "function")
        try {
            Ar.onCommitFiberRoot(Uc, t, void 0, (t.current.flags & 128) === 128)
        } catch {}
}
var vr = Math.clz32 ? Math.clz32 : m1
  , f1 = Math.log
  , p1 = Math.LN2;
function m1(t) {
    return t >>>= 0,
    t === 0 ? 32 : 31 - (f1(t) / p1 | 0) | 0
}
var nl = 64
  , sl = 4194304;
function Lo(t) {
    switch (t & -t) {
    case 1:
        return 1;
    case 2:
        return 2;
    case 4:
        return 4;
    case 8:
        return 8;
    case 16:
        return 16;
    case 32:
        return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return t & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return t & 130023424;
    case 134217728:
        return 134217728;
    case 268435456:
        return 268435456;
    case 536870912:
        return 536870912;
    case 1073741824:
        return 1073741824;
    default:
        return t
    }
}
function Xl(t, e) {
    var r = t.pendingLanes;
    if (r === 0)
        return 0;
    var n = 0
      , s = t.suspendedLanes
      , i = t.pingedLanes
      , o = r & 268435455;
    if (o !== 0) {
        var a = o & ~s;
        a !== 0 ? n = Lo(a) : (i &= o,
        i !== 0 && (n = Lo(i)))
    } else
        o = r & ~s,
        o !== 0 ? n = Lo(o) : i !== 0 && (n = Lo(i));
    if (n === 0)
        return 0;
    if (e !== 0 && e !== n && !(e & s) && (s = n & -n,
    i = e & -e,
    s >= i || s === 16 && (i & 4194240) !== 0))
        return e;
    if (n & 4 && (n |= r & 16),
    e = t.entangledLanes,
    e !== 0)
        for (t = t.entanglements,
        e &= n; 0 < e; )
            r = 31 - vr(e),
            s = 1 << r,
            n |= t[r],
            e &= ~s;
    return n
}
function g1(t, e) {
    switch (t) {
    case 1:
    case 2:
    case 4:
        return e + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
        return e + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
        return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
        return -1;
    default:
        return -1
    }
}
function v1(t, e) {
    for (var r = t.suspendedLanes, n = t.pingedLanes, s = t.expirationTimes, i = t.pendingLanes; 0 < i; ) {
        var o = 31 - vr(i)
          , a = 1 << o
          , l = s[o];
        l === -1 ? (!(a & r) || a & n) && (s[o] = g1(a, e)) : l <= e && (t.expiredLanes |= a),
        i &= ~a
    }
}
function Wd(t) {
    return t = t.pendingLanes & -1073741825,
    t !== 0 ? t : t & 1073741824 ? 1073741824 : 0
}
function Hy() {
    var t = nl;
    return nl <<= 1,
    !(nl & 4194240) && (nl = 64),
    t
}
function Iu(t) {
    for (var e = [], r = 0; 31 > r; r++)
        e.push(t);
    return e
}
function Ma(t, e, r) {
    t.pendingLanes |= e,
    e !== 536870912 && (t.suspendedLanes = 0,
    t.pingedLanes = 0),
    t = t.eventTimes,
    e = 31 - vr(e),
    t[e] = r
}
function y1(t, e) {
    var r = t.pendingLanes & ~e;
    t.pendingLanes = e,
    t.suspendedLanes = 0,
    t.pingedLanes = 0,
    t.expiredLanes &= e,
    t.mutableReadLanes &= e,
    t.entangledLanes &= e,
    e = t.entanglements;
    var n = t.eventTimes;
    for (t = t.expirationTimes; 0 < r; ) {
        var s = 31 - vr(r)
          , i = 1 << s;
        e[s] = 0,
        n[s] = -1,
        t[s] = -1,
        r &= ~i
    }
}
function If(t, e) {
    var r = t.entangledLanes |= e;
    for (t = t.entanglements; r; ) {
        var n = 31 - vr(r)
          , s = 1 << n;
        s & e | t[n] & e && (t[n] |= e),
        r &= ~s
    }
}
var _e = 0;
function Ky(t) {
    return t &= -t,
    1 < t ? 4 < t ? t & 268435455 ? 16 : 536870912 : 4 : 1
}
var qy, Lf, Gy, Qy, Jy, Hd = !1, il = [], jn = null, On = null, In = null, na = new Map, sa = new Map, vn = [], w1 = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function vm(t, e) {
    switch (t) {
    case "focusin":
    case "focusout":
        jn = null;
        break;
    case "dragenter":
    case "dragleave":
        On = null;
        break;
    case "mouseover":
    case "mouseout":
        In = null;
        break;
    case "pointerover":
    case "pointerout":
        na.delete(e.pointerId);
        break;
    case "gotpointercapture":
    case "lostpointercapture":
        sa.delete(e.pointerId)
    }
}
function Eo(t, e, r, n, s, i) {
    return t === null || t.nativeEvent !== i ? (t = {
        blockedOn: e,
        domEventName: r,
        eventSystemFlags: n,
        nativeEvent: i,
        targetContainers: [s]
    },
    e !== null && (e = Ua(e),
    e !== null && Lf(e)),
    t) : (t.eventSystemFlags |= n,
    e = t.targetContainers,
    s !== null && e.indexOf(s) === -1 && e.push(s),
    t)
}
function x1(t, e, r, n, s) {
    switch (e) {
    case "focusin":
        return jn = Eo(jn, t, e, r, n, s),
        !0;
    case "dragenter":
        return On = Eo(On, t, e, r, n, s),
        !0;
    case "mouseover":
        return In = Eo(In, t, e, r, n, s),
        !0;
    case "pointerover":
        var i = s.pointerId;
        return na.set(i, Eo(na.get(i) || null, t, e, r, n, s)),
        !0;
    case "gotpointercapture":
        return i = s.pointerId,
        sa.set(i, Eo(sa.get(i) || null, t, e, r, n, s)),
        !0
    }
    return !1
}
function Zy(t) {
    var e = ps(t.target);
    if (e !== null) {
        var r = Us(e);
        if (r !== null) {
            if (e = r.tag,
            e === 13) {
                if (e = Fy(r),
                e !== null) {
                    t.blockedOn = e,
                    Jy(t.priority, function() {
                        Gy(r)
                    });
                    return
                }
            } else if (e === 3 && r.stateNode.current.memoizedState.isDehydrated) {
                t.blockedOn = r.tag === 3 ? r.stateNode.containerInfo : null;
                return
            }
        }
    }
    t.blockedOn = null
}
function Ol(t) {
    if (t.blockedOn !== null)
        return !1;
    for (var e = t.targetContainers; 0 < e.length; ) {
        var r = Kd(t.domEventName, t.eventSystemFlags, e[0], t.nativeEvent);
        if (r === null) {
            r = t.nativeEvent;
            var n = new r.constructor(r.type,r);
            Ud = n,
            r.target.dispatchEvent(n),
            Ud = null
        } else
            return e = Ua(r),
            e !== null && Lf(e),
            t.blockedOn = r,
            !1;
        e.shift()
    }
    return !0
}
function ym(t, e, r) {
    Ol(t) && r.delete(e)
}
function b1() {
    Hd = !1,
    jn !== null && Ol(jn) && (jn = null),
    On !== null && Ol(On) && (On = null),
    In !== null && Ol(In) && (In = null),
    na.forEach(ym),
    sa.forEach(ym)
}
function Co(t, e) {
    t.blockedOn === e && (t.blockedOn = null,
    Hd || (Hd = !0,
    Ft.unstable_scheduleCallback(Ft.unstable_NormalPriority, b1)))
}
function ia(t) {
    function e(s) {
        return Co(s, t)
    }
    if (0 < il.length) {
        Co(il[0], t);
        for (var r = 1; r < il.length; r++) {
            var n = il[r];
            n.blockedOn === t && (n.blockedOn = null)
        }
    }
    for (jn !== null && Co(jn, t),
    On !== null && Co(On, t),
    In !== null && Co(In, t),
    na.forEach(e),
    sa.forEach(e),
    r = 0; r < vn.length; r++)
        n = vn[r],
        n.blockedOn === t && (n.blockedOn = null);
    for (; 0 < vn.length && (r = vn[0],
    r.blockedOn === null); )
        Zy(r),
        r.blockedOn === null && vn.shift()
}
var Ri = en.ReactCurrentBatchConfig
  , ec = !0;
function _1(t, e, r, n) {
    var s = _e
      , i = Ri.transition;
    Ri.transition = null;
    try {
        _e = 1,
        $f(t, e, r, n)
    } finally {
        _e = s,
        Ri.transition = i
    }
}
function S1(t, e, r, n) {
    var s = _e
      , i = Ri.transition;
    Ri.transition = null;
    try {
        _e = 4,
        $f(t, e, r, n)
    } finally {
        _e = s,
        Ri.transition = i
    }
}
function $f(t, e, r, n) {
    if (ec) {
        var s = Kd(t, e, r, n);
        if (s === null)
            Wu(t, e, n, tc, r),
            vm(t, n);
        else if (x1(s, t, e, r, n))
            n.stopPropagation();
        else if (vm(t, n),
        e & 4 && -1 < w1.indexOf(t)) {
            for (; s !== null; ) {
                var i = Ua(s);
                if (i !== null && qy(i),
                i = Kd(t, e, r, n),
                i === null && Wu(t, e, n, tc, r),
                i === s)
                    break;
                s = i
            }
            s !== null && n.stopPropagation()
        } else
            Wu(t, e, n, null, r)
    }
}
var tc = null;
function Kd(t, e, r, n) {
    if (tc = null,
    t = jf(n),
    t = ps(t),
    t !== null)
        if (e = Us(t),
        e === null)
            t = null;
        else if (r = e.tag,
        r === 13) {
            if (t = Fy(e),
            t !== null)
                return t;
            t = null
        } else if (r === 3) {
            if (e.stateNode.current.memoizedState.isDehydrated)
                return e.tag === 3 ? e.stateNode.containerInfo : null;
            t = null
        } else
            e !== t && (t = null);
    return tc = t,
    null
}
function Yy(t) {
    switch (t) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
        return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
        return 4;
    case "message":
        switch (u1()) {
        case Of:
            return 1;
        case Vy:
            return 4;
        case Yl:
        case d1:
            return 16;
        case Wy:
            return 536870912;
        default:
            return 16
        }
    default:
        return 16
    }
}
var Rn = null
  , Df = null
  , Il = null;
function Xy() {
    if (Il)
        return Il;
    var t, e = Df, r = e.length, n, s = "value"in Rn ? Rn.value : Rn.textContent, i = s.length;
    for (t = 0; t < r && e[t] === s[t]; t++)
        ;
    var o = r - t;
    for (n = 1; n <= o && e[r - n] === s[i - n]; n++)
        ;
    return Il = s.slice(t, 1 < n ? 1 - n : void 0)
}
function Ll(t) {
    var e = t.keyCode;
    return "charCode"in t ? (t = t.charCode,
    t === 0 && e === 13 && (t = 13)) : t = e,
    t === 10 && (t = 13),
    32 <= t || t === 13 ? t : 0
}
function ol() {
    return !0
}
function wm() {
    return !1
}
function zt(t) {
    function e(r, n, s, i, o) {
        this._reactName = r,
        this._targetInst = s,
        this.type = n,
        this.nativeEvent = i,
        this.target = o,
        this.currentTarget = null;
        for (var a in t)
            t.hasOwnProperty(a) && (r = t[a],
            this[a] = r ? r(i) : i[a]);
        return this.isDefaultPrevented = (i.defaultPrevented != null ? i.defaultPrevented : i.returnValue === !1) ? ol : wm,
        this.isPropagationStopped = wm,
        this
    }
    return De(e.prototype, {
        preventDefault: function() {
            this.defaultPrevented = !0;
            var r = this.nativeEvent;
            r && (r.preventDefault ? r.preventDefault() : typeof r.returnValue != "unknown" && (r.returnValue = !1),
            this.isDefaultPrevented = ol)
        },
        stopPropagation: function() {
            var r = this.nativeEvent;
            r && (r.stopPropagation ? r.stopPropagation() : typeof r.cancelBubble != "unknown" && (r.cancelBubble = !0),
            this.isPropagationStopped = ol)
        },
        persist: function() {},
        isPersistent: ol
    }),
    e
}
var fo = {
    eventPhase: 0,
    bubbles: 0,
    cancelable: 0,
    timeStamp: function(t) {
        return t.timeStamp || Date.now()
    },
    defaultPrevented: 0,
    isTrusted: 0
}, Mf = zt(fo), Fa = De({}, fo, {
    view: 0,
    detail: 0
}), k1 = zt(Fa), Lu, $u, To, Bc = De({}, Fa, {
    screenX: 0,
    screenY: 0,
    clientX: 0,
    clientY: 0,
    pageX: 0,
    pageY: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    getModifierState: Ff,
    button: 0,
    buttons: 0,
    relatedTarget: function(t) {
        return t.relatedTarget === void 0 ? t.fromElement === t.srcElement ? t.toElement : t.fromElement : t.relatedTarget
    },
    movementX: function(t) {
        return "movementX"in t ? t.movementX : (t !== To && (To && t.type === "mousemove" ? (Lu = t.screenX - To.screenX,
        $u = t.screenY - To.screenY) : $u = Lu = 0,
        To = t),
        Lu)
    },
    movementY: function(t) {
        return "movementY"in t ? t.movementY : $u
    }
}), xm = zt(Bc), E1 = De({}, Bc, {
    dataTransfer: 0
}), C1 = zt(E1), T1 = De({}, Fa, {
    relatedTarget: 0
}), Du = zt(T1), R1 = De({}, fo, {
    animationName: 0,
    elapsedTime: 0,
    pseudoElement: 0
}), N1 = zt(R1), P1 = De({}, fo, {
    clipboardData: function(t) {
        return "clipboardData"in t ? t.clipboardData : window.clipboardData
    }
}), A1 = zt(P1), j1 = De({}, fo, {
    data: 0
}), bm = zt(j1), O1 = {
    Esc: "Escape",
    Spacebar: " ",
    Left: "ArrowLeft",
    Up: "ArrowUp",
    Right: "ArrowRight",
    Down: "ArrowDown",
    Del: "Delete",
    Win: "OS",
    Menu: "ContextMenu",
    Apps: "ContextMenu",
    Scroll: "ScrollLock",
    MozPrintableKey: "Unidentified"
}, I1 = {
    8: "Backspace",
    9: "Tab",
    12: "Clear",
    13: "Enter",
    16: "Shift",
    17: "Control",
    18: "Alt",
    19: "Pause",
    20: "CapsLock",
    27: "Escape",
    32: " ",
    33: "PageUp",
    34: "PageDown",
    35: "End",
    36: "Home",
    37: "ArrowLeft",
    38: "ArrowUp",
    39: "ArrowRight",
    40: "ArrowDown",
    45: "Insert",
    46: "Delete",
    112: "F1",
    113: "F2",
    114: "F3",
    115: "F4",
    116: "F5",
    117: "F6",
    118: "F7",
    119: "F8",
    120: "F9",
    121: "F10",
    122: "F11",
    123: "F12",
    144: "NumLock",
    145: "ScrollLock",
    224: "Meta"
}, L1 = {
    Alt: "altKey",
    Control: "ctrlKey",
    Meta: "metaKey",
    Shift: "shiftKey"
};
function $1(t) {
    var e = this.nativeEvent;
    return e.getModifierState ? e.getModifierState(t) : (t = L1[t]) ? !!e[t] : !1
}
function Ff() {
    return $1
}
var D1 = De({}, Fa, {
    key: function(t) {
        if (t.key) {
            var e = O1[t.key] || t.key;
            if (e !== "Unidentified")
                return e
        }
        return t.type === "keypress" ? (t = Ll(t),
        t === 13 ? "Enter" : String.fromCharCode(t)) : t.type === "keydown" || t.type === "keyup" ? I1[t.keyCode] || "Unidentified" : ""
    },
    code: 0,
    location: 0,
    ctrlKey: 0,
    shiftKey: 0,
    altKey: 0,
    metaKey: 0,
    repeat: 0,
    locale: 0,
    getModifierState: Ff,
    charCode: function(t) {
        return t.type === "keypress" ? Ll(t) : 0
    },
    keyCode: function(t) {
        return t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
    },
    which: function(t) {
        return t.type === "keypress" ? Ll(t) : t.type === "keydown" || t.type === "keyup" ? t.keyCode : 0
    }
})
  , M1 = zt(D1)
  , F1 = De({}, Bc, {
    pointerId: 0,
    width: 0,
    height: 0,
    pressure: 0,
    tangentialPressure: 0,
    tiltX: 0,
    tiltY: 0,
    twist: 0,
    pointerType: 0,
    isPrimary: 0
})
  , _m = zt(F1)
  , U1 = De({}, Fa, {
    touches: 0,
    targetTouches: 0,
    changedTouches: 0,
    altKey: 0,
    metaKey: 0,
    ctrlKey: 0,
    shiftKey: 0,
    getModifierState: Ff
})
  , B1 = zt(U1)
  , z1 = De({}, fo, {
    propertyName: 0,
    elapsedTime: 0,
    pseudoElement: 0
})
  , V1 = zt(z1)
  , W1 = De({}, Bc, {
    deltaX: function(t) {
        return "deltaX"in t ? t.deltaX : "wheelDeltaX"in t ? -t.wheelDeltaX : 0
    },
    deltaY: function(t) {
        return "deltaY"in t ? t.deltaY : "wheelDeltaY"in t ? -t.wheelDeltaY : "wheelDelta"in t ? -t.wheelDelta : 0
    },
    deltaZ: 0,
    deltaMode: 0
})
  , H1 = zt(W1)
  , K1 = [9, 13, 27, 32]
  , Uf = qr && "CompositionEvent"in window
  , Wo = null;
qr && "documentMode"in document && (Wo = document.documentMode);
var q1 = qr && "TextEvent"in window && !Wo
  , e0 = qr && (!Uf || Wo && 8 < Wo && 11 >= Wo)
  , Sm = " "
  , km = !1;
function t0(t, e) {
    switch (t) {
    case "keyup":
        return K1.indexOf(e.keyCode) !== -1;
    case "keydown":
        return e.keyCode !== 229;
    case "keypress":
    case "mousedown":
    case "focusout":
        return !0;
    default:
        return !1
    }
}
function r0(t) {
    return t = t.detail,
    typeof t == "object" && "data"in t ? t.data : null
}
var hi = !1;
function G1(t, e) {
    switch (t) {
    case "compositionend":
        return r0(e);
    case "keypress":
        return e.which !== 32 ? null : (km = !0,
        Sm);
    case "textInput":
        return t = e.data,
        t === Sm && km ? null : t;
    default:
        return null
    }
}
function Q1(t, e) {
    if (hi)
        return t === "compositionend" || !Uf && t0(t, e) ? (t = Xy(),
        Il = Df = Rn = null,
        hi = !1,
        t) : null;
    switch (t) {
    case "paste":
        return null;
    case "keypress":
        if (!(e.ctrlKey || e.altKey || e.metaKey) || e.ctrlKey && e.altKey) {
            if (e.char && 1 < e.char.length)
                return e.char;
            if (e.which)
                return String.fromCharCode(e.which)
        }
        return null;
    case "compositionend":
        return e0 && e.locale !== "ko" ? null : e.data;
    default:
        return null
    }
}
var J1 = {
    color: !0,
    date: !0,
    datetime: !0,
    "datetime-local": !0,
    email: !0,
    month: !0,
    number: !0,
    password: !0,
    range: !0,
    search: !0,
    tel: !0,
    text: !0,
    time: !0,
    url: !0,
    week: !0
};
function Em(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e === "input" ? !!J1[t.type] : e === "textarea"
}
function n0(t, e, r, n) {
    Iy(n),
    e = rc(e, "onChange"),
    0 < e.length && (r = new Mf("onChange","change",null,r,n),
    t.push({
        event: r,
        listeners: e
    }))
}
var Ho = null
  , oa = null;
function Z1(t) {
    p0(t, 0)
}
function zc(t) {
    var e = mi(t);
    if (Ty(e))
        return t
}
function Y1(t, e) {
    if (t === "change")
        return e
}
var s0 = !1;
if (qr) {
    var Mu;
    if (qr) {
        var Fu = "oninput"in document;
        if (!Fu) {
            var Cm = document.createElement("div");
            Cm.setAttribute("oninput", "return;"),
            Fu = typeof Cm.oninput == "function"
        }
        Mu = Fu
    } else
        Mu = !1;
    s0 = Mu && (!document.documentMode || 9 < document.documentMode)
}
function Tm() {
    Ho && (Ho.detachEvent("onpropertychange", i0),
    oa = Ho = null)
}
function i0(t) {
    if (t.propertyName === "value" && zc(oa)) {
        var e = [];
        n0(e, oa, t, jf(t)),
        My(Z1, e)
    }
}
function X1(t, e, r) {
    t === "focusin" ? (Tm(),
    Ho = e,
    oa = r,
    Ho.attachEvent("onpropertychange", i0)) : t === "focusout" && Tm()
}
function ek(t) {
    if (t === "selectionchange" || t === "keyup" || t === "keydown")
        return zc(oa)
}
function tk(t, e) {
    if (t === "click")
        return zc(e)
}
function rk(t, e) {
    if (t === "input" || t === "change")
        return zc(e)
}
function nk(t, e) {
    return t === e && (t !== 0 || 1 / t === 1 / e) || t !== t && e !== e
}
var wr = typeof Object.is == "function" ? Object.is : nk;
function aa(t, e) {
    if (wr(t, e))
        return !0;
    if (typeof t != "object" || t === null || typeof e != "object" || e === null)
        return !1;
    var r = Object.keys(t)
      , n = Object.keys(e);
    if (r.length !== n.length)
        return !1;
    for (n = 0; n < r.length; n++) {
        var s = r[n];
        if (!Rd.call(e, s) || !wr(t[s], e[s]))
            return !1
    }
    return !0
}
function Rm(t) {
    for (; t && t.firstChild; )
        t = t.firstChild;
    return t
}
function Nm(t, e) {
    var r = Rm(t);
    t = 0;
    for (var n; r; ) {
        if (r.nodeType === 3) {
            if (n = t + r.textContent.length,
            t <= e && n >= e)
                return {
                    node: r,
                    offset: e - t
                };
            t = n
        }
        e: {
            for (; r; ) {
                if (r.nextSibling) {
                    r = r.nextSibling;
                    break e
                }
                r = r.parentNode
            }
            r = void 0
        }
        r = Rm(r)
    }
}
function o0(t, e) {
    return t && e ? t === e ? !0 : t && t.nodeType === 3 ? !1 : e && e.nodeType === 3 ? o0(t, e.parentNode) : "contains"in t ? t.contains(e) : t.compareDocumentPosition ? !!(t.compareDocumentPosition(e) & 16) : !1 : !1
}
function a0() {
    for (var t = window, e = Ql(); e instanceof t.HTMLIFrameElement; ) {
        try {
            var r = typeof e.contentWindow.location.href == "string"
        } catch {
            r = !1
        }
        if (r)
            t = e.contentWindow;
        else
            break;
        e = Ql(t.document)
    }
    return e
}
function Bf(t) {
    var e = t && t.nodeName && t.nodeName.toLowerCase();
    return e && (e === "input" && (t.type === "text" || t.type === "search" || t.type === "tel" || t.type === "url" || t.type === "password") || e === "textarea" || t.contentEditable === "true")
}
function sk(t) {
    var e = a0()
      , r = t.focusedElem
      , n = t.selectionRange;
    if (e !== r && r && r.ownerDocument && o0(r.ownerDocument.documentElement, r)) {
        if (n !== null && Bf(r)) {
            if (e = n.start,
            t = n.end,
            t === void 0 && (t = e),
            "selectionStart"in r)
                r.selectionStart = e,
                r.selectionEnd = Math.min(t, r.value.length);
            else if (t = (e = r.ownerDocument || document) && e.defaultView || window,
            t.getSelection) {
                t = t.getSelection();
                var s = r.textContent.length
                  , i = Math.min(n.start, s);
                n = n.end === void 0 ? i : Math.min(n.end, s),
                !t.extend && i > n && (s = n,
                n = i,
                i = s),
                s = Nm(r, i);
                var o = Nm(r, n);
                s && o && (t.rangeCount !== 1 || t.anchorNode !== s.node || t.anchorOffset !== s.offset || t.focusNode !== o.node || t.focusOffset !== o.offset) && (e = e.createRange(),
                e.setStart(s.node, s.offset),
                t.removeAllRanges(),
                i > n ? (t.addRange(e),
                t.extend(o.node, o.offset)) : (e.setEnd(o.node, o.offset),
                t.addRange(e)))
            }
        }
        for (e = [],
        t = r; t = t.parentNode; )
            t.nodeType === 1 && e.push({
                element: t,
                left: t.scrollLeft,
                top: t.scrollTop
            });
        for (typeof r.focus == "function" && r.focus(),
        r = 0; r < e.length; r++)
            t = e[r],
            t.element.scrollLeft = t.left,
            t.element.scrollTop = t.top
    }
}
var ik = qr && "documentMode"in document && 11 >= document.documentMode
  , fi = null
  , qd = null
  , Ko = null
  , Gd = !1;
function Pm(t, e, r) {
    var n = r.window === r ? r.document : r.nodeType === 9 ? r : r.ownerDocument;
    Gd || fi == null || fi !== Ql(n) || (n = fi,
    "selectionStart"in n && Bf(n) ? n = {
        start: n.selectionStart,
        end: n.selectionEnd
    } : (n = (n.ownerDocument && n.ownerDocument.defaultView || window).getSelection(),
    n = {
        anchorNode: n.anchorNode,
        anchorOffset: n.anchorOffset,
        focusNode: n.focusNode,
        focusOffset: n.focusOffset
    }),
    Ko && aa(Ko, n) || (Ko = n,
    n = rc(qd, "onSelect"),
    0 < n.length && (e = new Mf("onSelect","select",null,e,r),
    t.push({
        event: e,
        listeners: n
    }),
    e.target = fi)))
}
function al(t, e) {
    var r = {};
    return r[t.toLowerCase()] = e.toLowerCase(),
    r["Webkit" + t] = "webkit" + e,
    r["Moz" + t] = "moz" + e,
    r
}
var pi = {
    animationend: al("Animation", "AnimationEnd"),
    animationiteration: al("Animation", "AnimationIteration"),
    animationstart: al("Animation", "AnimationStart"),
    transitionend: al("Transition", "TransitionEnd")
}
  , Uu = {}
  , l0 = {};
qr && (l0 = document.createElement("div").style,
"AnimationEvent"in window || (delete pi.animationend.animation,
delete pi.animationiteration.animation,
delete pi.animationstart.animation),
"TransitionEvent"in window || delete pi.transitionend.transition);
function Vc(t) {
    if (Uu[t])
        return Uu[t];
    if (!pi[t])
        return t;
    var e = pi[t], r;
    for (r in e)
        if (e.hasOwnProperty(r) && r in l0)
            return Uu[t] = e[r];
    return t
}
var c0 = Vc("animationend")
  , u0 = Vc("animationiteration")
  , d0 = Vc("animationstart")
  , h0 = Vc("transitionend")
  , f0 = new Map
  , Am = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function Zn(t, e) {
    f0.set(t, e),
    Fs(e, [t])
}
for (var Bu = 0; Bu < Am.length; Bu++) {
    var zu = Am[Bu]
      , ok = zu.toLowerCase()
      , ak = zu[0].toUpperCase() + zu.slice(1);
    Zn(ok, "on" + ak)
}
Zn(c0, "onAnimationEnd");
Zn(u0, "onAnimationIteration");
Zn(d0, "onAnimationStart");
Zn("dblclick", "onDoubleClick");
Zn("focusin", "onFocus");
Zn("focusout", "onBlur");
Zn(h0, "onTransitionEnd");
Ji("onMouseEnter", ["mouseout", "mouseover"]);
Ji("onMouseLeave", ["mouseout", "mouseover"]);
Ji("onPointerEnter", ["pointerout", "pointerover"]);
Ji("onPointerLeave", ["pointerout", "pointerover"]);
Fs("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
Fs("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
Fs("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
Fs("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
Fs("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
Fs("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var $o = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" ")
  , lk = new Set("cancel close invalid load scroll toggle".split(" ").concat($o));
function jm(t, e, r) {
    var n = t.type || "unknown-event";
    t.currentTarget = r,
    o1(n, e, void 0, t),
    t.currentTarget = null
}
function p0(t, e) {
    e = (e & 4) !== 0;
    for (var r = 0; r < t.length; r++) {
        var n = t[r]
          , s = n.event;
        n = n.listeners;
        e: {
            var i = void 0;
            if (e)
                for (var o = n.length - 1; 0 <= o; o--) {
                    var a = n[o]
                      , l = a.instance
                      , c = a.currentTarget;
                    if (a = a.listener,
                    l !== i && s.isPropagationStopped())
                        break e;
                    jm(s, a, c),
                    i = l
                }
            else
                for (o = 0; o < n.length; o++) {
                    if (a = n[o],
                    l = a.instance,
                    c = a.currentTarget,
                    a = a.listener,
                    l !== i && s.isPropagationStopped())
                        break e;
                    jm(s, a, c),
                    i = l
                }
        }
    }
    if (Zl)
        throw t = Vd,
        Zl = !1,
        Vd = null,
        t
}
function Ne(t, e) {
    var r = e[Xd];
    r === void 0 && (r = e[Xd] = new Set);
    var n = t + "__bubble";
    r.has(n) || (m0(e, t, 2, !1),
    r.add(n))
}
function Vu(t, e, r) {
    var n = 0;
    e && (n |= 4),
    m0(r, t, n, e)
}
var ll = "_reactListening" + Math.random().toString(36).slice(2);
function la(t) {
    if (!t[ll]) {
        t[ll] = !0,
        _y.forEach(function(r) {
            r !== "selectionchange" && (lk.has(r) || Vu(r, !1, t),
            Vu(r, !0, t))
        });
        var e = t.nodeType === 9 ? t : t.ownerDocument;
        e === null || e[ll] || (e[ll] = !0,
        Vu("selectionchange", !1, e))
    }
}
function m0(t, e, r, n) {
    switch (Yy(e)) {
    case 1:
        var s = _1;
        break;
    case 4:
        s = S1;
        break;
    default:
        s = $f
    }
    r = s.bind(null, e, r, t),
    s = void 0,
    !zd || e !== "touchstart" && e !== "touchmove" && e !== "wheel" || (s = !0),
    n ? s !== void 0 ? t.addEventListener(e, r, {
        capture: !0,
        passive: s
    }) : t.addEventListener(e, r, !0) : s !== void 0 ? t.addEventListener(e, r, {
        passive: s
    }) : t.addEventListener(e, r, !1)
}
function Wu(t, e, r, n, s) {
    var i = n;
    if (!(e & 1) && !(e & 2) && n !== null)
        e: for (; ; ) {
            if (n === null)
                return;
            var o = n.tag;
            if (o === 3 || o === 4) {
                var a = n.stateNode.containerInfo;
                if (a === s || a.nodeType === 8 && a.parentNode === s)
                    break;
                if (o === 4)
                    for (o = n.return; o !== null; ) {
                        var l = o.tag;
                        if ((l === 3 || l === 4) && (l = o.stateNode.containerInfo,
                        l === s || l.nodeType === 8 && l.parentNode === s))
                            return;
                        o = o.return
                    }
                for (; a !== null; ) {
                    if (o = ps(a),
                    o === null)
                        return;
                    if (l = o.tag,
                    l === 5 || l === 6) {
                        n = i = o;
                        continue e
                    }
                    a = a.parentNode
                }
            }
            n = n.return
        }
    My(function() {
        var c = i
          , u = jf(r)
          , h = [];
        e: {
            var p = f0.get(t);
            if (p !== void 0) {
                var f = Mf
                  , b = t;
                switch (t) {
                case "keypress":
                    if (Ll(r) === 0)
                        break e;
                case "keydown":
                case "keyup":
                    f = M1;
                    break;
                case "focusin":
                    b = "focus",
                    f = Du;
                    break;
                case "focusout":
                    b = "blur",
                    f = Du;
                    break;
                case "beforeblur":
                case "afterblur":
                    f = Du;
                    break;
                case "click":
                    if (r.button === 2)
                        break e;
                case "auxclick":
                case "dblclick":
                case "mousedown":
                case "mousemove":
                case "mouseup":
                case "mouseout":
                case "mouseover":
                case "contextmenu":
                    f = xm;
                    break;
                case "drag":
                case "dragend":
                case "dragenter":
                case "dragexit":
                case "dragleave":
                case "dragover":
                case "dragstart":
                case "drop":
                    f = C1;
                    break;
                case "touchcancel":
                case "touchend":
                case "touchmove":
                case "touchstart":
                    f = B1;
                    break;
                case c0:
                case u0:
                case d0:
                    f = N1;
                    break;
                case h0:
                    f = V1;
                    break;
                case "scroll":
                    f = k1;
                    break;
                case "wheel":
                    f = H1;
                    break;
                case "copy":
                case "cut":
                case "paste":
                    f = A1;
                    break;
                case "gotpointercapture":
                case "lostpointercapture":
                case "pointercancel":
                case "pointerdown":
                case "pointermove":
                case "pointerout":
                case "pointerover":
                case "pointerup":
                    f = _m
                }
                var m = (e & 4) !== 0
                  , x = !m && t === "scroll"
                  , w = m ? p !== null ? p + "Capture" : null : p;
                m = [];
                for (var g = c, v; g !== null; ) {
                    v = g;
                    var _ = v.stateNode;
                    if (v.tag === 5 && _ !== null && (v = _,
                    w !== null && (_ = ra(g, w),
                    _ != null && m.push(ca(g, _, v)))),
                    x)
                        break;
                    g = g.return
                }
                0 < m.length && (p = new f(p,b,null,r,u),
                h.push({
                    event: p,
                    listeners: m
                }))
            }
        }
        if (!(e & 7)) {
            e: {
                if (p = t === "mouseover" || t === "pointerover",
                f = t === "mouseout" || t === "pointerout",
                p && r !== Ud && (b = r.relatedTarget || r.fromElement) && (ps(b) || b[Gr]))
                    break e;
                if ((f || p) && (p = u.window === u ? u : (p = u.ownerDocument) ? p.defaultView || p.parentWindow : window,
                f ? (b = r.relatedTarget || r.toElement,
                f = c,
                b = b ? ps(b) : null,
                b !== null && (x = Us(b),
                b !== x || b.tag !== 5 && b.tag !== 6) && (b = null)) : (f = null,
                b = c),
                f !== b)) {
                    if (m = xm,
                    _ = "onMouseLeave",
                    w = "onMouseEnter",
                    g = "mouse",
                    (t === "pointerout" || t === "pointerover") && (m = _m,
                    _ = "onPointerLeave",
                    w = "onPointerEnter",
                    g = "pointer"),
                    x = f == null ? p : mi(f),
                    v = b == null ? p : mi(b),
                    p = new m(_,g + "leave",f,r,u),
                    p.target = x,
                    p.relatedTarget = v,
                    _ = null,
                    ps(u) === c && (m = new m(w,g + "enter",b,r,u),
                    m.target = v,
                    m.relatedTarget = x,
                    _ = m),
                    x = _,
                    f && b)
                        t: {
                            for (m = f,
                            w = b,
                            g = 0,
                            v = m; v; v = Qs(v))
                                g++;
                            for (v = 0,
                            _ = w; _; _ = Qs(_))
                                v++;
                            for (; 0 < g - v; )
                                m = Qs(m),
                                g--;
                            for (; 0 < v - g; )
                                w = Qs(w),
                                v--;
                            for (; g--; ) {
                                if (m === w || w !== null && m === w.alternate)
                                    break t;
                                m = Qs(m),
                                w = Qs(w)
                            }
                            m = null
                        }
                    else
                        m = null;
                    f !== null && Om(h, p, f, m, !1),
                    b !== null && x !== null && Om(h, x, b, m, !0)
                }
            }
            e: {
                if (p = c ? mi(c) : window,
                f = p.nodeName && p.nodeName.toLowerCase(),
                f === "select" || f === "input" && p.type === "file")
                    var S = Y1;
                else if (Em(p))
                    if (s0)
                        S = rk;
                    else {
                        S = ek;
                        var k = X1
                    }
                else
                    (f = p.nodeName) && f.toLowerCase() === "input" && (p.type === "checkbox" || p.type === "radio") && (S = tk);
                if (S && (S = S(t, c))) {
                    n0(h, S, r, u);
                    break e
                }
                k && k(t, p, c),
                t === "focusout" && (k = p._wrapperState) && k.controlled && p.type === "number" && Ld(p, "number", p.value)
            }
            switch (k = c ? mi(c) : window,
            t) {
            case "focusin":
                (Em(k) || k.contentEditable === "true") && (fi = k,
                qd = c,
                Ko = null);
                break;
            case "focusout":
                Ko = qd = fi = null;
                break;
            case "mousedown":
                Gd = !0;
                break;
            case "contextmenu":
            case "mouseup":
            case "dragend":
                Gd = !1,
                Pm(h, r, u);
                break;
            case "selectionchange":
                if (ik)
                    break;
            case "keydown":
            case "keyup":
                Pm(h, r, u)
            }
            var C;
            if (Uf)
                e: {
                    switch (t) {
                    case "compositionstart":
                        var T = "onCompositionStart";
                        break e;
                    case "compositionend":
                        T = "onCompositionEnd";
                        break e;
                    case "compositionupdate":
                        T = "onCompositionUpdate";
                        break e
                    }
                    T = void 0
                }
            else
                hi ? t0(t, r) && (T = "onCompositionEnd") : t === "keydown" && r.keyCode === 229 && (T = "onCompositionStart");
            T && (e0 && r.locale !== "ko" && (hi || T !== "onCompositionStart" ? T === "onCompositionEnd" && hi && (C = Xy()) : (Rn = u,
            Df = "value"in Rn ? Rn.value : Rn.textContent,
            hi = !0)),
            k = rc(c, T),
            0 < k.length && (T = new bm(T,t,null,r,u),
            h.push({
                event: T,
                listeners: k
            }),
            C ? T.data = C : (C = r0(r),
            C !== null && (T.data = C)))),
            (C = q1 ? G1(t, r) : Q1(t, r)) && (c = rc(c, "onBeforeInput"),
            0 < c.length && (u = new bm("onBeforeInput","beforeinput",null,r,u),
            h.push({
                event: u,
                listeners: c
            }),
            u.data = C))
        }
        p0(h, e)
    })
}
function ca(t, e, r) {
    return {
        instance: t,
        listener: e,
        currentTarget: r
    }
}
function rc(t, e) {
    for (var r = e + "Capture", n = []; t !== null; ) {
        var s = t
          , i = s.stateNode;
        s.tag === 5 && i !== null && (s = i,
        i = ra(t, r),
        i != null && n.unshift(ca(t, i, s)),
        i = ra(t, e),
        i != null && n.push(ca(t, i, s))),
        t = t.return
    }
    return n
}
function Qs(t) {
    if (t === null)
        return null;
    do
        t = t.return;
    while (t && t.tag !== 5);
    return t || null
}
function Om(t, e, r, n, s) {
    for (var i = e._reactName, o = []; r !== null && r !== n; ) {
        var a = r
          , l = a.alternate
          , c = a.stateNode;
        if (l !== null && l === n)
            break;
        a.tag === 5 && c !== null && (a = c,
        s ? (l = ra(r, i),
        l != null && o.unshift(ca(r, l, a))) : s || (l = ra(r, i),
        l != null && o.push(ca(r, l, a)))),
        r = r.return
    }
    o.length !== 0 && t.push({
        event: e,
        listeners: o
    })
}
var ck = /\r\n?/g
  , uk = /\u0000|\uFFFD/g;
function Im(t) {
    return (typeof t == "string" ? t : "" + t).replace(ck, `
`).replace(uk, "")
}
function cl(t, e, r) {
    if (e = Im(e),
    Im(t) !== e && r)
        throw Error(O(425))
}
function nc() {}
var Qd = null
  , Jd = null;
function Zd(t, e) {
    return t === "textarea" || t === "noscript" || typeof e.children == "string" || typeof e.children == "number" || typeof e.dangerouslySetInnerHTML == "object" && e.dangerouslySetInnerHTML !== null && e.dangerouslySetInnerHTML.__html != null
}
var Yd = typeof setTimeout == "function" ? setTimeout : void 0
  , dk = typeof clearTimeout == "function" ? clearTimeout : void 0
  , Lm = typeof Promise == "function" ? Promise : void 0
  , hk = typeof queueMicrotask == "function" ? queueMicrotask : typeof Lm < "u" ? function(t) {
    return Lm.resolve(null).then(t).catch(fk)
}
: Yd;
function fk(t) {
    setTimeout(function() {
        throw t
    })
}
function Hu(t, e) {
    var r = e
      , n = 0;
    do {
        var s = r.nextSibling;
        if (t.removeChild(r),
        s && s.nodeType === 8)
            if (r = s.data,
            r === "/$") {
                if (n === 0) {
                    t.removeChild(s),
                    ia(e);
                    return
                }
                n--
            } else
                r !== "$" && r !== "$?" && r !== "$!" || n++;
        r = s
    } while (r);
    ia(e)
}
function Ln(t) {
    for (; t != null; t = t.nextSibling) {
        var e = t.nodeType;
        if (e === 1 || e === 3)
            break;
        if (e === 8) {
            if (e = t.data,
            e === "$" || e === "$!" || e === "$?")
                break;
            if (e === "/$")
                return null
        }
    }
    return t
}
function $m(t) {
    t = t.previousSibling;
    for (var e = 0; t; ) {
        if (t.nodeType === 8) {
            var r = t.data;
            if (r === "$" || r === "$!" || r === "$?") {
                if (e === 0)
                    return t;
                e--
            } else
                r === "/$" && e++
        }
        t = t.previousSibling
    }
    return null
}
var po = Math.random().toString(36).slice(2)
  , Rr = "__reactFiber$" + po
  , ua = "__reactProps$" + po
  , Gr = "__reactContainer$" + po
  , Xd = "__reactEvents$" + po
  , pk = "__reactListeners$" + po
  , mk = "__reactHandles$" + po;
function ps(t) {
    var e = t[Rr];
    if (e)
        return e;
    for (var r = t.parentNode; r; ) {
        if (e = r[Gr] || r[Rr]) {
            if (r = e.alternate,
            e.child !== null || r !== null && r.child !== null)
                for (t = $m(t); t !== null; ) {
                    if (r = t[Rr])
                        return r;
                    t = $m(t)
                }
            return e
        }
        t = r,
        r = t.parentNode
    }
    return null
}
function Ua(t) {
    return t = t[Rr] || t[Gr],
    !t || t.tag !== 5 && t.tag !== 6 && t.tag !== 13 && t.tag !== 3 ? null : t
}
function mi(t) {
    if (t.tag === 5 || t.tag === 6)
        return t.stateNode;
    throw Error(O(33))
}
function Wc(t) {
    return t[ua] || null
}
var eh = []
  , gi = -1;
function Yn(t) {
    return {
        current: t
    }
}
function Pe(t) {
    0 > gi || (t.current = eh[gi],
    eh[gi] = null,
    gi--)
}
function Ee(t, e) {
    gi++,
    eh[gi] = t.current,
    t.current = e
}
var Hn = {}
  , ht = Yn(Hn)
  , Ct = Yn(!1)
  , Ns = Hn;
function Zi(t, e) {
    var r = t.type.contextTypes;
    if (!r)
        return Hn;
    var n = t.stateNode;
    if (n && n.__reactInternalMemoizedUnmaskedChildContext === e)
        return n.__reactInternalMemoizedMaskedChildContext;
    var s = {}, i;
    for (i in r)
        s[i] = e[i];
    return n && (t = t.stateNode,
    t.__reactInternalMemoizedUnmaskedChildContext = e,
    t.__reactInternalMemoizedMaskedChildContext = s),
    s
}
function Tt(t) {
    return t = t.childContextTypes,
    t != null
}
function sc() {
    Pe(Ct),
    Pe(ht)
}
function Dm(t, e, r) {
    if (ht.current !== Hn)
        throw Error(O(168));
    Ee(ht, e),
    Ee(Ct, r)
}
function g0(t, e, r) {
    var n = t.stateNode;
    if (e = e.childContextTypes,
    typeof n.getChildContext != "function")
        return r;
    n = n.getChildContext();
    for (var s in n)
        if (!(s in e))
            throw Error(O(108, XS(t) || "Unknown", s));
    return De({}, r, n)
}
function ic(t) {
    return t = (t = t.stateNode) && t.__reactInternalMemoizedMergedChildContext || Hn,
    Ns = ht.current,
    Ee(ht, t),
    Ee(Ct, Ct.current),
    !0
}
function Mm(t, e, r) {
    var n = t.stateNode;
    if (!n)
        throw Error(O(169));
    r ? (t = g0(t, e, Ns),
    n.__reactInternalMemoizedMergedChildContext = t,
    Pe(Ct),
    Pe(ht),
    Ee(ht, t)) : Pe(Ct),
    Ee(Ct, r)
}
var Br = null
  , Hc = !1
  , Ku = !1;
function v0(t) {
    Br === null ? Br = [t] : Br.push(t)
}
function gk(t) {
    Hc = !0,
    v0(t)
}
function Xn() {
    if (!Ku && Br !== null) {
        Ku = !0;
        var t = 0
          , e = _e;
        try {
            var r = Br;
            for (_e = 1; t < r.length; t++) {
                var n = r[t];
                do
                    n = n(!0);
                while (n !== null)
            }
            Br = null,
            Hc = !1
        } catch (s) {
            throw Br !== null && (Br = Br.slice(t + 1)),
            zy(Of, Xn),
            s
        } finally {
            _e = e,
            Ku = !1
        }
    }
    return null
}
var vi = []
  , yi = 0
  , oc = null
  , ac = 0
  , qt = []
  , Gt = 0
  , Ps = null
  , Vr = 1
  , Wr = "";
function cs(t, e) {
    vi[yi++] = ac,
    vi[yi++] = oc,
    oc = t,
    ac = e
}
function y0(t, e, r) {
    qt[Gt++] = Vr,
    qt[Gt++] = Wr,
    qt[Gt++] = Ps,
    Ps = t;
    var n = Vr;
    t = Wr;
    var s = 32 - vr(n) - 1;
    n &= ~(1 << s),
    r += 1;
    var i = 32 - vr(e) + s;
    if (30 < i) {
        var o = s - s % 5;
        i = (n & (1 << o) - 1).toString(32),
        n >>= o,
        s -= o,
        Vr = 1 << 32 - vr(e) + s | r << s | n,
        Wr = i + t
    } else
        Vr = 1 << i | r << s | n,
        Wr = t
}
function zf(t) {
    t.return !== null && (cs(t, 1),
    y0(t, 1, 0))
}
function Vf(t) {
    for (; t === oc; )
        oc = vi[--yi],
        vi[yi] = null,
        ac = vi[--yi],
        vi[yi] = null;
    for (; t === Ps; )
        Ps = qt[--Gt],
        qt[Gt] = null,
        Wr = qt[--Gt],
        qt[Gt] = null,
        Vr = qt[--Gt],
        qt[Gt] = null
}
var Dt = null
  , $t = null
  , Oe = !1
  , gr = null;
function w0(t, e) {
    var r = Qt(5, null, null, 0);
    r.elementType = "DELETED",
    r.stateNode = e,
    r.return = t,
    e = t.deletions,
    e === null ? (t.deletions = [r],
    t.flags |= 16) : e.push(r)
}
function Fm(t, e) {
    switch (t.tag) {
    case 5:
        var r = t.type;
        return e = e.nodeType !== 1 || r.toLowerCase() !== e.nodeName.toLowerCase() ? null : e,
        e !== null ? (t.stateNode = e,
        Dt = t,
        $t = Ln(e.firstChild),
        !0) : !1;
    case 6:
        return e = t.pendingProps === "" || e.nodeType !== 3 ? null : e,
        e !== null ? (t.stateNode = e,
        Dt = t,
        $t = null,
        !0) : !1;
    case 13:
        return e = e.nodeType !== 8 ? null : e,
        e !== null ? (r = Ps !== null ? {
            id: Vr,
            overflow: Wr
        } : null,
        t.memoizedState = {
            dehydrated: e,
            treeContext: r,
            retryLane: 1073741824
        },
        r = Qt(18, null, null, 0),
        r.stateNode = e,
        r.return = t,
        t.child = r,
        Dt = t,
        $t = null,
        !0) : !1;
    default:
        return !1
    }
}
function th(t) {
    return (t.mode & 1) !== 0 && (t.flags & 128) === 0
}
function rh(t) {
    if (Oe) {
        var e = $t;
        if (e) {
            var r = e;
            if (!Fm(t, e)) {
                if (th(t))
                    throw Error(O(418));
                e = Ln(r.nextSibling);
                var n = Dt;
                e && Fm(t, e) ? w0(n, r) : (t.flags = t.flags & -4097 | 2,
                Oe = !1,
                Dt = t)
            }
        } else {
            if (th(t))
                throw Error(O(418));
            t.flags = t.flags & -4097 | 2,
            Oe = !1,
            Dt = t
        }
    }
}
function Um(t) {
    for (t = t.return; t !== null && t.tag !== 5 && t.tag !== 3 && t.tag !== 13; )
        t = t.return;
    Dt = t
}
function ul(t) {
    if (t !== Dt)
        return !1;
    if (!Oe)
        return Um(t),
        Oe = !0,
        !1;
    var e;
    if ((e = t.tag !== 3) && !(e = t.tag !== 5) && (e = t.type,
    e = e !== "head" && e !== "body" && !Zd(t.type, t.memoizedProps)),
    e && (e = $t)) {
        if (th(t))
            throw x0(),
            Error(O(418));
        for (; e; )
            w0(t, e),
            e = Ln(e.nextSibling)
    }
    if (Um(t),
    t.tag === 13) {
        if (t = t.memoizedState,
        t = t !== null ? t.dehydrated : null,
        !t)
            throw Error(O(317));
        e: {
            for (t = t.nextSibling,
            e = 0; t; ) {
                if (t.nodeType === 8) {
                    var r = t.data;
                    if (r === "/$") {
                        if (e === 0) {
                            $t = Ln(t.nextSibling);
                            break e
                        }
                        e--
                    } else
                        r !== "$" && r !== "$!" && r !== "$?" || e++
                }
                t = t.nextSibling
            }
            $t = null
        }
    } else
        $t = Dt ? Ln(t.stateNode.nextSibling) : null;
    return !0
}
function x0() {
    for (var t = $t; t; )
        t = Ln(t.nextSibling)
}
function Yi() {
    $t = Dt = null,
    Oe = !1
}
function Wf(t) {
    gr === null ? gr = [t] : gr.push(t)
}
var vk = en.ReactCurrentBatchConfig;
function Ro(t, e, r) {
    if (t = r.ref,
    t !== null && typeof t != "function" && typeof t != "object") {
        if (r._owner) {
            if (r = r._owner,
            r) {
                if (r.tag !== 1)
                    throw Error(O(309));
                var n = r.stateNode
            }
            if (!n)
                throw Error(O(147, t));
            var s = n
              , i = "" + t;
            return e !== null && e.ref !== null && typeof e.ref == "function" && e.ref._stringRef === i ? e.ref : (e = function(o) {
                var a = s.refs;
                o === null ? delete a[i] : a[i] = o
            }
            ,
            e._stringRef = i,
            e)
        }
        if (typeof t != "string")
            throw Error(O(284));
        if (!r._owner)
            throw Error(O(290, t))
    }
    return t
}
function dl(t, e) {
    throw t = Object.prototype.toString.call(e),
    Error(O(31, t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t))
}
function Bm(t) {
    var e = t._init;
    return e(t._payload)
}
function b0(t) {
    function e(w, g) {
        if (t) {
            var v = w.deletions;
            v === null ? (w.deletions = [g],
            w.flags |= 16) : v.push(g)
        }
    }
    function r(w, g) {
        if (!t)
            return null;
        for (; g !== null; )
            e(w, g),
            g = g.sibling;
        return null
    }
    function n(w, g) {
        for (w = new Map; g !== null; )
            g.key !== null ? w.set(g.key, g) : w.set(g.index, g),
            g = g.sibling;
        return w
    }
    function s(w, g) {
        return w = Fn(w, g),
        w.index = 0,
        w.sibling = null,
        w
    }
    function i(w, g, v) {
        return w.index = v,
        t ? (v = w.alternate,
        v !== null ? (v = v.index,
        v < g ? (w.flags |= 2,
        g) : v) : (w.flags |= 2,
        g)) : (w.flags |= 1048576,
        g)
    }
    function o(w) {
        return t && w.alternate === null && (w.flags |= 2),
        w
    }
    function a(w, g, v, _) {
        return g === null || g.tag !== 6 ? (g = Xu(v, w.mode, _),
        g.return = w,
        g) : (g = s(g, v),
        g.return = w,
        g)
    }
    function l(w, g, v, _) {
        var S = v.type;
        return S === di ? u(w, g, v.props.children, _, v.key) : g !== null && (g.elementType === S || typeof S == "object" && S !== null && S.$$typeof === fn && Bm(S) === g.type) ? (_ = s(g, v.props),
        _.ref = Ro(w, g, v),
        _.return = w,
        _) : (_ = zl(v.type, v.key, v.props, null, w.mode, _),
        _.ref = Ro(w, g, v),
        _.return = w,
        _)
    }
    function c(w, g, v, _) {
        return g === null || g.tag !== 4 || g.stateNode.containerInfo !== v.containerInfo || g.stateNode.implementation !== v.implementation ? (g = ed(v, w.mode, _),
        g.return = w,
        g) : (g = s(g, v.children || []),
        g.return = w,
        g)
    }
    function u(w, g, v, _, S) {
        return g === null || g.tag !== 7 ? (g = Rs(v, w.mode, _, S),
        g.return = w,
        g) : (g = s(g, v),
        g.return = w,
        g)
    }
    function h(w, g, v) {
        if (typeof g == "string" && g !== "" || typeof g == "number")
            return g = Xu("" + g, w.mode, v),
            g.return = w,
            g;
        if (typeof g == "object" && g !== null) {
            switch (g.$$typeof) {
            case el:
                return v = zl(g.type, g.key, g.props, null, w.mode, v),
                v.ref = Ro(w, null, g),
                v.return = w,
                v;
            case ui:
                return g = ed(g, w.mode, v),
                g.return = w,
                g;
            case fn:
                var _ = g._init;
                return h(w, _(g._payload), v)
            }
            if (Io(g) || So(g))
                return g = Rs(g, w.mode, v, null),
                g.return = w,
                g;
            dl(w, g)
        }
        return null
    }
    function p(w, g, v, _) {
        var S = g !== null ? g.key : null;
        if (typeof v == "string" && v !== "" || typeof v == "number")
            return S !== null ? null : a(w, g, "" + v, _);
        if (typeof v == "object" && v !== null) {
            switch (v.$$typeof) {
            case el:
                return v.key === S ? l(w, g, v, _) : null;
            case ui:
                return v.key === S ? c(w, g, v, _) : null;
            case fn:
                return S = v._init,
                p(w, g, S(v._payload), _)
            }
            if (Io(v) || So(v))
                return S !== null ? null : u(w, g, v, _, null);
            dl(w, v)
        }
        return null
    }
    function f(w, g, v, _, S) {
        if (typeof _ == "string" && _ !== "" || typeof _ == "number")
            return w = w.get(v) || null,
            a(g, w, "" + _, S);
        if (typeof _ == "object" && _ !== null) {
            switch (_.$$typeof) {
            case el:
                return w = w.get(_.key === null ? v : _.key) || null,
                l(g, w, _, S);
            case ui:
                return w = w.get(_.key === null ? v : _.key) || null,
                c(g, w, _, S);
            case fn:
                var k = _._init;
                return f(w, g, v, k(_._payload), S)
            }
            if (Io(_) || So(_))
                return w = w.get(v) || null,
                u(g, w, _, S, null);
            dl(g, _)
        }
        return null
    }
    function b(w, g, v, _) {
        for (var S = null, k = null, C = g, T = g = 0, A = null; C !== null && T < v.length; T++) {
            C.index > T ? (A = C,
            C = null) : A = C.sibling;
            var P = p(w, C, v[T], _);
            if (P === null) {
                C === null && (C = A);
                break
            }
            t && C && P.alternate === null && e(w, C),
            g = i(P, g, T),
            k === null ? S = P : k.sibling = P,
            k = P,
            C = A
        }
        if (T === v.length)
            return r(w, C),
            Oe && cs(w, T),
            S;
        if (C === null) {
            for (; T < v.length; T++)
                C = h(w, v[T], _),
                C !== null && (g = i(C, g, T),
                k === null ? S = C : k.sibling = C,
                k = C);
            return Oe && cs(w, T),
            S
        }
        for (C = n(w, C); T < v.length; T++)
            A = f(C, w, T, v[T], _),
            A !== null && (t && A.alternate !== null && C.delete(A.key === null ? T : A.key),
            g = i(A, g, T),
            k === null ? S = A : k.sibling = A,
            k = A);
        return t && C.forEach(function(B) {
            return e(w, B)
        }),
        Oe && cs(w, T),
        S
    }
    function m(w, g, v, _) {
        var S = So(v);
        if (typeof S != "function")
            throw Error(O(150));
        if (v = S.call(v),
        v == null)
            throw Error(O(151));
        for (var k = S = null, C = g, T = g = 0, A = null, P = v.next(); C !== null && !P.done; T++,
        P = v.next()) {
            C.index > T ? (A = C,
            C = null) : A = C.sibling;
            var B = p(w, C, P.value, _);
            if (B === null) {
                C === null && (C = A);
                break
            }
            t && C && B.alternate === null && e(w, C),
            g = i(B, g, T),
            k === null ? S = B : k.sibling = B,
            k = B,
            C = A
        }
        if (P.done)
            return r(w, C),
            Oe && cs(w, T),
            S;
        if (C === null) {
            for (; !P.done; T++,
            P = v.next())
                P = h(w, P.value, _),
                P !== null && (g = i(P, g, T),
                k === null ? S = P : k.sibling = P,
                k = P);
            return Oe && cs(w, T),
            S
        }
        for (C = n(w, C); !P.done; T++,
        P = v.next())
            P = f(C, w, T, P.value, _),
            P !== null && (t && P.alternate !== null && C.delete(P.key === null ? T : P.key),
            g = i(P, g, T),
            k === null ? S = P : k.sibling = P,
            k = P);
        return t && C.forEach(function(L) {
            return e(w, L)
        }),
        Oe && cs(w, T),
        S
    }
    function x(w, g, v, _) {
        if (typeof v == "object" && v !== null && v.type === di && v.key === null && (v = v.props.children),
        typeof v == "object" && v !== null) {
            switch (v.$$typeof) {
            case el:
                e: {
                    for (var S = v.key, k = g; k !== null; ) {
                        if (k.key === S) {
                            if (S = v.type,
                            S === di) {
                                if (k.tag === 7) {
                                    r(w, k.sibling),
                                    g = s(k, v.props.children),
                                    g.return = w,
                                    w = g;
                                    break e
                                }
                            } else if (k.elementType === S || typeof S == "object" && S !== null && S.$$typeof === fn && Bm(S) === k.type) {
                                r(w, k.sibling),
                                g = s(k, v.props),
                                g.ref = Ro(w, k, v),
                                g.return = w,
                                w = g;
                                break e
                            }
                            r(w, k);
                            break
                        } else
                            e(w, k);
                        k = k.sibling
                    }
                    v.type === di ? (g = Rs(v.props.children, w.mode, _, v.key),
                    g.return = w,
                    w = g) : (_ = zl(v.type, v.key, v.props, null, w.mode, _),
                    _.ref = Ro(w, g, v),
                    _.return = w,
                    w = _)
                }
                return o(w);
            case ui:
                e: {
                    for (k = v.key; g !== null; ) {
                        if (g.key === k)
                            if (g.tag === 4 && g.stateNode.containerInfo === v.containerInfo && g.stateNode.implementation === v.implementation) {
                                r(w, g.sibling),
                                g = s(g, v.children || []),
                                g.return = w,
                                w = g;
                                break e
                            } else {
                                r(w, g);
                                break
                            }
                        else
                            e(w, g);
                        g = g.sibling
                    }
                    g = ed(v, w.mode, _),
                    g.return = w,
                    w = g
                }
                return o(w);
            case fn:
                return k = v._init,
                x(w, g, k(v._payload), _)
            }
            if (Io(v))
                return b(w, g, v, _);
            if (So(v))
                return m(w, g, v, _);
            dl(w, v)
        }
        return typeof v == "string" && v !== "" || typeof v == "number" ? (v = "" + v,
        g !== null && g.tag === 6 ? (r(w, g.sibling),
        g = s(g, v),
        g.return = w,
        w = g) : (r(w, g),
        g = Xu(v, w.mode, _),
        g.return = w,
        w = g),
        o(w)) : r(w, g)
    }
    return x
}
var Xi = b0(!0)
  , _0 = b0(!1)
  , lc = Yn(null)
  , cc = null
  , wi = null
  , Hf = null;
function Kf() {
    Hf = wi = cc = null
}
function qf(t) {
    var e = lc.current;
    Pe(lc),
    t._currentValue = e
}
function nh(t, e, r) {
    for (; t !== null; ) {
        var n = t.alternate;
        if ((t.childLanes & e) !== e ? (t.childLanes |= e,
        n !== null && (n.childLanes |= e)) : n !== null && (n.childLanes & e) !== e && (n.childLanes |= e),
        t === r)
            break;
        t = t.return
    }
}
function Ni(t, e) {
    cc = t,
    Hf = wi = null,
    t = t.dependencies,
    t !== null && t.firstContext !== null && (t.lanes & e && (Et = !0),
    t.firstContext = null)
}
function Xt(t) {
    var e = t._currentValue;
    if (Hf !== t)
        if (t = {
            context: t,
            memoizedValue: e,
            next: null
        },
        wi === null) {
            if (cc === null)
                throw Error(O(308));
            wi = t,
            cc.dependencies = {
                lanes: 0,
                firstContext: t
            }
        } else
            wi = wi.next = t;
    return e
}
var ms = null;
function Gf(t) {
    ms === null ? ms = [t] : ms.push(t)
}
function S0(t, e, r, n) {
    var s = e.interleaved;
    return s === null ? (r.next = r,
    Gf(e)) : (r.next = s.next,
    s.next = r),
    e.interleaved = r,
    Qr(t, n)
}
function Qr(t, e) {
    t.lanes |= e;
    var r = t.alternate;
    for (r !== null && (r.lanes |= e),
    r = t,
    t = t.return; t !== null; )
        t.childLanes |= e,
        r = t.alternate,
        r !== null && (r.childLanes |= e),
        r = t,
        t = t.return;
    return r.tag === 3 ? r.stateNode : null
}
var pn = !1;
function Qf(t) {
    t.updateQueue = {
        baseState: t.memoizedState,
        firstBaseUpdate: null,
        lastBaseUpdate: null,
        shared: {
            pending: null,
            interleaved: null,
            lanes: 0
        },
        effects: null
    }
}
function k0(t, e) {
    t = t.updateQueue,
    e.updateQueue === t && (e.updateQueue = {
        baseState: t.baseState,
        firstBaseUpdate: t.firstBaseUpdate,
        lastBaseUpdate: t.lastBaseUpdate,
        shared: t.shared,
        effects: t.effects
    })
}
function Kr(t, e) {
    return {
        eventTime: t,
        lane: e,
        tag: 0,
        payload: null,
        callback: null,
        next: null
    }
}
function $n(t, e, r) {
    var n = t.updateQueue;
    if (n === null)
        return null;
    if (n = n.shared,
    pe & 2) {
        var s = n.pending;
        return s === null ? e.next = e : (e.next = s.next,
        s.next = e),
        n.pending = e,
        Qr(t, r)
    }
    return s = n.interleaved,
    s === null ? (e.next = e,
    Gf(n)) : (e.next = s.next,
    s.next = e),
    n.interleaved = e,
    Qr(t, r)
}
function $l(t, e, r) {
    if (e = e.updateQueue,
    e !== null && (e = e.shared,
    (r & 4194240) !== 0)) {
        var n = e.lanes;
        n &= t.pendingLanes,
        r |= n,
        e.lanes = r,
        If(t, r)
    }
}
function zm(t, e) {
    var r = t.updateQueue
      , n = t.alternate;
    if (n !== null && (n = n.updateQueue,
    r === n)) {
        var s = null
          , i = null;
        if (r = r.firstBaseUpdate,
        r !== null) {
            do {
                var o = {
                    eventTime: r.eventTime,
                    lane: r.lane,
                    tag: r.tag,
                    payload: r.payload,
                    callback: r.callback,
                    next: null
                };
                i === null ? s = i = o : i = i.next = o,
                r = r.next
            } while (r !== null);
            i === null ? s = i = e : i = i.next = e
        } else
            s = i = e;
        r = {
            baseState: n.baseState,
            firstBaseUpdate: s,
            lastBaseUpdate: i,
            shared: n.shared,
            effects: n.effects
        },
        t.updateQueue = r;
        return
    }
    t = r.lastBaseUpdate,
    t === null ? r.firstBaseUpdate = e : t.next = e,
    r.lastBaseUpdate = e
}
function uc(t, e, r, n) {
    var s = t.updateQueue;
    pn = !1;
    var i = s.firstBaseUpdate
      , o = s.lastBaseUpdate
      , a = s.shared.pending;
    if (a !== null) {
        s.shared.pending = null;
        var l = a
          , c = l.next;
        l.next = null,
        o === null ? i = c : o.next = c,
        o = l;
        var u = t.alternate;
        u !== null && (u = u.updateQueue,
        a = u.lastBaseUpdate,
        a !== o && (a === null ? u.firstBaseUpdate = c : a.next = c,
        u.lastBaseUpdate = l))
    }
    if (i !== null) {
        var h = s.baseState;
        o = 0,
        u = c = l = null,
        a = i;
        do {
            var p = a.lane
              , f = a.eventTime;
            if ((n & p) === p) {
                u !== null && (u = u.next = {
                    eventTime: f,
                    lane: 0,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                });
                e: {
                    var b = t
                      , m = a;
                    switch (p = e,
                    f = r,
                    m.tag) {
                    case 1:
                        if (b = m.payload,
                        typeof b == "function") {
                            h = b.call(f, h, p);
                            break e
                        }
                        h = b;
                        break e;
                    case 3:
                        b.flags = b.flags & -65537 | 128;
                    case 0:
                        if (b = m.payload,
                        p = typeof b == "function" ? b.call(f, h, p) : b,
                        p == null)
                            break e;
                        h = De({}, h, p);
                        break e;
                    case 2:
                        pn = !0
                    }
                }
                a.callback !== null && a.lane !== 0 && (t.flags |= 64,
                p = s.effects,
                p === null ? s.effects = [a] : p.push(a))
            } else
                f = {
                    eventTime: f,
                    lane: p,
                    tag: a.tag,
                    payload: a.payload,
                    callback: a.callback,
                    next: null
                },
                u === null ? (c = u = f,
                l = h) : u = u.next = f,
                o |= p;
            if (a = a.next,
            a === null) {
                if (a = s.shared.pending,
                a === null)
                    break;
                p = a,
                a = p.next,
                p.next = null,
                s.lastBaseUpdate = p,
                s.shared.pending = null
            }
        } while (!0);
        if (u === null && (l = h),
        s.baseState = l,
        s.firstBaseUpdate = c,
        s.lastBaseUpdate = u,
        e = s.shared.interleaved,
        e !== null) {
            s = e;
            do
                o |= s.lane,
                s = s.next;
            while (s !== e)
        } else
            i === null && (s.shared.lanes = 0);
        js |= o,
        t.lanes = o,
        t.memoizedState = h
    }
}
function Vm(t, e, r) {
    if (t = e.effects,
    e.effects = null,
    t !== null)
        for (e = 0; e < t.length; e++) {
            var n = t[e]
              , s = n.callback;
            if (s !== null) {
                if (n.callback = null,
                n = r,
                typeof s != "function")
                    throw Error(O(191, s));
                s.call(n)
            }
        }
}
var Ba = {}
  , jr = Yn(Ba)
  , da = Yn(Ba)
  , ha = Yn(Ba);
function gs(t) {
    if (t === Ba)
        throw Error(O(174));
    return t
}
function Jf(t, e) {
    switch (Ee(ha, e),
    Ee(da, t),
    Ee(jr, Ba),
    t = e.nodeType,
    t) {
    case 9:
    case 11:
        e = (e = e.documentElement) ? e.namespaceURI : Dd(null, "");
        break;
    default:
        t = t === 8 ? e.parentNode : e,
        e = t.namespaceURI || null,
        t = t.tagName,
        e = Dd(e, t)
    }
    Pe(jr),
    Ee(jr, e)
}
function eo() {
    Pe(jr),
    Pe(da),
    Pe(ha)
}
function E0(t) {
    gs(ha.current);
    var e = gs(jr.current)
      , r = Dd(e, t.type);
    e !== r && (Ee(da, t),
    Ee(jr, r))
}
function Zf(t) {
    da.current === t && (Pe(jr),
    Pe(da))
}
var Le = Yn(0);
function dc(t) {
    for (var e = t; e !== null; ) {
        if (e.tag === 13) {
            var r = e.memoizedState;
            if (r !== null && (r = r.dehydrated,
            r === null || r.data === "$?" || r.data === "$!"))
                return e
        } else if (e.tag === 19 && e.memoizedProps.revealOrder !== void 0) {
            if (e.flags & 128)
                return e
        } else if (e.child !== null) {
            e.child.return = e,
            e = e.child;
            continue
        }
        if (e === t)
            break;
        for (; e.sibling === null; ) {
            if (e.return === null || e.return === t)
                return null;
            e = e.return
        }
        e.sibling.return = e.return,
        e = e.sibling
    }
    return null
}
var qu = [];
function Yf() {
    for (var t = 0; t < qu.length; t++)
        qu[t]._workInProgressVersionPrimary = null;
    qu.length = 0
}
var Dl = en.ReactCurrentDispatcher
  , Gu = en.ReactCurrentBatchConfig
  , As = 0
  , $e = null
  , Qe = null
  , Ze = null
  , hc = !1
  , qo = !1
  , fa = 0
  , yk = 0;
function lt() {
    throw Error(O(321))
}
function Xf(t, e) {
    if (e === null)
        return !1;
    for (var r = 0; r < e.length && r < t.length; r++)
        if (!wr(t[r], e[r]))
            return !1;
    return !0
}
function ep(t, e, r, n, s, i) {
    if (As = i,
    $e = e,
    e.memoizedState = null,
    e.updateQueue = null,
    e.lanes = 0,
    Dl.current = t === null || t.memoizedState === null ? _k : Sk,
    t = r(n, s),
    qo) {
        i = 0;
        do {
            if (qo = !1,
            fa = 0,
            25 <= i)
                throw Error(O(301));
            i += 1,
            Ze = Qe = null,
            e.updateQueue = null,
            Dl.current = kk,
            t = r(n, s)
        } while (qo)
    }
    if (Dl.current = fc,
    e = Qe !== null && Qe.next !== null,
    As = 0,
    Ze = Qe = $e = null,
    hc = !1,
    e)
        throw Error(O(300));
    return t
}
function tp() {
    var t = fa !== 0;
    return fa = 0,
    t
}
function kr() {
    var t = {
        memoizedState: null,
        baseState: null,
        baseQueue: null,
        queue: null,
        next: null
    };
    return Ze === null ? $e.memoizedState = Ze = t : Ze = Ze.next = t,
    Ze
}
function er() {
    if (Qe === null) {
        var t = $e.alternate;
        t = t !== null ? t.memoizedState : null
    } else
        t = Qe.next;
    var e = Ze === null ? $e.memoizedState : Ze.next;
    if (e !== null)
        Ze = e,
        Qe = t;
    else {
        if (t === null)
            throw Error(O(310));
        Qe = t,
        t = {
            memoizedState: Qe.memoizedState,
            baseState: Qe.baseState,
            baseQueue: Qe.baseQueue,
            queue: Qe.queue,
            next: null
        },
        Ze === null ? $e.memoizedState = Ze = t : Ze = Ze.next = t
    }
    return Ze
}
function pa(t, e) {
    return typeof e == "function" ? e(t) : e
}
function Qu(t) {
    var e = er()
      , r = e.queue;
    if (r === null)
        throw Error(O(311));
    r.lastRenderedReducer = t;
    var n = Qe
      , s = n.baseQueue
      , i = r.pending;
    if (i !== null) {
        if (s !== null) {
            var o = s.next;
            s.next = i.next,
            i.next = o
        }
        n.baseQueue = s = i,
        r.pending = null
    }
    if (s !== null) {
        i = s.next,
        n = n.baseState;
        var a = o = null
          , l = null
          , c = i;
        do {
            var u = c.lane;
            if ((As & u) === u)
                l !== null && (l = l.next = {
                    lane: 0,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                }),
                n = c.hasEagerState ? c.eagerState : t(n, c.action);
            else {
                var h = {
                    lane: u,
                    action: c.action,
                    hasEagerState: c.hasEagerState,
                    eagerState: c.eagerState,
                    next: null
                };
                l === null ? (a = l = h,
                o = n) : l = l.next = h,
                $e.lanes |= u,
                js |= u
            }
            c = c.next
        } while (c !== null && c !== i);
        l === null ? o = n : l.next = a,
        wr(n, e.memoizedState) || (Et = !0),
        e.memoizedState = n,
        e.baseState = o,
        e.baseQueue = l,
        r.lastRenderedState = n
    }
    if (t = r.interleaved,
    t !== null) {
        s = t;
        do
            i = s.lane,
            $e.lanes |= i,
            js |= i,
            s = s.next;
        while (s !== t)
    } else
        s === null && (r.lanes = 0);
    return [e.memoizedState, r.dispatch]
}
function Ju(t) {
    var e = er()
      , r = e.queue;
    if (r === null)
        throw Error(O(311));
    r.lastRenderedReducer = t;
    var n = r.dispatch
      , s = r.pending
      , i = e.memoizedState;
    if (s !== null) {
        r.pending = null;
        var o = s = s.next;
        do
            i = t(i, o.action),
            o = o.next;
        while (o !== s);
        wr(i, e.memoizedState) || (Et = !0),
        e.memoizedState = i,
        e.baseQueue === null && (e.baseState = i),
        r.lastRenderedState = i
    }
    return [i, n]
}
function C0() {}
function T0(t, e) {
    var r = $e
      , n = er()
      , s = e()
      , i = !wr(n.memoizedState, s);
    if (i && (n.memoizedState = s,
    Et = !0),
    n = n.queue,
    rp(P0.bind(null, r, n, t), [t]),
    n.getSnapshot !== e || i || Ze !== null && Ze.memoizedState.tag & 1) {
        if (r.flags |= 2048,
        ma(9, N0.bind(null, r, n, s, e), void 0, null),
        Xe === null)
            throw Error(O(349));
        As & 30 || R0(r, e, s)
    }
    return s
}
function R0(t, e, r) {
    t.flags |= 16384,
    t = {
        getSnapshot: e,
        value: r
    },
    e = $e.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    $e.updateQueue = e,
    e.stores = [t]) : (r = e.stores,
    r === null ? e.stores = [t] : r.push(t))
}
function N0(t, e, r, n) {
    e.value = r,
    e.getSnapshot = n,
    A0(e) && j0(t)
}
function P0(t, e, r) {
    return r(function() {
        A0(e) && j0(t)
    })
}
function A0(t) {
    var e = t.getSnapshot;
    t = t.value;
    try {
        var r = e();
        return !wr(t, r)
    } catch {
        return !0
    }
}
function j0(t) {
    var e = Qr(t, 1);
    e !== null && yr(e, t, 1, -1)
}
function Wm(t) {
    var e = kr();
    return typeof t == "function" && (t = t()),
    e.memoizedState = e.baseState = t,
    t = {
        pending: null,
        interleaved: null,
        lanes: 0,
        dispatch: null,
        lastRenderedReducer: pa,
        lastRenderedState: t
    },
    e.queue = t,
    t = t.dispatch = bk.bind(null, $e, t),
    [e.memoizedState, t]
}
function ma(t, e, r, n) {
    return t = {
        tag: t,
        create: e,
        destroy: r,
        deps: n,
        next: null
    },
    e = $e.updateQueue,
    e === null ? (e = {
        lastEffect: null,
        stores: null
    },
    $e.updateQueue = e,
    e.lastEffect = t.next = t) : (r = e.lastEffect,
    r === null ? e.lastEffect = t.next = t : (n = r.next,
    r.next = t,
    t.next = n,
    e.lastEffect = t)),
    t
}
function O0() {
    return er().memoizedState
}
function Ml(t, e, r, n) {
    var s = kr();
    $e.flags |= t,
    s.memoizedState = ma(1 | e, r, void 0, n === void 0 ? null : n)
}
function Kc(t, e, r, n) {
    var s = er();
    n = n === void 0 ? null : n;
    var i = void 0;
    if (Qe !== null) {
        var o = Qe.memoizedState;
        if (i = o.destroy,
        n !== null && Xf(n, o.deps)) {
            s.memoizedState = ma(e, r, i, n);
            return
        }
    }
    $e.flags |= t,
    s.memoizedState = ma(1 | e, r, i, n)
}
function Hm(t, e) {
    return Ml(8390656, 8, t, e)
}
function rp(t, e) {
    return Kc(2048, 8, t, e)
}
function I0(t, e) {
    return Kc(4, 2, t, e)
}
function L0(t, e) {
    return Kc(4, 4, t, e)
}
function $0(t, e) {
    if (typeof e == "function")
        return t = t(),
        e(t),
        function() {
            e(null)
        }
        ;
    if (e != null)
        return t = t(),
        e.current = t,
        function() {
            e.current = null
        }
}
function D0(t, e, r) {
    return r = r != null ? r.concat([t]) : null,
    Kc(4, 4, $0.bind(null, e, t), r)
}
function np() {}
function M0(t, e) {
    var r = er();
    e = e === void 0 ? null : e;
    var n = r.memoizedState;
    return n !== null && e !== null && Xf(e, n[1]) ? n[0] : (r.memoizedState = [t, e],
    t)
}
function F0(t, e) {
    var r = er();
    e = e === void 0 ? null : e;
    var n = r.memoizedState;
    return n !== null && e !== null && Xf(e, n[1]) ? n[0] : (t = t(),
    r.memoizedState = [t, e],
    t)
}
function U0(t, e, r) {
    return As & 21 ? (wr(r, e) || (r = Hy(),
    $e.lanes |= r,
    js |= r,
    t.baseState = !0),
    e) : (t.baseState && (t.baseState = !1,
    Et = !0),
    t.memoizedState = r)
}
function wk(t, e) {
    var r = _e;
    _e = r !== 0 && 4 > r ? r : 4,
    t(!0);
    var n = Gu.transition;
    Gu.transition = {};
    try {
        t(!1),
        e()
    } finally {
        _e = r,
        Gu.transition = n
    }
}
function B0() {
    return er().memoizedState
}
function xk(t, e, r) {
    var n = Mn(t);
    if (r = {
        lane: n,
        action: r,
        hasEagerState: !1,
        eagerState: null,
        next: null
    },
    z0(t))
        V0(e, r);
    else if (r = S0(t, e, r, n),
    r !== null) {
        var s = vt();
        yr(r, t, n, s),
        W0(r, e, n)
    }
}
function bk(t, e, r) {
    var n = Mn(t)
      , s = {
        lane: n,
        action: r,
        hasEagerState: !1,
        eagerState: null,
        next: null
    };
    if (z0(t))
        V0(e, s);
    else {
        var i = t.alternate;
        if (t.lanes === 0 && (i === null || i.lanes === 0) && (i = e.lastRenderedReducer,
        i !== null))
            try {
                var o = e.lastRenderedState
                  , a = i(o, r);
                if (s.hasEagerState = !0,
                s.eagerState = a,
                wr(a, o)) {
                    var l = e.interleaved;
                    l === null ? (s.next = s,
                    Gf(e)) : (s.next = l.next,
                    l.next = s),
                    e.interleaved = s;
                    return
                }
            } catch {} finally {}
        r = S0(t, e, s, n),
        r !== null && (s = vt(),
        yr(r, t, n, s),
        W0(r, e, n))
    }
}
function z0(t) {
    var e = t.alternate;
    return t === $e || e !== null && e === $e
}
function V0(t, e) {
    qo = hc = !0;
    var r = t.pending;
    r === null ? e.next = e : (e.next = r.next,
    r.next = e),
    t.pending = e
}
function W0(t, e, r) {
    if (r & 4194240) {
        var n = e.lanes;
        n &= t.pendingLanes,
        r |= n,
        e.lanes = r,
        If(t, r)
    }
}
var fc = {
    readContext: Xt,
    useCallback: lt,
    useContext: lt,
    useEffect: lt,
    useImperativeHandle: lt,
    useInsertionEffect: lt,
    useLayoutEffect: lt,
    useMemo: lt,
    useReducer: lt,
    useRef: lt,
    useState: lt,
    useDebugValue: lt,
    useDeferredValue: lt,
    useTransition: lt,
    useMutableSource: lt,
    useSyncExternalStore: lt,
    useId: lt,
    unstable_isNewReconciler: !1
}
  , _k = {
    readContext: Xt,
    useCallback: function(t, e) {
        return kr().memoizedState = [t, e === void 0 ? null : e],
        t
    },
    useContext: Xt,
    useEffect: Hm,
    useImperativeHandle: function(t, e, r) {
        return r = r != null ? r.concat([t]) : null,
        Ml(4194308, 4, $0.bind(null, e, t), r)
    },
    useLayoutEffect: function(t, e) {
        return Ml(4194308, 4, t, e)
    },
    useInsertionEffect: function(t, e) {
        return Ml(4, 2, t, e)
    },
    useMemo: function(t, e) {
        var r = kr();
        return e = e === void 0 ? null : e,
        t = t(),
        r.memoizedState = [t, e],
        t
    },
    useReducer: function(t, e, r) {
        var n = kr();
        return e = r !== void 0 ? r(e) : e,
        n.memoizedState = n.baseState = e,
        t = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: t,
            lastRenderedState: e
        },
        n.queue = t,
        t = t.dispatch = xk.bind(null, $e, t),
        [n.memoizedState, t]
    },
    useRef: function(t) {
        var e = kr();
        return t = {
            current: t
        },
        e.memoizedState = t
    },
    useState: Wm,
    useDebugValue: np,
    useDeferredValue: function(t) {
        return kr().memoizedState = t
    },
    useTransition: function() {
        var t = Wm(!1)
          , e = t[0];
        return t = wk.bind(null, t[1]),
        kr().memoizedState = t,
        [e, t]
    },
    useMutableSource: function() {},
    useSyncExternalStore: function(t, e, r) {
        var n = $e
          , s = kr();
        if (Oe) {
            if (r === void 0)
                throw Error(O(407));
            r = r()
        } else {
            if (r = e(),
            Xe === null)
                throw Error(O(349));
            As & 30 || R0(n, e, r)
        }
        s.memoizedState = r;
        var i = {
            value: r,
            getSnapshot: e
        };
        return s.queue = i,
        Hm(P0.bind(null, n, i, t), [t]),
        n.flags |= 2048,
        ma(9, N0.bind(null, n, i, r, e), void 0, null),
        r
    },
    useId: function() {
        var t = kr()
          , e = Xe.identifierPrefix;
        if (Oe) {
            var r = Wr
              , n = Vr;
            r = (n & ~(1 << 32 - vr(n) - 1)).toString(32) + r,
            e = ":" + e + "R" + r,
            r = fa++,
            0 < r && (e += "H" + r.toString(32)),
            e += ":"
        } else
            r = yk++,
            e = ":" + e + "r" + r.toString(32) + ":";
        return t.memoizedState = e
    },
    unstable_isNewReconciler: !1
}
  , Sk = {
    readContext: Xt,
    useCallback: M0,
    useContext: Xt,
    useEffect: rp,
    useImperativeHandle: D0,
    useInsertionEffect: I0,
    useLayoutEffect: L0,
    useMemo: F0,
    useReducer: Qu,
    useRef: O0,
    useState: function() {
        return Qu(pa)
    },
    useDebugValue: np,
    useDeferredValue: function(t) {
        var e = er();
        return U0(e, Qe.memoizedState, t)
    },
    useTransition: function() {
        var t = Qu(pa)[0]
          , e = er().memoizedState;
        return [t, e]
    },
    useMutableSource: C0,
    useSyncExternalStore: T0,
    useId: B0,
    unstable_isNewReconciler: !1
}
  , kk = {
    readContext: Xt,
    useCallback: M0,
    useContext: Xt,
    useEffect: rp,
    useImperativeHandle: D0,
    useInsertionEffect: I0,
    useLayoutEffect: L0,
    useMemo: F0,
    useReducer: Ju,
    useRef: O0,
    useState: function() {
        return Ju(pa)
    },
    useDebugValue: np,
    useDeferredValue: function(t) {
        var e = er();
        return Qe === null ? e.memoizedState = t : U0(e, Qe.memoizedState, t)
    },
    useTransition: function() {
        var t = Ju(pa)[0]
          , e = er().memoizedState;
        return [t, e]
    },
    useMutableSource: C0,
    useSyncExternalStore: T0,
    useId: B0,
    unstable_isNewReconciler: !1
};
function ur(t, e) {
    if (t && t.defaultProps) {
        e = De({}, e),
        t = t.defaultProps;
        for (var r in t)
            e[r] === void 0 && (e[r] = t[r]);
        return e
    }
    return e
}
function sh(t, e, r, n) {
    e = t.memoizedState,
    r = r(n, e),
    r = r == null ? e : De({}, e, r),
    t.memoizedState = r,
    t.lanes === 0 && (t.updateQueue.baseState = r)
}
var qc = {
    isMounted: function(t) {
        return (t = t._reactInternals) ? Us(t) === t : !1
    },
    enqueueSetState: function(t, e, r) {
        t = t._reactInternals;
        var n = vt()
          , s = Mn(t)
          , i = Kr(n, s);
        i.payload = e,
        r != null && (i.callback = r),
        e = $n(t, i, s),
        e !== null && (yr(e, t, s, n),
        $l(e, t, s))
    },
    enqueueReplaceState: function(t, e, r) {
        t = t._reactInternals;
        var n = vt()
          , s = Mn(t)
          , i = Kr(n, s);
        i.tag = 1,
        i.payload = e,
        r != null && (i.callback = r),
        e = $n(t, i, s),
        e !== null && (yr(e, t, s, n),
        $l(e, t, s))
    },
    enqueueForceUpdate: function(t, e) {
        t = t._reactInternals;
        var r = vt()
          , n = Mn(t)
          , s = Kr(r, n);
        s.tag = 2,
        e != null && (s.callback = e),
        e = $n(t, s, n),
        e !== null && (yr(e, t, n, r),
        $l(e, t, n))
    }
};
function Km(t, e, r, n, s, i, o) {
    return t = t.stateNode,
    typeof t.shouldComponentUpdate == "function" ? t.shouldComponentUpdate(n, i, o) : e.prototype && e.prototype.isPureReactComponent ? !aa(r, n) || !aa(s, i) : !0
}
function H0(t, e, r) {
    var n = !1
      , s = Hn
      , i = e.contextType;
    return typeof i == "object" && i !== null ? i = Xt(i) : (s = Tt(e) ? Ns : ht.current,
    n = e.contextTypes,
    i = (n = n != null) ? Zi(t, s) : Hn),
    e = new e(r,i),
    t.memoizedState = e.state !== null && e.state !== void 0 ? e.state : null,
    e.updater = qc,
    t.stateNode = e,
    e._reactInternals = t,
    n && (t = t.stateNode,
    t.__reactInternalMemoizedUnmaskedChildContext = s,
    t.__reactInternalMemoizedMaskedChildContext = i),
    e
}
function qm(t, e, r, n) {
    t = e.state,
    typeof e.componentWillReceiveProps == "function" && e.componentWillReceiveProps(r, n),
    typeof e.UNSAFE_componentWillReceiveProps == "function" && e.UNSAFE_componentWillReceiveProps(r, n),
    e.state !== t && qc.enqueueReplaceState(e, e.state, null)
}
function ih(t, e, r, n) {
    var s = t.stateNode;
    s.props = r,
    s.state = t.memoizedState,
    s.refs = {},
    Qf(t);
    var i = e.contextType;
    typeof i == "object" && i !== null ? s.context = Xt(i) : (i = Tt(e) ? Ns : ht.current,
    s.context = Zi(t, i)),
    s.state = t.memoizedState,
    i = e.getDerivedStateFromProps,
    typeof i == "function" && (sh(t, e, i, r),
    s.state = t.memoizedState),
    typeof e.getDerivedStateFromProps == "function" || typeof s.getSnapshotBeforeUpdate == "function" || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (e = s.state,
    typeof s.componentWillMount == "function" && s.componentWillMount(),
    typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount(),
    e !== s.state && qc.enqueueReplaceState(s, s.state, null),
    uc(t, r, s, n),
    s.state = t.memoizedState),
    typeof s.componentDidMount == "function" && (t.flags |= 4194308)
}
function to(t, e) {
    try {
        var r = ""
          , n = e;
        do
            r += YS(n),
            n = n.return;
        while (n);
        var s = r
    } catch (i) {
        s = `
Error generating stack: ` + i.message + `
` + i.stack
    }
    return {
        value: t,
        source: e,
        stack: s,
        digest: null
    }
}
function Zu(t, e, r) {
    return {
        value: t,
        source: null,
        stack: r ?? null,
        digest: e ?? null
    }
}
function oh(t, e) {
    try {
        console.error(e.value)
    } catch (r) {
        setTimeout(function() {
            throw r
        })
    }
}
var Ek = typeof WeakMap == "function" ? WeakMap : Map;
function K0(t, e, r) {
    r = Kr(-1, r),
    r.tag = 3,
    r.payload = {
        element: null
    };
    var n = e.value;
    return r.callback = function() {
        mc || (mc = !0,
        gh = n),
        oh(t, e)
    }
    ,
    r
}
function q0(t, e, r) {
    r = Kr(-1, r),
    r.tag = 3;
    var n = t.type.getDerivedStateFromError;
    if (typeof n == "function") {
        var s = e.value;
        r.payload = function() {
            return n(s)
        }
        ,
        r.callback = function() {
            oh(t, e)
        }
    }
    var i = t.stateNode;
    return i !== null && typeof i.componentDidCatch == "function" && (r.callback = function() {
        oh(t, e),
        typeof n != "function" && (Dn === null ? Dn = new Set([this]) : Dn.add(this));
        var o = e.stack;
        this.componentDidCatch(e.value, {
            componentStack: o !== null ? o : ""
        })
    }
    ),
    r
}
function Gm(t, e, r) {
    var n = t.pingCache;
    if (n === null) {
        n = t.pingCache = new Ek;
        var s = new Set;
        n.set(e, s)
    } else
        s = n.get(e),
        s === void 0 && (s = new Set,
        n.set(e, s));
    s.has(r) || (s.add(r),
    t = Fk.bind(null, t, e, r),
    e.then(t, t))
}
function Qm(t) {
    do {
        var e;
        if ((e = t.tag === 13) && (e = t.memoizedState,
        e = e !== null ? e.dehydrated !== null : !0),
        e)
            return t;
        t = t.return
    } while (t !== null);
    return null
}
function Jm(t, e, r, n, s) {
    return t.mode & 1 ? (t.flags |= 65536,
    t.lanes = s,
    t) : (t === e ? t.flags |= 65536 : (t.flags |= 128,
    r.flags |= 131072,
    r.flags &= -52805,
    r.tag === 1 && (r.alternate === null ? r.tag = 17 : (e = Kr(-1, 1),
    e.tag = 2,
    $n(r, e, 1))),
    r.lanes |= 1),
    t)
}
var Ck = en.ReactCurrentOwner
  , Et = !1;
function mt(t, e, r, n) {
    e.child = t === null ? _0(e, null, r, n) : Xi(e, t.child, r, n)
}
function Zm(t, e, r, n, s) {
    r = r.render;
    var i = e.ref;
    return Ni(e, s),
    n = ep(t, e, r, n, i, s),
    r = tp(),
    t !== null && !Et ? (e.updateQueue = t.updateQueue,
    e.flags &= -2053,
    t.lanes &= ~s,
    Jr(t, e, s)) : (Oe && r && zf(e),
    e.flags |= 1,
    mt(t, e, n, s),
    e.child)
}
function Ym(t, e, r, n, s) {
    if (t === null) {
        var i = r.type;
        return typeof i == "function" && !dp(i) && i.defaultProps === void 0 && r.compare === null && r.defaultProps === void 0 ? (e.tag = 15,
        e.type = i,
        G0(t, e, i, n, s)) : (t = zl(r.type, null, n, e, e.mode, s),
        t.ref = e.ref,
        t.return = e,
        e.child = t)
    }
    if (i = t.child,
    !(t.lanes & s)) {
        var o = i.memoizedProps;
        if (r = r.compare,
        r = r !== null ? r : aa,
        r(o, n) && t.ref === e.ref)
            return Jr(t, e, s)
    }
    return e.flags |= 1,
    t = Fn(i, n),
    t.ref = e.ref,
    t.return = e,
    e.child = t
}
function G0(t, e, r, n, s) {
    if (t !== null) {
        var i = t.memoizedProps;
        if (aa(i, n) && t.ref === e.ref)
            if (Et = !1,
            e.pendingProps = n = i,
            (t.lanes & s) !== 0)
                t.flags & 131072 && (Et = !0);
            else
                return e.lanes = t.lanes,
                Jr(t, e, s)
    }
    return ah(t, e, r, n, s)
}
function Q0(t, e, r) {
    var n = e.pendingProps
      , s = n.children
      , i = t !== null ? t.memoizedState : null;
    if (n.mode === "hidden")
        if (!(e.mode & 1))
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            Ee(bi, Pt),
            Pt |= r;
        else {
            if (!(r & 1073741824))
                return t = i !== null ? i.baseLanes | r : r,
                e.lanes = e.childLanes = 1073741824,
                e.memoizedState = {
                    baseLanes: t,
                    cachePool: null,
                    transitions: null
                },
                e.updateQueue = null,
                Ee(bi, Pt),
                Pt |= t,
                null;
            e.memoizedState = {
                baseLanes: 0,
                cachePool: null,
                transitions: null
            },
            n = i !== null ? i.baseLanes : r,
            Ee(bi, Pt),
            Pt |= n
        }
    else
        i !== null ? (n = i.baseLanes | r,
        e.memoizedState = null) : n = r,
        Ee(bi, Pt),
        Pt |= n;
    return mt(t, e, s, r),
    e.child
}
function J0(t, e) {
    var r = e.ref;
    (t === null && r !== null || t !== null && t.ref !== r) && (e.flags |= 512,
    e.flags |= 2097152)
}
function ah(t, e, r, n, s) {
    var i = Tt(r) ? Ns : ht.current;
    return i = Zi(e, i),
    Ni(e, s),
    r = ep(t, e, r, n, i, s),
    n = tp(),
    t !== null && !Et ? (e.updateQueue = t.updateQueue,
    e.flags &= -2053,
    t.lanes &= ~s,
    Jr(t, e, s)) : (Oe && n && zf(e),
    e.flags |= 1,
    mt(t, e, r, s),
    e.child)
}
function Xm(t, e, r, n, s) {
    if (Tt(r)) {
        var i = !0;
        ic(e)
    } else
        i = !1;
    if (Ni(e, s),
    e.stateNode === null)
        Fl(t, e),
        H0(e, r, n),
        ih(e, r, n, s),
        n = !0;
    else if (t === null) {
        var o = e.stateNode
          , a = e.memoizedProps;
        o.props = a;
        var l = o.context
          , c = r.contextType;
        typeof c == "object" && c !== null ? c = Xt(c) : (c = Tt(r) ? Ns : ht.current,
        c = Zi(e, c));
        var u = r.getDerivedStateFromProps
          , h = typeof u == "function" || typeof o.getSnapshotBeforeUpdate == "function";
        h || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== n || l !== c) && qm(e, o, n, c),
        pn = !1;
        var p = e.memoizedState;
        o.state = p,
        uc(e, n, o, s),
        l = e.memoizedState,
        a !== n || p !== l || Ct.current || pn ? (typeof u == "function" && (sh(e, r, u, n),
        l = e.memoizedState),
        (a = pn || Km(e, r, a, n, p, l, c)) ? (h || typeof o.UNSAFE_componentWillMount != "function" && typeof o.componentWillMount != "function" || (typeof o.componentWillMount == "function" && o.componentWillMount(),
        typeof o.UNSAFE_componentWillMount == "function" && o.UNSAFE_componentWillMount()),
        typeof o.componentDidMount == "function" && (e.flags |= 4194308)) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        e.memoizedProps = n,
        e.memoizedState = l),
        o.props = n,
        o.state = l,
        o.context = c,
        n = a) : (typeof o.componentDidMount == "function" && (e.flags |= 4194308),
        n = !1)
    } else {
        o = e.stateNode,
        k0(t, e),
        a = e.memoizedProps,
        c = e.type === e.elementType ? a : ur(e.type, a),
        o.props = c,
        h = e.pendingProps,
        p = o.context,
        l = r.contextType,
        typeof l == "object" && l !== null ? l = Xt(l) : (l = Tt(r) ? Ns : ht.current,
        l = Zi(e, l));
        var f = r.getDerivedStateFromProps;
        (u = typeof f == "function" || typeof o.getSnapshotBeforeUpdate == "function") || typeof o.UNSAFE_componentWillReceiveProps != "function" && typeof o.componentWillReceiveProps != "function" || (a !== h || p !== l) && qm(e, o, n, l),
        pn = !1,
        p = e.memoizedState,
        o.state = p,
        uc(e, n, o, s);
        var b = e.memoizedState;
        a !== h || p !== b || Ct.current || pn ? (typeof f == "function" && (sh(e, r, f, n),
        b = e.memoizedState),
        (c = pn || Km(e, r, c, n, p, b, l) || !1) ? (u || typeof o.UNSAFE_componentWillUpdate != "function" && typeof o.componentWillUpdate != "function" || (typeof o.componentWillUpdate == "function" && o.componentWillUpdate(n, b, l),
        typeof o.UNSAFE_componentWillUpdate == "function" && o.UNSAFE_componentWillUpdate(n, b, l)),
        typeof o.componentDidUpdate == "function" && (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate == "function" && (e.flags |= 1024)) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 1024),
        e.memoizedProps = n,
        e.memoizedState = b),
        o.props = n,
        o.state = b,
        o.context = l,
        n = c) : (typeof o.componentDidUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 4),
        typeof o.getSnapshotBeforeUpdate != "function" || a === t.memoizedProps && p === t.memoizedState || (e.flags |= 1024),
        n = !1)
    }
    return lh(t, e, r, n, i, s)
}
function lh(t, e, r, n, s, i) {
    J0(t, e);
    var o = (e.flags & 128) !== 0;
    if (!n && !o)
        return s && Mm(e, r, !1),
        Jr(t, e, i);
    n = e.stateNode,
    Ck.current = e;
    var a = o && typeof r.getDerivedStateFromError != "function" ? null : n.render();
    return e.flags |= 1,
    t !== null && o ? (e.child = Xi(e, t.child, null, i),
    e.child = Xi(e, null, a, i)) : mt(t, e, a, i),
    e.memoizedState = n.state,
    s && Mm(e, r, !0),
    e.child
}
function Z0(t) {
    var e = t.stateNode;
    e.pendingContext ? Dm(t, e.pendingContext, e.pendingContext !== e.context) : e.context && Dm(t, e.context, !1),
    Jf(t, e.containerInfo)
}
function eg(t, e, r, n, s) {
    return Yi(),
    Wf(s),
    e.flags |= 256,
    mt(t, e, r, n),
    e.child
}
var ch = {
    dehydrated: null,
    treeContext: null,
    retryLane: 0
};
function uh(t) {
    return {
        baseLanes: t,
        cachePool: null,
        transitions: null
    }
}
function Y0(t, e, r) {
    var n = e.pendingProps, s = Le.current, i = !1, o = (e.flags & 128) !== 0, a;
    if ((a = o) || (a = t !== null && t.memoizedState === null ? !1 : (s & 2) !== 0),
    a ? (i = !0,
    e.flags &= -129) : (t === null || t.memoizedState !== null) && (s |= 1),
    Ee(Le, s & 1),
    t === null)
        return rh(e),
        t = e.memoizedState,
        t !== null && (t = t.dehydrated,
        t !== null) ? (e.mode & 1 ? t.data === "$!" ? e.lanes = 8 : e.lanes = 1073741824 : e.lanes = 1,
        null) : (o = n.children,
        t = n.fallback,
        i ? (n = e.mode,
        i = e.child,
        o = {
            mode: "hidden",
            children: o
        },
        !(n & 1) && i !== null ? (i.childLanes = 0,
        i.pendingProps = o) : i = Jc(o, n, 0, null),
        t = Rs(t, n, r, null),
        i.return = e,
        t.return = e,
        i.sibling = t,
        e.child = i,
        e.child.memoizedState = uh(r),
        e.memoizedState = ch,
        t) : sp(e, o));
    if (s = t.memoizedState,
    s !== null && (a = s.dehydrated,
    a !== null))
        return Tk(t, e, o, n, a, s, r);
    if (i) {
        i = n.fallback,
        o = e.mode,
        s = t.child,
        a = s.sibling;
        var l = {
            mode: "hidden",
            children: n.children
        };
        return !(o & 1) && e.child !== s ? (n = e.child,
        n.childLanes = 0,
        n.pendingProps = l,
        e.deletions = null) : (n = Fn(s, l),
        n.subtreeFlags = s.subtreeFlags & 14680064),
        a !== null ? i = Fn(a, i) : (i = Rs(i, o, r, null),
        i.flags |= 2),
        i.return = e,
        n.return = e,
        n.sibling = i,
        e.child = n,
        n = i,
        i = e.child,
        o = t.child.memoizedState,
        o = o === null ? uh(r) : {
            baseLanes: o.baseLanes | r,
            cachePool: null,
            transitions: o.transitions
        },
        i.memoizedState = o,
        i.childLanes = t.childLanes & ~r,
        e.memoizedState = ch,
        n
    }
    return i = t.child,
    t = i.sibling,
    n = Fn(i, {
        mode: "visible",
        children: n.children
    }),
    !(e.mode & 1) && (n.lanes = r),
    n.return = e,
    n.sibling = null,
    t !== null && (r = e.deletions,
    r === null ? (e.deletions = [t],
    e.flags |= 16) : r.push(t)),
    e.child = n,
    e.memoizedState = null,
    n
}
function sp(t, e) {
    return e = Jc({
        mode: "visible",
        children: e
    }, t.mode, 0, null),
    e.return = t,
    t.child = e
}
function hl(t, e, r, n) {
    return n !== null && Wf(n),
    Xi(e, t.child, null, r),
    t = sp(e, e.pendingProps.children),
    t.flags |= 2,
    e.memoizedState = null,
    t
}
function Tk(t, e, r, n, s, i, o) {
    if (r)
        return e.flags & 256 ? (e.flags &= -257,
        n = Zu(Error(O(422))),
        hl(t, e, o, n)) : e.memoizedState !== null ? (e.child = t.child,
        e.flags |= 128,
        null) : (i = n.fallback,
        s = e.mode,
        n = Jc({
            mode: "visible",
            children: n.children
        }, s, 0, null),
        i = Rs(i, s, o, null),
        i.flags |= 2,
        n.return = e,
        i.return = e,
        n.sibling = i,
        e.child = n,
        e.mode & 1 && Xi(e, t.child, null, o),
        e.child.memoizedState = uh(o),
        e.memoizedState = ch,
        i);
    if (!(e.mode & 1))
        return hl(t, e, o, null);
    if (s.data === "$!") {
        if (n = s.nextSibling && s.nextSibling.dataset,
        n)
            var a = n.dgst;
        return n = a,
        i = Error(O(419)),
        n = Zu(i, n, void 0),
        hl(t, e, o, n)
    }
    if (a = (o & t.childLanes) !== 0,
    Et || a) {
        if (n = Xe,
        n !== null) {
            switch (o & -o) {
            case 4:
                s = 2;
                break;
            case 16:
                s = 8;
                break;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                s = 32;
                break;
            case 536870912:
                s = 268435456;
                break;
            default:
                s = 0
            }
            s = s & (n.suspendedLanes | o) ? 0 : s,
            s !== 0 && s !== i.retryLane && (i.retryLane = s,
            Qr(t, s),
            yr(n, t, s, -1))
        }
        return up(),
        n = Zu(Error(O(421))),
        hl(t, e, o, n)
    }
    return s.data === "$?" ? (e.flags |= 128,
    e.child = t.child,
    e = Uk.bind(null, t),
    s._reactRetry = e,
    null) : (t = i.treeContext,
    $t = Ln(s.nextSibling),
    Dt = e,
    Oe = !0,
    gr = null,
    t !== null && (qt[Gt++] = Vr,
    qt[Gt++] = Wr,
    qt[Gt++] = Ps,
    Vr = t.id,
    Wr = t.overflow,
    Ps = e),
    e = sp(e, n.children),
    e.flags |= 4096,
    e)
}
function tg(t, e, r) {
    t.lanes |= e;
    var n = t.alternate;
    n !== null && (n.lanes |= e),
    nh(t.return, e, r)
}
function Yu(t, e, r, n, s) {
    var i = t.memoizedState;
    i === null ? t.memoizedState = {
        isBackwards: e,
        rendering: null,
        renderingStartTime: 0,
        last: n,
        tail: r,
        tailMode: s
    } : (i.isBackwards = e,
    i.rendering = null,
    i.renderingStartTime = 0,
    i.last = n,
    i.tail = r,
    i.tailMode = s)
}
function X0(t, e, r) {
    var n = e.pendingProps
      , s = n.revealOrder
      , i = n.tail;
    if (mt(t, e, n.children, r),
    n = Le.current,
    n & 2)
        n = n & 1 | 2,
        e.flags |= 128;
    else {
        if (t !== null && t.flags & 128)
            e: for (t = e.child; t !== null; ) {
                if (t.tag === 13)
                    t.memoizedState !== null && tg(t, r, e);
                else if (t.tag === 19)
                    tg(t, r, e);
                else if (t.child !== null) {
                    t.child.return = t,
                    t = t.child;
                    continue
                }
                if (t === e)
                    break e;
                for (; t.sibling === null; ) {
                    if (t.return === null || t.return === e)
                        break e;
                    t = t.return
                }
                t.sibling.return = t.return,
                t = t.sibling
            }
        n &= 1
    }
    if (Ee(Le, n),
    !(e.mode & 1))
        e.memoizedState = null;
    else
        switch (s) {
        case "forwards":
            for (r = e.child,
            s = null; r !== null; )
                t = r.alternate,
                t !== null && dc(t) === null && (s = r),
                r = r.sibling;
            r = s,
            r === null ? (s = e.child,
            e.child = null) : (s = r.sibling,
            r.sibling = null),
            Yu(e, !1, s, r, i);
            break;
        case "backwards":
            for (r = null,
            s = e.child,
            e.child = null; s !== null; ) {
                if (t = s.alternate,
                t !== null && dc(t) === null) {
                    e.child = s;
                    break
                }
                t = s.sibling,
                s.sibling = r,
                r = s,
                s = t
            }
            Yu(e, !0, r, null, i);
            break;
        case "together":
            Yu(e, !1, null, null, void 0);
            break;
        default:
            e.memoizedState = null
        }
    return e.child
}
function Fl(t, e) {
    !(e.mode & 1) && t !== null && (t.alternate = null,
    e.alternate = null,
    e.flags |= 2)
}
function Jr(t, e, r) {
    if (t !== null && (e.dependencies = t.dependencies),
    js |= e.lanes,
    !(r & e.childLanes))
        return null;
    if (t !== null && e.child !== t.child)
        throw Error(O(153));
    if (e.child !== null) {
        for (t = e.child,
        r = Fn(t, t.pendingProps),
        e.child = r,
        r.return = e; t.sibling !== null; )
            t = t.sibling,
            r = r.sibling = Fn(t, t.pendingProps),
            r.return = e;
        r.sibling = null
    }
    return e.child
}
function Rk(t, e, r) {
    switch (e.tag) {
    case 3:
        Z0(e),
        Yi();
        break;
    case 5:
        E0(e);
        break;
    case 1:
        Tt(e.type) && ic(e);
        break;
    case 4:
        Jf(e, e.stateNode.containerInfo);
        break;
    case 10:
        var n = e.type._context
          , s = e.memoizedProps.value;
        Ee(lc, n._currentValue),
        n._currentValue = s;
        break;
    case 13:
        if (n = e.memoizedState,
        n !== null)
            return n.dehydrated !== null ? (Ee(Le, Le.current & 1),
            e.flags |= 128,
            null) : r & e.child.childLanes ? Y0(t, e, r) : (Ee(Le, Le.current & 1),
            t = Jr(t, e, r),
            t !== null ? t.sibling : null);
        Ee(Le, Le.current & 1);
        break;
    case 19:
        if (n = (r & e.childLanes) !== 0,
        t.flags & 128) {
            if (n)
                return X0(t, e, r);
            e.flags |= 128
        }
        if (s = e.memoizedState,
        s !== null && (s.rendering = null,
        s.tail = null,
        s.lastEffect = null),
        Ee(Le, Le.current),
        n)
            break;
        return null;
    case 22:
    case 23:
        return e.lanes = 0,
        Q0(t, e, r)
    }
    return Jr(t, e, r)
}
var ew, dh, tw, rw;
ew = function(t, e) {
    for (var r = e.child; r !== null; ) {
        if (r.tag === 5 || r.tag === 6)
            t.appendChild(r.stateNode);
        else if (r.tag !== 4 && r.child !== null) {
            r.child.return = r,
            r = r.child;
            continue
        }
        if (r === e)
            break;
        for (; r.sibling === null; ) {
            if (r.return === null || r.return === e)
                return;
            r = r.return
        }
        r.sibling.return = r.return,
        r = r.sibling
    }
}
;
dh = function() {}
;
tw = function(t, e, r, n) {
    var s = t.memoizedProps;
    if (s !== n) {
        t = e.stateNode,
        gs(jr.current);
        var i = null;
        switch (r) {
        case "input":
            s = Od(t, s),
            n = Od(t, n),
            i = [];
            break;
        case "select":
            s = De({}, s, {
                value: void 0
            }),
            n = De({}, n, {
                value: void 0
            }),
            i = [];
            break;
        case "textarea":
            s = $d(t, s),
            n = $d(t, n),
            i = [];
            break;
        default:
            typeof s.onClick != "function" && typeof n.onClick == "function" && (t.onclick = nc)
        }
        Md(r, n);
        var o;
        r = null;
        for (c in s)
            if (!n.hasOwnProperty(c) && s.hasOwnProperty(c) && s[c] != null)
                if (c === "style") {
                    var a = s[c];
                    for (o in a)
                        a.hasOwnProperty(o) && (r || (r = {}),
                        r[o] = "")
                } else
                    c !== "dangerouslySetInnerHTML" && c !== "children" && c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && c !== "autoFocus" && (ea.hasOwnProperty(c) ? i || (i = []) : (i = i || []).push(c, null));
        for (c in n) {
            var l = n[c];
            if (a = s != null ? s[c] : void 0,
            n.hasOwnProperty(c) && l !== a && (l != null || a != null))
                if (c === "style")
                    if (a) {
                        for (o in a)
                            !a.hasOwnProperty(o) || l && l.hasOwnProperty(o) || (r || (r = {}),
                            r[o] = "");
                        for (o in l)
                            l.hasOwnProperty(o) && a[o] !== l[o] && (r || (r = {}),
                            r[o] = l[o])
                    } else
                        r || (i || (i = []),
                        i.push(c, r)),
                        r = l;
                else
                    c === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                    a = a ? a.__html : void 0,
                    l != null && a !== l && (i = i || []).push(c, l)) : c === "children" ? typeof l != "string" && typeof l != "number" || (i = i || []).push(c, "" + l) : c !== "suppressContentEditableWarning" && c !== "suppressHydrationWarning" && (ea.hasOwnProperty(c) ? (l != null && c === "onScroll" && Ne("scroll", t),
                    i || a === l || (i = [])) : (i = i || []).push(c, l))
        }
        r && (i = i || []).push("style", r);
        var c = i;
        (e.updateQueue = c) && (e.flags |= 4)
    }
}
;
rw = function(t, e, r, n) {
    r !== n && (e.flags |= 4)
}
;
function No(t, e) {
    if (!Oe)
        switch (t.tailMode) {
        case "hidden":
            e = t.tail;
            for (var r = null; e !== null; )
                e.alternate !== null && (r = e),
                e = e.sibling;
            r === null ? t.tail = null : r.sibling = null;
            break;
        case "collapsed":
            r = t.tail;
            for (var n = null; r !== null; )
                r.alternate !== null && (n = r),
                r = r.sibling;
            n === null ? e || t.tail === null ? t.tail = null : t.tail.sibling = null : n.sibling = null
        }
}
function ct(t) {
    var e = t.alternate !== null && t.alternate.child === t.child
      , r = 0
      , n = 0;
    if (e)
        for (var s = t.child; s !== null; )
            r |= s.lanes | s.childLanes,
            n |= s.subtreeFlags & 14680064,
            n |= s.flags & 14680064,
            s.return = t,
            s = s.sibling;
    else
        for (s = t.child; s !== null; )
            r |= s.lanes | s.childLanes,
            n |= s.subtreeFlags,
            n |= s.flags,
            s.return = t,
            s = s.sibling;
    return t.subtreeFlags |= n,
    t.childLanes = r,
    e
}
function Nk(t, e, r) {
    var n = e.pendingProps;
    switch (Vf(e),
    e.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
        return ct(e),
        null;
    case 1:
        return Tt(e.type) && sc(),
        ct(e),
        null;
    case 3:
        return n = e.stateNode,
        eo(),
        Pe(Ct),
        Pe(ht),
        Yf(),
        n.pendingContext && (n.context = n.pendingContext,
        n.pendingContext = null),
        (t === null || t.child === null) && (ul(e) ? e.flags |= 4 : t === null || t.memoizedState.isDehydrated && !(e.flags & 256) || (e.flags |= 1024,
        gr !== null && (wh(gr),
        gr = null))),
        dh(t, e),
        ct(e),
        null;
    case 5:
        Zf(e);
        var s = gs(ha.current);
        if (r = e.type,
        t !== null && e.stateNode != null)
            tw(t, e, r, n, s),
            t.ref !== e.ref && (e.flags |= 512,
            e.flags |= 2097152);
        else {
            if (!n) {
                if (e.stateNode === null)
                    throw Error(O(166));
                return ct(e),
                null
            }
            if (t = gs(jr.current),
            ul(e)) {
                n = e.stateNode,
                r = e.type;
                var i = e.memoizedProps;
                switch (n[Rr] = e,
                n[ua] = i,
                t = (e.mode & 1) !== 0,
                r) {
                case "dialog":
                    Ne("cancel", n),
                    Ne("close", n);
                    break;
                case "iframe":
                case "object":
                case "embed":
                    Ne("load", n);
                    break;
                case "video":
                case "audio":
                    for (s = 0; s < $o.length; s++)
                        Ne($o[s], n);
                    break;
                case "source":
                    Ne("error", n);
                    break;
                case "img":
                case "image":
                case "link":
                    Ne("error", n),
                    Ne("load", n);
                    break;
                case "details":
                    Ne("toggle", n);
                    break;
                case "input":
                    um(n, i),
                    Ne("invalid", n);
                    break;
                case "select":
                    n._wrapperState = {
                        wasMultiple: !!i.multiple
                    },
                    Ne("invalid", n);
                    break;
                case "textarea":
                    hm(n, i),
                    Ne("invalid", n)
                }
                Md(r, i),
                s = null;
                for (var o in i)
                    if (i.hasOwnProperty(o)) {
                        var a = i[o];
                        o === "children" ? typeof a == "string" ? n.textContent !== a && (i.suppressHydrationWarning !== !0 && cl(n.textContent, a, t),
                        s = ["children", a]) : typeof a == "number" && n.textContent !== "" + a && (i.suppressHydrationWarning !== !0 && cl(n.textContent, a, t),
                        s = ["children", "" + a]) : ea.hasOwnProperty(o) && a != null && o === "onScroll" && Ne("scroll", n)
                    }
                switch (r) {
                case "input":
                    tl(n),
                    dm(n, i, !0);
                    break;
                case "textarea":
                    tl(n),
                    fm(n);
                    break;
                case "select":
                case "option":
                    break;
                default:
                    typeof i.onClick == "function" && (n.onclick = nc)
                }
                n = s,
                e.updateQueue = n,
                n !== null && (e.flags |= 4)
            } else {
                o = s.nodeType === 9 ? s : s.ownerDocument,
                t === "http://www.w3.org/1999/xhtml" && (t = Py(r)),
                t === "http://www.w3.org/1999/xhtml" ? r === "script" ? (t = o.createElement("div"),
                t.innerHTML = "<script><\/script>",
                t = t.removeChild(t.firstChild)) : typeof n.is == "string" ? t = o.createElement(r, {
                    is: n.is
                }) : (t = o.createElement(r),
                r === "select" && (o = t,
                n.multiple ? o.multiple = !0 : n.size && (o.size = n.size))) : t = o.createElementNS(t, r),
                t[Rr] = e,
                t[ua] = n,
                ew(t, e, !1, !1),
                e.stateNode = t;
                e: {
                    switch (o = Fd(r, n),
                    r) {
                    case "dialog":
                        Ne("cancel", t),
                        Ne("close", t),
                        s = n;
                        break;
                    case "iframe":
                    case "object":
                    case "embed":
                        Ne("load", t),
                        s = n;
                        break;
                    case "video":
                    case "audio":
                        for (s = 0; s < $o.length; s++)
                            Ne($o[s], t);
                        s = n;
                        break;
                    case "source":
                        Ne("error", t),
                        s = n;
                        break;
                    case "img":
                    case "image":
                    case "link":
                        Ne("error", t),
                        Ne("load", t),
                        s = n;
                        break;
                    case "details":
                        Ne("toggle", t),
                        s = n;
                        break;
                    case "input":
                        um(t, n),
                        s = Od(t, n),
                        Ne("invalid", t);
                        break;
                    case "option":
                        s = n;
                        break;
                    case "select":
                        t._wrapperState = {
                            wasMultiple: !!n.multiple
                        },
                        s = De({}, n, {
                            value: void 0
                        }),
                        Ne("invalid", t);
                        break;
                    case "textarea":
                        hm(t, n),
                        s = $d(t, n),
                        Ne("invalid", t);
                        break;
                    default:
                        s = n
                    }
                    Md(r, s),
                    a = s;
                    for (i in a)
                        if (a.hasOwnProperty(i)) {
                            var l = a[i];
                            i === "style" ? Oy(t, l) : i === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0,
                            l != null && Ay(t, l)) : i === "children" ? typeof l == "string" ? (r !== "textarea" || l !== "") && ta(t, l) : typeof l == "number" && ta(t, "" + l) : i !== "suppressContentEditableWarning" && i !== "suppressHydrationWarning" && i !== "autoFocus" && (ea.hasOwnProperty(i) ? l != null && i === "onScroll" && Ne("scroll", t) : l != null && Rf(t, i, l, o))
                        }
                    switch (r) {
                    case "input":
                        tl(t),
                        dm(t, n, !1);
                        break;
                    case "textarea":
                        tl(t),
                        fm(t);
                        break;
                    case "option":
                        n.value != null && t.setAttribute("value", "" + Wn(n.value));
                        break;
                    case "select":
                        t.multiple = !!n.multiple,
                        i = n.value,
                        i != null ? Ei(t, !!n.multiple, i, !1) : n.defaultValue != null && Ei(t, !!n.multiple, n.defaultValue, !0);
                        break;
                    default:
                        typeof s.onClick == "function" && (t.onclick = nc)
                    }
                    switch (r) {
                    case "button":
                    case "input":
                    case "select":
                    case "textarea":
                        n = !!n.autoFocus;
                        break e;
                    case "img":
                        n = !0;
                        break e;
                    default:
                        n = !1
                    }
                }
                n && (e.flags |= 4)
            }
            e.ref !== null && (e.flags |= 512,
            e.flags |= 2097152)
        }
        return ct(e),
        null;
    case 6:
        if (t && e.stateNode != null)
            rw(t, e, t.memoizedProps, n);
        else {
            if (typeof n != "string" && e.stateNode === null)
                throw Error(O(166));
            if (r = gs(ha.current),
            gs(jr.current),
            ul(e)) {
                if (n = e.stateNode,
                r = e.memoizedProps,
                n[Rr] = e,
                (i = n.nodeValue !== r) && (t = Dt,
                t !== null))
                    switch (t.tag) {
                    case 3:
                        cl(n.nodeValue, r, (t.mode & 1) !== 0);
                        break;
                    case 5:
                        t.memoizedProps.suppressHydrationWarning !== !0 && cl(n.nodeValue, r, (t.mode & 1) !== 0)
                    }
                i && (e.flags |= 4)
            } else
                n = (r.nodeType === 9 ? r : r.ownerDocument).createTextNode(n),
                n[Rr] = e,
                e.stateNode = n
        }
        return ct(e),
        null;
    case 13:
        if (Pe(Le),
        n = e.memoizedState,
        t === null || t.memoizedState !== null && t.memoizedState.dehydrated !== null) {
            if (Oe && $t !== null && e.mode & 1 && !(e.flags & 128))
                x0(),
                Yi(),
                e.flags |= 98560,
                i = !1;
            else if (i = ul(e),
            n !== null && n.dehydrated !== null) {
                if (t === null) {
                    if (!i)
                        throw Error(O(318));
                    if (i = e.memoizedState,
                    i = i !== null ? i.dehydrated : null,
                    !i)
                        throw Error(O(317));
                    i[Rr] = e
                } else
                    Yi(),
                    !(e.flags & 128) && (e.memoizedState = null),
                    e.flags |= 4;
                ct(e),
                i = !1
            } else
                gr !== null && (wh(gr),
                gr = null),
                i = !0;
            if (!i)
                return e.flags & 65536 ? e : null
        }
        return e.flags & 128 ? (e.lanes = r,
        e) : (n = n !== null,
        n !== (t !== null && t.memoizedState !== null) && n && (e.child.flags |= 8192,
        e.mode & 1 && (t === null || Le.current & 1 ? Je === 0 && (Je = 3) : up())),
        e.updateQueue !== null && (e.flags |= 4),
        ct(e),
        null);
    case 4:
        return eo(),
        dh(t, e),
        t === null && la(e.stateNode.containerInfo),
        ct(e),
        null;
    case 10:
        return qf(e.type._context),
        ct(e),
        null;
    case 17:
        return Tt(e.type) && sc(),
        ct(e),
        null;
    case 19:
        if (Pe(Le),
        i = e.memoizedState,
        i === null)
            return ct(e),
            null;
        if (n = (e.flags & 128) !== 0,
        o = i.rendering,
        o === null)
            if (n)
                No(i, !1);
            else {
                if (Je !== 0 || t !== null && t.flags & 128)
                    for (t = e.child; t !== null; ) {
                        if (o = dc(t),
                        o !== null) {
                            for (e.flags |= 128,
                            No(i, !1),
                            n = o.updateQueue,
                            n !== null && (e.updateQueue = n,
                            e.flags |= 4),
                            e.subtreeFlags = 0,
                            n = r,
                            r = e.child; r !== null; )
                                i = r,
                                t = n,
                                i.flags &= 14680066,
                                o = i.alternate,
                                o === null ? (i.childLanes = 0,
                                i.lanes = t,
                                i.child = null,
                                i.subtreeFlags = 0,
                                i.memoizedProps = null,
                                i.memoizedState = null,
                                i.updateQueue = null,
                                i.dependencies = null,
                                i.stateNode = null) : (i.childLanes = o.childLanes,
                                i.lanes = o.lanes,
                                i.child = o.child,
                                i.subtreeFlags = 0,
                                i.deletions = null,
                                i.memoizedProps = o.memoizedProps,
                                i.memoizedState = o.memoizedState,
                                i.updateQueue = o.updateQueue,
                                i.type = o.type,
                                t = o.dependencies,
                                i.dependencies = t === null ? null : {
                                    lanes: t.lanes,
                                    firstContext: t.firstContext
                                }),
                                r = r.sibling;
                            return Ee(Le, Le.current & 1 | 2),
                            e.child
                        }
                        t = t.sibling
                    }
                i.tail !== null && He() > ro && (e.flags |= 128,
                n = !0,
                No(i, !1),
                e.lanes = 4194304)
            }
        else {
            if (!n)
                if (t = dc(o),
                t !== null) {
                    if (e.flags |= 128,
                    n = !0,
                    r = t.updateQueue,
                    r !== null && (e.updateQueue = r,
                    e.flags |= 4),
                    No(i, !0),
                    i.tail === null && i.tailMode === "hidden" && !o.alternate && !Oe)
                        return ct(e),
                        null
                } else
                    2 * He() - i.renderingStartTime > ro && r !== 1073741824 && (e.flags |= 128,
                    n = !0,
                    No(i, !1),
                    e.lanes = 4194304);
            i.isBackwards ? (o.sibling = e.child,
            e.child = o) : (r = i.last,
            r !== null ? r.sibling = o : e.child = o,
            i.last = o)
        }
        return i.tail !== null ? (e = i.tail,
        i.rendering = e,
        i.tail = e.sibling,
        i.renderingStartTime = He(),
        e.sibling = null,
        r = Le.current,
        Ee(Le, n ? r & 1 | 2 : r & 1),
        e) : (ct(e),
        null);
    case 22:
    case 23:
        return cp(),
        n = e.memoizedState !== null,
        t !== null && t.memoizedState !== null !== n && (e.flags |= 8192),
        n && e.mode & 1 ? Pt & 1073741824 && (ct(e),
        e.subtreeFlags & 6 && (e.flags |= 8192)) : ct(e),
        null;
    case 24:
        return null;
    case 25:
        return null
    }
    throw Error(O(156, e.tag))
}
function Pk(t, e) {
    switch (Vf(e),
    e.tag) {
    case 1:
        return Tt(e.type) && sc(),
        t = e.flags,
        t & 65536 ? (e.flags = t & -65537 | 128,
        e) : null;
    case 3:
        return eo(),
        Pe(Ct),
        Pe(ht),
        Yf(),
        t = e.flags,
        t & 65536 && !(t & 128) ? (e.flags = t & -65537 | 128,
        e) : null;
    case 5:
        return Zf(e),
        null;
    case 13:
        if (Pe(Le),
        t = e.memoizedState,
        t !== null && t.dehydrated !== null) {
            if (e.alternate === null)
                throw Error(O(340));
            Yi()
        }
        return t = e.flags,
        t & 65536 ? (e.flags = t & -65537 | 128,
        e) : null;
    case 19:
        return Pe(Le),
        null;
    case 4:
        return eo(),
        null;
    case 10:
        return qf(e.type._context),
        null;
    case 22:
    case 23:
        return cp(),
        null;
    case 24:
        return null;
    default:
        return null
    }
}
var fl = !1
  , dt = !1
  , Ak = typeof WeakSet == "function" ? WeakSet : Set
  , z = null;
function xi(t, e) {
    var r = t.ref;
    if (r !== null)
        if (typeof r == "function")
            try {
                r(null)
            } catch (n) {
                Ve(t, e, n)
            }
        else
            r.current = null
}
function hh(t, e, r) {
    try {
        r()
    } catch (n) {
        Ve(t, e, n)
    }
}
var rg = !1;
function jk(t, e) {
    if (Qd = ec,
    t = a0(),
    Bf(t)) {
        if ("selectionStart"in t)
            var r = {
                start: t.selectionStart,
                end: t.selectionEnd
            };
        else
            e: {
                r = (r = t.ownerDocument) && r.defaultView || window;
                var n = r.getSelection && r.getSelection();
                if (n && n.rangeCount !== 0) {
                    r = n.anchorNode;
                    var s = n.anchorOffset
                      , i = n.focusNode;
                    n = n.focusOffset;
                    try {
                        r.nodeType,
                        i.nodeType
                    } catch {
                        r = null;
                        break e
                    }
                    var o = 0
                      , a = -1
                      , l = -1
                      , c = 0
                      , u = 0
                      , h = t
                      , p = null;
                    t: for (; ; ) {
                        for (var f; h !== r || s !== 0 && h.nodeType !== 3 || (a = o + s),
                        h !== i || n !== 0 && h.nodeType !== 3 || (l = o + n),
                        h.nodeType === 3 && (o += h.nodeValue.length),
                        (f = h.firstChild) !== null; )
                            p = h,
                            h = f;
                        for (; ; ) {
                            if (h === t)
                                break t;
                            if (p === r && ++c === s && (a = o),
                            p === i && ++u === n && (l = o),
                            (f = h.nextSibling) !== null)
                                break;
                            h = p,
                            p = h.parentNode
                        }
                        h = f
                    }
                    r = a === -1 || l === -1 ? null : {
                        start: a,
                        end: l
                    }
                } else
                    r = null
            }
        r = r || {
            start: 0,
            end: 0
        }
    } else
        r = null;
    for (Jd = {
        focusedElem: t,
        selectionRange: r
    },
    ec = !1,
    z = e; z !== null; )
        if (e = z,
        t = e.child,
        (e.subtreeFlags & 1028) !== 0 && t !== null)
            t.return = e,
            z = t;
        else
            for (; z !== null; ) {
                e = z;
                try {
                    var b = e.alternate;
                    if (e.flags & 1024)
                        switch (e.tag) {
                        case 0:
                        case 11:
                        case 15:
                            break;
                        case 1:
                            if (b !== null) {
                                var m = b.memoizedProps
                                  , x = b.memoizedState
                                  , w = e.stateNode
                                  , g = w.getSnapshotBeforeUpdate(e.elementType === e.type ? m : ur(e.type, m), x);
                                w.__reactInternalSnapshotBeforeUpdate = g
                            }
                            break;
                        case 3:
                            var v = e.stateNode.containerInfo;
                            v.nodeType === 1 ? v.textContent = "" : v.nodeType === 9 && v.documentElement && v.removeChild(v.documentElement);
                            break;
                        case 5:
                        case 6:
                        case 4:
                        case 17:
                            break;
                        default:
                            throw Error(O(163))
                        }
                } catch (_) {
                    Ve(e, e.return, _)
                }
                if (t = e.sibling,
                t !== null) {
                    t.return = e.return,
                    z = t;
                    break
                }
                z = e.return
            }
    return b = rg,
    rg = !1,
    b
}
function Go(t, e, r) {
    var n = e.updateQueue;
    if (n = n !== null ? n.lastEffect : null,
    n !== null) {
        var s = n = n.next;
        do {
            if ((s.tag & t) === t) {
                var i = s.destroy;
                s.destroy = void 0,
                i !== void 0 && hh(e, r, i)
            }
            s = s.next
        } while (s !== n)
    }
}
function Gc(t, e) {
    if (e = e.updateQueue,
    e = e !== null ? e.lastEffect : null,
    e !== null) {
        var r = e = e.next;
        do {
            if ((r.tag & t) === t) {
                var n = r.create;
                r.destroy = n()
            }
            r = r.next
        } while (r !== e)
    }
}
function fh(t) {
    var e = t.ref;
    if (e !== null) {
        var r = t.stateNode;
        switch (t.tag) {
        case 5:
            t = r;
            break;
        default:
            t = r
        }
        typeof e == "function" ? e(t) : e.current = t
    }
}
function nw(t) {
    var e = t.alternate;
    e !== null && (t.alternate = null,
    nw(e)),
    t.child = null,
    t.deletions = null,
    t.sibling = null,
    t.tag === 5 && (e = t.stateNode,
    e !== null && (delete e[Rr],
    delete e[ua],
    delete e[Xd],
    delete e[pk],
    delete e[mk])),
    t.stateNode = null,
    t.return = null,
    t.dependencies = null,
    t.memoizedProps = null,
    t.memoizedState = null,
    t.pendingProps = null,
    t.stateNode = null,
    t.updateQueue = null
}
function sw(t) {
    return t.tag === 5 || t.tag === 3 || t.tag === 4
}
function ng(t) {
    e: for (; ; ) {
        for (; t.sibling === null; ) {
            if (t.return === null || sw(t.return))
                return null;
            t = t.return
        }
        for (t.sibling.return = t.return,
        t = t.sibling; t.tag !== 5 && t.tag !== 6 && t.tag !== 18; ) {
            if (t.flags & 2 || t.child === null || t.tag === 4)
                continue e;
            t.child.return = t,
            t = t.child
        }
        if (!(t.flags & 2))
            return t.stateNode
    }
}
function ph(t, e, r) {
    var n = t.tag;
    if (n === 5 || n === 6)
        t = t.stateNode,
        e ? r.nodeType === 8 ? r.parentNode.insertBefore(t, e) : r.insertBefore(t, e) : (r.nodeType === 8 ? (e = r.parentNode,
        e.insertBefore(t, r)) : (e = r,
        e.appendChild(t)),
        r = r._reactRootContainer,
        r != null || e.onclick !== null || (e.onclick = nc));
    else if (n !== 4 && (t = t.child,
    t !== null))
        for (ph(t, e, r),
        t = t.sibling; t !== null; )
            ph(t, e, r),
            t = t.sibling
}
function mh(t, e, r) {
    var n = t.tag;
    if (n === 5 || n === 6)
        t = t.stateNode,
        e ? r.insertBefore(t, e) : r.appendChild(t);
    else if (n !== 4 && (t = t.child,
    t !== null))
        for (mh(t, e, r),
        t = t.sibling; t !== null; )
            mh(t, e, r),
            t = t.sibling
}
var nt = null
  , pr = !1;
function ln(t, e, r) {
    for (r = r.child; r !== null; )
        iw(t, e, r),
        r = r.sibling
}
function iw(t, e, r) {
    if (Ar && typeof Ar.onCommitFiberUnmount == "function")
        try {
            Ar.onCommitFiberUnmount(Uc, r)
        } catch {}
    switch (r.tag) {
    case 5:
        dt || xi(r, e);
    case 6:
        var n = nt
          , s = pr;
        nt = null,
        ln(t, e, r),
        nt = n,
        pr = s,
        nt !== null && (pr ? (t = nt,
        r = r.stateNode,
        t.nodeType === 8 ? t.parentNode.removeChild(r) : t.removeChild(r)) : nt.removeChild(r.stateNode));
        break;
    case 18:
        nt !== null && (pr ? (t = nt,
        r = r.stateNode,
        t.nodeType === 8 ? Hu(t.parentNode, r) : t.nodeType === 1 && Hu(t, r),
        ia(t)) : Hu(nt, r.stateNode));
        break;
    case 4:
        n = nt,
        s = pr,
        nt = r.stateNode.containerInfo,
        pr = !0,
        ln(t, e, r),
        nt = n,
        pr = s;
        break;
    case 0:
    case 11:
    case 14:
    case 15:
        if (!dt && (n = r.updateQueue,
        n !== null && (n = n.lastEffect,
        n !== null))) {
            s = n = n.next;
            do {
                var i = s
                  , o = i.destroy;
                i = i.tag,
                o !== void 0 && (i & 2 || i & 4) && hh(r, e, o),
                s = s.next
            } while (s !== n)
        }
        ln(t, e, r);
        break;
    case 1:
        if (!dt && (xi(r, e),
        n = r.stateNode,
        typeof n.componentWillUnmount == "function"))
            try {
                n.props = r.memoizedProps,
                n.state = r.memoizedState,
                n.componentWillUnmount()
            } catch (a) {
                Ve(r, e, a)
            }
        ln(t, e, r);
        break;
    case 21:
        ln(t, e, r);
        break;
    case 22:
        r.mode & 1 ? (dt = (n = dt) || r.memoizedState !== null,
        ln(t, e, r),
        dt = n) : ln(t, e, r);
        break;
    default:
        ln(t, e, r)
    }
}
function sg(t) {
    var e = t.updateQueue;
    if (e !== null) {
        t.updateQueue = null;
        var r = t.stateNode;
        r === null && (r = t.stateNode = new Ak),
        e.forEach(function(n) {
            var s = Bk.bind(null, t, n);
            r.has(n) || (r.add(n),
            n.then(s, s))
        })
    }
}
function or(t, e) {
    var r = e.deletions;
    if (r !== null)
        for (var n = 0; n < r.length; n++) {
            var s = r[n];
            try {
                var i = t
                  , o = e
                  , a = o;
                e: for (; a !== null; ) {
                    switch (a.tag) {
                    case 5:
                        nt = a.stateNode,
                        pr = !1;
                        break e;
                    case 3:
                        nt = a.stateNode.containerInfo,
                        pr = !0;
                        break e;
                    case 4:
                        nt = a.stateNode.containerInfo,
                        pr = !0;
                        break e
                    }
                    a = a.return
                }
                if (nt === null)
                    throw Error(O(160));
                iw(i, o, s),
                nt = null,
                pr = !1;
                var l = s.alternate;
                l !== null && (l.return = null),
                s.return = null
            } catch (c) {
                Ve(s, e, c)
            }
        }
    if (e.subtreeFlags & 12854)
        for (e = e.child; e !== null; )
            ow(e, t),
            e = e.sibling
}
function ow(t, e) {
    var r = t.alternate
      , n = t.flags;
    switch (t.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
        if (or(e, t),
        Sr(t),
        n & 4) {
            try {
                Go(3, t, t.return),
                Gc(3, t)
            } catch (m) {
                Ve(t, t.return, m)
            }
            try {
                Go(5, t, t.return)
            } catch (m) {
                Ve(t, t.return, m)
            }
        }
        break;
    case 1:
        or(e, t),
        Sr(t),
        n & 512 && r !== null && xi(r, r.return);
        break;
    case 5:
        if (or(e, t),
        Sr(t),
        n & 512 && r !== null && xi(r, r.return),
        t.flags & 32) {
            var s = t.stateNode;
            try {
                ta(s, "")
            } catch (m) {
                Ve(t, t.return, m)
            }
        }
        if (n & 4 && (s = t.stateNode,
        s != null)) {
            var i = t.memoizedProps
              , o = r !== null ? r.memoizedProps : i
              , a = t.type
              , l = t.updateQueue;
            if (t.updateQueue = null,
            l !== null)
                try {
                    a === "input" && i.type === "radio" && i.name != null && Ry(s, i),
                    Fd(a, o);
                    var c = Fd(a, i);
                    for (o = 0; o < l.length; o += 2) {
                        var u = l[o]
                          , h = l[o + 1];
                        u === "style" ? Oy(s, h) : u === "dangerouslySetInnerHTML" ? Ay(s, h) : u === "children" ? ta(s, h) : Rf(s, u, h, c)
                    }
                    switch (a) {
                    case "input":
                        Id(s, i);
                        break;
                    case "textarea":
                        Ny(s, i);
                        break;
                    case "select":
                        var p = s._wrapperState.wasMultiple;
                        s._wrapperState.wasMultiple = !!i.multiple;
                        var f = i.value;
                        f != null ? Ei(s, !!i.multiple, f, !1) : p !== !!i.multiple && (i.defaultValue != null ? Ei(s, !!i.multiple, i.defaultValue, !0) : Ei(s, !!i.multiple, i.multiple ? [] : "", !1))
                    }
                    s[ua] = i
                } catch (m) {
                    Ve(t, t.return, m)
                }
        }
        break;
    case 6:
        if (or(e, t),
        Sr(t),
        n & 4) {
            if (t.stateNode === null)
                throw Error(O(162));
            s = t.stateNode,
            i = t.memoizedProps;
            try {
                s.nodeValue = i
            } catch (m) {
                Ve(t, t.return, m)
            }
        }
        break;
    case 3:
        if (or(e, t),
        Sr(t),
        n & 4 && r !== null && r.memoizedState.isDehydrated)
            try {
                ia(e.containerInfo)
            } catch (m) {
                Ve(t, t.return, m)
            }
        break;
    case 4:
        or(e, t),
        Sr(t);
        break;
    case 13:
        or(e, t),
        Sr(t),
        s = t.child,
        s.flags & 8192 && (i = s.memoizedState !== null,
        s.stateNode.isHidden = i,
        !i || s.alternate !== null && s.alternate.memoizedState !== null || (ap = He())),
        n & 4 && sg(t);
        break;
    case 22:
        if (u = r !== null && r.memoizedState !== null,
        t.mode & 1 ? (dt = (c = dt) || u,
        or(e, t),
        dt = c) : or(e, t),
        Sr(t),
        n & 8192) {
            if (c = t.memoizedState !== null,
            (t.stateNode.isHidden = c) && !u && t.mode & 1)
                for (z = t,
                u = t.child; u !== null; ) {
                    for (h = z = u; z !== null; ) {
                        switch (p = z,
                        f = p.child,
                        p.tag) {
                        case 0:
                        case 11:
                        case 14:
                        case 15:
                            Go(4, p, p.return);
                            break;
                        case 1:
                            xi(p, p.return);
                            var b = p.stateNode;
                            if (typeof b.componentWillUnmount == "function") {
                                n = p,
                                r = p.return;
                                try {
                                    e = n,
                                    b.props = e.memoizedProps,
                                    b.state = e.memoizedState,
                                    b.componentWillUnmount()
                                } catch (m) {
                                    Ve(n, r, m)
                                }
                            }
                            break;
                        case 5:
                            xi(p, p.return);
                            break;
                        case 22:
                            if (p.memoizedState !== null) {
                                og(h);
                                continue
                            }
                        }
                        f !== null ? (f.return = p,
                        z = f) : og(h)
                    }
                    u = u.sibling
                }
            e: for (u = null,
            h = t; ; ) {
                if (h.tag === 5) {
                    if (u === null) {
                        u = h;
                        try {
                            s = h.stateNode,
                            c ? (i = s.style,
                            typeof i.setProperty == "function" ? i.setProperty("display", "none", "important") : i.display = "none") : (a = h.stateNode,
                            l = h.memoizedProps.style,
                            o = l != null && l.hasOwnProperty("display") ? l.display : null,
                            a.style.display = jy("display", o))
                        } catch (m) {
                            Ve(t, t.return, m)
                        }
                    }
                } else if (h.tag === 6) {
                    if (u === null)
                        try {
                            h.stateNode.nodeValue = c ? "" : h.memoizedProps
                        } catch (m) {
                            Ve(t, t.return, m)
                        }
                } else if ((h.tag !== 22 && h.tag !== 23 || h.memoizedState === null || h === t) && h.child !== null) {
                    h.child.return = h,
                    h = h.child;
                    continue
                }
                if (h === t)
                    break e;
                for (; h.sibling === null; ) {
                    if (h.return === null || h.return === t)
                        break e;
                    u === h && (u = null),
                    h = h.return
                }
                u === h && (u = null),
                h.sibling.return = h.return,
                h = h.sibling
            }
        }
        break;
    case 19:
        or(e, t),
        Sr(t),
        n & 4 && sg(t);
        break;
    case 21:
        break;
    default:
        or(e, t),
        Sr(t)
    }
}
function Sr(t) {
    var e = t.flags;
    if (e & 2) {
        try {
            e: {
                for (var r = t.return; r !== null; ) {
                    if (sw(r)) {
                        var n = r;
                        break e
                    }
                    r = r.return
                }
                throw Error(O(160))
            }
            switch (n.tag) {
            case 5:
                var s = n.stateNode;
                n.flags & 32 && (ta(s, ""),
                n.flags &= -33);
                var i = ng(t);
                mh(t, i, s);
                break;
            case 3:
            case 4:
                var o = n.stateNode.containerInfo
                  , a = ng(t);
                ph(t, a, o);
                break;
            default:
                throw Error(O(161))
            }
        } catch (l) {
            Ve(t, t.return, l)
        }
        t.flags &= -3
    }
    e & 4096 && (t.flags &= -4097)
}
function Ok(t, e, r) {
    z = t,
    aw(t)
}
function aw(t, e, r) {
    for (var n = (t.mode & 1) !== 0; z !== null; ) {
        var s = z
          , i = s.child;
        if (s.tag === 22 && n) {
            var o = s.memoizedState !== null || fl;
            if (!o) {
                var a = s.alternate
                  , l = a !== null && a.memoizedState !== null || dt;
                a = fl;
                var c = dt;
                if (fl = o,
                (dt = l) && !c)
                    for (z = s; z !== null; )
                        o = z,
                        l = o.child,
                        o.tag === 22 && o.memoizedState !== null ? ag(s) : l !== null ? (l.return = o,
                        z = l) : ag(s);
                for (; i !== null; )
                    z = i,
                    aw(i),
                    i = i.sibling;
                z = s,
                fl = a,
                dt = c
            }
            ig(t)
        } else
            s.subtreeFlags & 8772 && i !== null ? (i.return = s,
            z = i) : ig(t)
    }
}
function ig(t) {
    for (; z !== null; ) {
        var e = z;
        if (e.flags & 8772) {
            var r = e.alternate;
            try {
                if (e.flags & 8772)
                    switch (e.tag) {
                    case 0:
                    case 11:
                    case 15:
                        dt || Gc(5, e);
                        break;
                    case 1:
                        var n = e.stateNode;
                        if (e.flags & 4 && !dt)
                            if (r === null)
                                n.componentDidMount();
                            else {
                                var s = e.elementType === e.type ? r.memoizedProps : ur(e.type, r.memoizedProps);
                                n.componentDidUpdate(s, r.memoizedState, n.__reactInternalSnapshotBeforeUpdate)
                            }
                        var i = e.updateQueue;
                        i !== null && Vm(e, i, n);
                        break;
                    case 3:
                        var o = e.updateQueue;
                        if (o !== null) {
                            if (r = null,
                            e.child !== null)
                                switch (e.child.tag) {
                                case 5:
                                    r = e.child.stateNode;
                                    break;
                                case 1:
                                    r = e.child.stateNode
                                }
                            Vm(e, o, r)
                        }
                        break;
                    case 5:
                        var a = e.stateNode;
                        if (r === null && e.flags & 4) {
                            r = a;
                            var l = e.memoizedProps;
                            switch (e.type) {
                            case "button":
                            case "input":
                            case "select":
                            case "textarea":
                                l.autoFocus && r.focus();
                                break;
                            case "img":
                                l.src && (r.src = l.src)
                            }
                        }
                        break;
                    case 6:
                        break;
                    case 4:
                        break;
                    case 12:
                        break;
                    case 13:
                        if (e.memoizedState === null) {
                            var c = e.alternate;
                            if (c !== null) {
                                var u = c.memoizedState;
                                if (u !== null) {
                                    var h = u.dehydrated;
                                    h !== null && ia(h)
                                }
                            }
                        }
                        break;
                    case 19:
                    case 17:
                    case 21:
                    case 22:
                    case 23:
                    case 25:
                        break;
                    default:
                        throw Error(O(163))
                    }
                dt || e.flags & 512 && fh(e)
            } catch (p) {
                Ve(e, e.return, p)
            }
        }
        if (e === t) {
            z = null;
            break
        }
        if (r = e.sibling,
        r !== null) {
            r.return = e.return,
            z = r;
            break
        }
        z = e.return
    }
}
function og(t) {
    for (; z !== null; ) {
        var e = z;
        if (e === t) {
            z = null;
            break
        }
        var r = e.sibling;
        if (r !== null) {
            r.return = e.return,
            z = r;
            break
        }
        z = e.return
    }
}
function ag(t) {
    for (; z !== null; ) {
        var e = z;
        try {
            switch (e.tag) {
            case 0:
            case 11:
            case 15:
                var r = e.return;
                try {
                    Gc(4, e)
                } catch (l) {
                    Ve(e, r, l)
                }
                break;
            case 1:
                var n = e.stateNode;
                if (typeof n.componentDidMount == "function") {
                    var s = e.return;
                    try {
                        n.componentDidMount()
                    } catch (l) {
                        Ve(e, s, l)
                    }
                }
                var i = e.return;
                try {
                    fh(e)
                } catch (l) {
                    Ve(e, i, l)
                }
                break;
            case 5:
                var o = e.return;
                try {
                    fh(e)
                } catch (l) {
                    Ve(e, o, l)
                }
            }
        } catch (l) {
            Ve(e, e.return, l)
        }
        if (e === t) {
            z = null;
            break
        }
        var a = e.sibling;
        if (a !== null) {
            a.return = e.return,
            z = a;
            break
        }
        z = e.return
    }
}
var Ik = Math.ceil
  , pc = en.ReactCurrentDispatcher
  , ip = en.ReactCurrentOwner
  , Yt = en.ReactCurrentBatchConfig
  , pe = 0
  , Xe = null
  , qe = null
  , it = 0
  , Pt = 0
  , bi = Yn(0)
  , Je = 0
  , ga = null
  , js = 0
  , Qc = 0
  , op = 0
  , Qo = null
  , kt = null
  , ap = 0
  , ro = 1 / 0
  , Fr = null
  , mc = !1
  , gh = null
  , Dn = null
  , pl = !1
  , Nn = null
  , gc = 0
  , Jo = 0
  , vh = null
  , Ul = -1
  , Bl = 0;
function vt() {
    return pe & 6 ? He() : Ul !== -1 ? Ul : Ul = He()
}
function Mn(t) {
    return t.mode & 1 ? pe & 2 && it !== 0 ? it & -it : vk.transition !== null ? (Bl === 0 && (Bl = Hy()),
    Bl) : (t = _e,
    t !== 0 || (t = window.event,
    t = t === void 0 ? 16 : Yy(t.type)),
    t) : 1
}
function yr(t, e, r, n) {
    if (50 < Jo)
        throw Jo = 0,
        vh = null,
        Error(O(185));
    Ma(t, r, n),
    (!(pe & 2) || t !== Xe) && (t === Xe && (!(pe & 2) && (Qc |= r),
    Je === 4 && yn(t, it)),
    Rt(t, n),
    r === 1 && pe === 0 && !(e.mode & 1) && (ro = He() + 500,
    Hc && Xn()))
}
function Rt(t, e) {
    var r = t.callbackNode;
    v1(t, e);
    var n = Xl(t, t === Xe ? it : 0);
    if (n === 0)
        r !== null && gm(r),
        t.callbackNode = null,
        t.callbackPriority = 0;
    else if (e = n & -n,
    t.callbackPriority !== e) {
        if (r != null && gm(r),
        e === 1)
            t.tag === 0 ? gk(lg.bind(null, t)) : v0(lg.bind(null, t)),
            hk(function() {
                !(pe & 6) && Xn()
            }),
            r = null;
        else {
            switch (Ky(n)) {
            case 1:
                r = Of;
                break;
            case 4:
                r = Vy;
                break;
            case 16:
                r = Yl;
                break;
            case 536870912:
                r = Wy;
                break;
            default:
                r = Yl
            }
            r = mw(r, lw.bind(null, t))
        }
        t.callbackPriority = e,
        t.callbackNode = r
    }
}
function lw(t, e) {
    if (Ul = -1,
    Bl = 0,
    pe & 6)
        throw Error(O(327));
    var r = t.callbackNode;
    if (Pi() && t.callbackNode !== r)
        return null;
    var n = Xl(t, t === Xe ? it : 0);
    if (n === 0)
        return null;
    if (n & 30 || n & t.expiredLanes || e)
        e = vc(t, n);
    else {
        e = n;
        var s = pe;
        pe |= 2;
        var i = uw();
        (Xe !== t || it !== e) && (Fr = null,
        ro = He() + 500,
        Ts(t, e));
        do
            try {
                Dk();
                break
            } catch (a) {
                cw(t, a)
            }
        while (!0);
        Kf(),
        pc.current = i,
        pe = s,
        qe !== null ? e = 0 : (Xe = null,
        it = 0,
        e = Je)
    }
    if (e !== 0) {
        if (e === 2 && (s = Wd(t),
        s !== 0 && (n = s,
        e = yh(t, s))),
        e === 1)
            throw r = ga,
            Ts(t, 0),
            yn(t, n),
            Rt(t, He()),
            r;
        if (e === 6)
            yn(t, n);
        else {
            if (s = t.current.alternate,
            !(n & 30) && !Lk(s) && (e = vc(t, n),
            e === 2 && (i = Wd(t),
            i !== 0 && (n = i,
            e = yh(t, i))),
            e === 1))
                throw r = ga,
                Ts(t, 0),
                yn(t, n),
                Rt(t, He()),
                r;
            switch (t.finishedWork = s,
            t.finishedLanes = n,
            e) {
            case 0:
            case 1:
                throw Error(O(345));
            case 2:
                us(t, kt, Fr);
                break;
            case 3:
                if (yn(t, n),
                (n & 130023424) === n && (e = ap + 500 - He(),
                10 < e)) {
                    if (Xl(t, 0) !== 0)
                        break;
                    if (s = t.suspendedLanes,
                    (s & n) !== n) {
                        vt(),
                        t.pingedLanes |= t.suspendedLanes & s;
                        break
                    }
                    t.timeoutHandle = Yd(us.bind(null, t, kt, Fr), e);
                    break
                }
                us(t, kt, Fr);
                break;
            case 4:
                if (yn(t, n),
                (n & 4194240) === n)
                    break;
                for (e = t.eventTimes,
                s = -1; 0 < n; ) {
                    var o = 31 - vr(n);
                    i = 1 << o,
                    o = e[o],
                    o > s && (s = o),
                    n &= ~i
                }
                if (n = s,
                n = He() - n,
                n = (120 > n ? 120 : 480 > n ? 480 : 1080 > n ? 1080 : 1920 > n ? 1920 : 3e3 > n ? 3e3 : 4320 > n ? 4320 : 1960 * Ik(n / 1960)) - n,
                10 < n) {
                    t.timeoutHandle = Yd(us.bind(null, t, kt, Fr), n);
                    break
                }
                us(t, kt, Fr);
                break;
            case 5:
                us(t, kt, Fr);
                break;
            default:
                throw Error(O(329))
            }
        }
    }
    return Rt(t, He()),
    t.callbackNode === r ? lw.bind(null, t) : null
}
function yh(t, e) {
    var r = Qo;
    return t.current.memoizedState.isDehydrated && (Ts(t, e).flags |= 256),
    t = vc(t, e),
    t !== 2 && (e = kt,
    kt = r,
    e !== null && wh(e)),
    t
}
function wh(t) {
    kt === null ? kt = t : kt.push.apply(kt, t)
}
function Lk(t) {
    for (var e = t; ; ) {
        if (e.flags & 16384) {
            var r = e.updateQueue;
            if (r !== null && (r = r.stores,
            r !== null))
                for (var n = 0; n < r.length; n++) {
                    var s = r[n]
                      , i = s.getSnapshot;
                    s = s.value;
                    try {
                        if (!wr(i(), s))
                            return !1
                    } catch {
                        return !1
                    }
                }
        }
        if (r = e.child,
        e.subtreeFlags & 16384 && r !== null)
            r.return = e,
            e = r;
        else {
            if (e === t)
                break;
            for (; e.sibling === null; ) {
                if (e.return === null || e.return === t)
                    return !0;
                e = e.return
            }
            e.sibling.return = e.return,
            e = e.sibling
        }
    }
    return !0
}
function yn(t, e) {
    for (e &= ~op,
    e &= ~Qc,
    t.suspendedLanes |= e,
    t.pingedLanes &= ~e,
    t = t.expirationTimes; 0 < e; ) {
        var r = 31 - vr(e)
          , n = 1 << r;
        t[r] = -1,
        e &= ~n
    }
}
function lg(t) {
    if (pe & 6)
        throw Error(O(327));
    Pi();
    var e = Xl(t, 0);
    if (!(e & 1))
        return Rt(t, He()),
        null;
    var r = vc(t, e);
    if (t.tag !== 0 && r === 2) {
        var n = Wd(t);
        n !== 0 && (e = n,
        r = yh(t, n))
    }
    if (r === 1)
        throw r = ga,
        Ts(t, 0),
        yn(t, e),
        Rt(t, He()),
        r;
    if (r === 6)
        throw Error(O(345));
    return t.finishedWork = t.current.alternate,
    t.finishedLanes = e,
    us(t, kt, Fr),
    Rt(t, He()),
    null
}
function lp(t, e) {
    var r = pe;
    pe |= 1;
    try {
        return t(e)
    } finally {
        pe = r,
        pe === 0 && (ro = He() + 500,
        Hc && Xn())
    }
}
function Os(t) {
    Nn !== null && Nn.tag === 0 && !(pe & 6) && Pi();
    var e = pe;
    pe |= 1;
    var r = Yt.transition
      , n = _e;
    try {
        if (Yt.transition = null,
        _e = 1,
        t)
            return t()
    } finally {
        _e = n,
        Yt.transition = r,
        pe = e,
        !(pe & 6) && Xn()
    }
}
function cp() {
    Pt = bi.current,
    Pe(bi)
}
function Ts(t, e) {
    t.finishedWork = null,
    t.finishedLanes = 0;
    var r = t.timeoutHandle;
    if (r !== -1 && (t.timeoutHandle = -1,
    dk(r)),
    qe !== null)
        for (r = qe.return; r !== null; ) {
            var n = r;
            switch (Vf(n),
            n.tag) {
            case 1:
                n = n.type.childContextTypes,
                n != null && sc();
                break;
            case 3:
                eo(),
                Pe(Ct),
                Pe(ht),
                Yf();
                break;
            case 5:
                Zf(n);
                break;
            case 4:
                eo();
                break;
            case 13:
                Pe(Le);
                break;
            case 19:
                Pe(Le);
                break;
            case 10:
                qf(n.type._context);
                break;
            case 22:
            case 23:
                cp()
            }
            r = r.return
        }
    if (Xe = t,
    qe = t = Fn(t.current, null),
    it = Pt = e,
    Je = 0,
    ga = null,
    op = Qc = js = 0,
    kt = Qo = null,
    ms !== null) {
        for (e = 0; e < ms.length; e++)
            if (r = ms[e],
            n = r.interleaved,
            n !== null) {
                r.interleaved = null;
                var s = n.next
                  , i = r.pending;
                if (i !== null) {
                    var o = i.next;
                    i.next = s,
                    n.next = o
                }
                r.pending = n
            }
        ms = null
    }
    return t
}
function cw(t, e) {
    do {
        var r = qe;
        try {
            if (Kf(),
            Dl.current = fc,
            hc) {
                for (var n = $e.memoizedState; n !== null; ) {
                    var s = n.queue;
                    s !== null && (s.pending = null),
                    n = n.next
                }
                hc = !1
            }
            if (As = 0,
            Ze = Qe = $e = null,
            qo = !1,
            fa = 0,
            ip.current = null,
            r === null || r.return === null) {
                Je = 1,
                ga = e,
                qe = null;
                break
            }
            e: {
                var i = t
                  , o = r.return
                  , a = r
                  , l = e;
                if (e = it,
                a.flags |= 32768,
                l !== null && typeof l == "object" && typeof l.then == "function") {
                    var c = l
                      , u = a
                      , h = u.tag;
                    if (!(u.mode & 1) && (h === 0 || h === 11 || h === 15)) {
                        var p = u.alternate;
                        p ? (u.updateQueue = p.updateQueue,
                        u.memoizedState = p.memoizedState,
                        u.lanes = p.lanes) : (u.updateQueue = null,
                        u.memoizedState = null)
                    }
                    var f = Qm(o);
                    if (f !== null) {
                        f.flags &= -257,
                        Jm(f, o, a, i, e),
                        f.mode & 1 && Gm(i, c, e),
                        e = f,
                        l = c;
                        var b = e.updateQueue;
                        if (b === null) {
                            var m = new Set;
                            m.add(l),
                            e.updateQueue = m
                        } else
                            b.add(l);
                        break e
                    } else {
                        if (!(e & 1)) {
                            Gm(i, c, e),
                            up();
                            break e
                        }
                        l = Error(O(426))
                    }
                } else if (Oe && a.mode & 1) {
                    var x = Qm(o);
                    if (x !== null) {
                        !(x.flags & 65536) && (x.flags |= 256),
                        Jm(x, o, a, i, e),
                        Wf(to(l, a));
                        break e
                    }
                }
                i = l = to(l, a),
                Je !== 4 && (Je = 2),
                Qo === null ? Qo = [i] : Qo.push(i),
                i = o;
                do {
                    switch (i.tag) {
                    case 3:
                        i.flags |= 65536,
                        e &= -e,
                        i.lanes |= e;
                        var w = K0(i, l, e);
                        zm(i, w);
                        break e;
                    case 1:
                        a = l;
                        var g = i.type
                          , v = i.stateNode;
                        if (!(i.flags & 128) && (typeof g.getDerivedStateFromError == "function" || v !== null && typeof v.componentDidCatch == "function" && (Dn === null || !Dn.has(v)))) {
                            i.flags |= 65536,
                            e &= -e,
                            i.lanes |= e;
                            var _ = q0(i, a, e);
                            zm(i, _);
                            break e
                        }
                    }
                    i = i.return
                } while (i !== null)
            }
            hw(r)
        } catch (S) {
            e = S,
            qe === r && r !== null && (qe = r = r.return);
            continue
        }
        break
    } while (!0)
}
function uw() {
    var t = pc.current;
    return pc.current = fc,
    t === null ? fc : t
}
function up() {
    (Je === 0 || Je === 3 || Je === 2) && (Je = 4),
    Xe === null || !(js & 268435455) && !(Qc & 268435455) || yn(Xe, it)
}
function vc(t, e) {
    var r = pe;
    pe |= 2;
    var n = uw();
    (Xe !== t || it !== e) && (Fr = null,
    Ts(t, e));
    do
        try {
            $k();
            break
        } catch (s) {
            cw(t, s)
        }
    while (!0);
    if (Kf(),
    pe = r,
    pc.current = n,
    qe !== null)
        throw Error(O(261));
    return Xe = null,
    it = 0,
    Je
}
function $k() {
    for (; qe !== null; )
        dw(qe)
}
function Dk() {
    for (; qe !== null && !l1(); )
        dw(qe)
}
function dw(t) {
    var e = pw(t.alternate, t, Pt);
    t.memoizedProps = t.pendingProps,
    e === null ? hw(t) : qe = e,
    ip.current = null
}
function hw(t) {
    var e = t;
    do {
        var r = e.alternate;
        if (t = e.return,
        e.flags & 32768) {
            if (r = Pk(r, e),
            r !== null) {
                r.flags &= 32767,
                qe = r;
                return
            }
            if (t !== null)
                t.flags |= 32768,
                t.subtreeFlags = 0,
                t.deletions = null;
            else {
                Je = 6,
                qe = null;
                return
            }
        } else if (r = Nk(r, e, Pt),
        r !== null) {
            qe = r;
            return
        }
        if (e = e.sibling,
        e !== null) {
            qe = e;
            return
        }
        qe = e = t
    } while (e !== null);
    Je === 0 && (Je = 5)
}
function us(t, e, r) {
    var n = _e
      , s = Yt.transition;
    try {
        Yt.transition = null,
        _e = 1,
        Mk(t, e, r, n)
    } finally {
        Yt.transition = s,
        _e = n
    }
    return null
}
function Mk(t, e, r, n) {
    do
        Pi();
    while (Nn !== null);
    if (pe & 6)
        throw Error(O(327));
    r = t.finishedWork;
    var s = t.finishedLanes;
    if (r === null)
        return null;
    if (t.finishedWork = null,
    t.finishedLanes = 0,
    r === t.current)
        throw Error(O(177));
    t.callbackNode = null,
    t.callbackPriority = 0;
    var i = r.lanes | r.childLanes;
    if (y1(t, i),
    t === Xe && (qe = Xe = null,
    it = 0),
    !(r.subtreeFlags & 2064) && !(r.flags & 2064) || pl || (pl = !0,
    mw(Yl, function() {
        return Pi(),
        null
    })),
    i = (r.flags & 15990) !== 0,
    r.subtreeFlags & 15990 || i) {
        i = Yt.transition,
        Yt.transition = null;
        var o = _e;
        _e = 1;
        var a = pe;
        pe |= 4,
        ip.current = null,
        jk(t, r),
        ow(r, t),
        sk(Jd),
        ec = !!Qd,
        Jd = Qd = null,
        t.current = r,
        Ok(r),
        c1(),
        pe = a,
        _e = o,
        Yt.transition = i
    } else
        t.current = r;
    if (pl && (pl = !1,
    Nn = t,
    gc = s),
    i = t.pendingLanes,
    i === 0 && (Dn = null),
    h1(r.stateNode),
    Rt(t, He()),
    e !== null)
        for (n = t.onRecoverableError,
        r = 0; r < e.length; r++)
            s = e[r],
            n(s.value, {
                componentStack: s.stack,
                digest: s.digest
            });
    if (mc)
        throw mc = !1,
        t = gh,
        gh = null,
        t;
    return gc & 1 && t.tag !== 0 && Pi(),
    i = t.pendingLanes,
    i & 1 ? t === vh ? Jo++ : (Jo = 0,
    vh = t) : Jo = 0,
    Xn(),
    null
}
function Pi() {
    if (Nn !== null) {
        var t = Ky(gc)
          , e = Yt.transition
          , r = _e;
        try {
            if (Yt.transition = null,
            _e = 16 > t ? 16 : t,
            Nn === null)
                var n = !1;
            else {
                if (t = Nn,
                Nn = null,
                gc = 0,
                pe & 6)
                    throw Error(O(331));
                var s = pe;
                for (pe |= 4,
                z = t.current; z !== null; ) {
                    var i = z
                      , o = i.child;
                    if (z.flags & 16) {
                        var a = i.deletions;
                        if (a !== null) {
                            for (var l = 0; l < a.length; l++) {
                                var c = a[l];
                                for (z = c; z !== null; ) {
                                    var u = z;
                                    switch (u.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Go(8, u, i)
                                    }
                                    var h = u.child;
                                    if (h !== null)
                                        h.return = u,
                                        z = h;
                                    else
                                        for (; z !== null; ) {
                                            u = z;
                                            var p = u.sibling
                                              , f = u.return;
                                            if (nw(u),
                                            u === c) {
                                                z = null;
                                                break
                                            }
                                            if (p !== null) {
                                                p.return = f,
                                                z = p;
                                                break
                                            }
                                            z = f
                                        }
                                }
                            }
                            var b = i.alternate;
                            if (b !== null) {
                                var m = b.child;
                                if (m !== null) {
                                    b.child = null;
                                    do {
                                        var x = m.sibling;
                                        m.sibling = null,
                                        m = x
                                    } while (m !== null)
                                }
                            }
                            z = i
                        }
                    }
                    if (i.subtreeFlags & 2064 && o !== null)
                        o.return = i,
                        z = o;
                    else
                        e: for (; z !== null; ) {
                            if (i = z,
                            i.flags & 2048)
                                switch (i.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    Go(9, i, i.return)
                                }
                            var w = i.sibling;
                            if (w !== null) {
                                w.return = i.return,
                                z = w;
                                break e
                            }
                            z = i.return
                        }
                }
                var g = t.current;
                for (z = g; z !== null; ) {
                    o = z;
                    var v = o.child;
                    if (o.subtreeFlags & 2064 && v !== null)
                        v.return = o,
                        z = v;
                    else
                        e: for (o = g; z !== null; ) {
                            if (a = z,
                            a.flags & 2048)
                                try {
                                    switch (a.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Gc(9, a)
                                    }
                                } catch (S) {
                                    Ve(a, a.return, S)
                                }
                            if (a === o) {
                                z = null;
                                break e
                            }
                            var _ = a.sibling;
                            if (_ !== null) {
                                _.return = a.return,
                                z = _;
                                break e
                            }
                            z = a.return
                        }
                }
                if (pe = s,
                Xn(),
                Ar && typeof Ar.onPostCommitFiberRoot == "function")
                    try {
                        Ar.onPostCommitFiberRoot(Uc, t)
                    } catch {}
                n = !0
            }
            return n
        } finally {
            _e = r,
            Yt.transition = e
        }
    }
    return !1
}
function cg(t, e, r) {
    e = to(r, e),
    e = K0(t, e, 1),
    t = $n(t, e, 1),
    e = vt(),
    t !== null && (Ma(t, 1, e),
    Rt(t, e))
}
function Ve(t, e, r) {
    if (t.tag === 3)
        cg(t, t, r);
    else
        for (; e !== null; ) {
            if (e.tag === 3) {
                cg(e, t, r);
                break
            } else if (e.tag === 1) {
                var n = e.stateNode;
                if (typeof e.type.getDerivedStateFromError == "function" || typeof n.componentDidCatch == "function" && (Dn === null || !Dn.has(n))) {
                    t = to(r, t),
                    t = q0(e, t, 1),
                    e = $n(e, t, 1),
                    t = vt(),
                    e !== null && (Ma(e, 1, t),
                    Rt(e, t));
                    break
                }
            }
            e = e.return
        }
}
function Fk(t, e, r) {
    var n = t.pingCache;
    n !== null && n.delete(e),
    e = vt(),
    t.pingedLanes |= t.suspendedLanes & r,
    Xe === t && (it & r) === r && (Je === 4 || Je === 3 && (it & 130023424) === it && 500 > He() - ap ? Ts(t, 0) : op |= r),
    Rt(t, e)
}
function fw(t, e) {
    e === 0 && (t.mode & 1 ? (e = sl,
    sl <<= 1,
    !(sl & 130023424) && (sl = 4194304)) : e = 1);
    var r = vt();
    t = Qr(t, e),
    t !== null && (Ma(t, e, r),
    Rt(t, r))
}
function Uk(t) {
    var e = t.memoizedState
      , r = 0;
    e !== null && (r = e.retryLane),
    fw(t, r)
}
function Bk(t, e) {
    var r = 0;
    switch (t.tag) {
    case 13:
        var n = t.stateNode
          , s = t.memoizedState;
        s !== null && (r = s.retryLane);
        break;
    case 19:
        n = t.stateNode;
        break;
    default:
        throw Error(O(314))
    }
    n !== null && n.delete(e),
    fw(t, r)
}
var pw;
pw = function(t, e, r) {
    if (t !== null)
        if (t.memoizedProps !== e.pendingProps || Ct.current)
            Et = !0;
        else {
            if (!(t.lanes & r) && !(e.flags & 128))
                return Et = !1,
                Rk(t, e, r);
            Et = !!(t.flags & 131072)
        }
    else
        Et = !1,
        Oe && e.flags & 1048576 && y0(e, ac, e.index);
    switch (e.lanes = 0,
    e.tag) {
    case 2:
        var n = e.type;
        Fl(t, e),
        t = e.pendingProps;
        var s = Zi(e, ht.current);
        Ni(e, r),
        s = ep(null, e, n, t, s, r);
        var i = tp();
        return e.flags |= 1,
        typeof s == "object" && s !== null && typeof s.render == "function" && s.$$typeof === void 0 ? (e.tag = 1,
        e.memoizedState = null,
        e.updateQueue = null,
        Tt(n) ? (i = !0,
        ic(e)) : i = !1,
        e.memoizedState = s.state !== null && s.state !== void 0 ? s.state : null,
        Qf(e),
        s.updater = qc,
        e.stateNode = s,
        s._reactInternals = e,
        ih(e, n, t, r),
        e = lh(null, e, n, !0, i, r)) : (e.tag = 0,
        Oe && i && zf(e),
        mt(null, e, s, r),
        e = e.child),
        e;
    case 16:
        n = e.elementType;
        e: {
            switch (Fl(t, e),
            t = e.pendingProps,
            s = n._init,
            n = s(n._payload),
            e.type = n,
            s = e.tag = Vk(n),
            t = ur(n, t),
            s) {
            case 0:
                e = ah(null, e, n, t, r);
                break e;
            case 1:
                e = Xm(null, e, n, t, r);
                break e;
            case 11:
                e = Zm(null, e, n, t, r);
                break e;
            case 14:
                e = Ym(null, e, n, ur(n.type, t), r);
                break e
            }
            throw Error(O(306, n, ""))
        }
        return e;
    case 0:
        return n = e.type,
        s = e.pendingProps,
        s = e.elementType === n ? s : ur(n, s),
        ah(t, e, n, s, r);
    case 1:
        return n = e.type,
        s = e.pendingProps,
        s = e.elementType === n ? s : ur(n, s),
        Xm(t, e, n, s, r);
    case 3:
        e: {
            if (Z0(e),
            t === null)
                throw Error(O(387));
            n = e.pendingProps,
            i = e.memoizedState,
            s = i.element,
            k0(t, e),
            uc(e, n, null, r);
            var o = e.memoizedState;
            if (n = o.element,
            i.isDehydrated)
                if (i = {
                    element: n,
                    isDehydrated: !1,
                    cache: o.cache,
                    pendingSuspenseBoundaries: o.pendingSuspenseBoundaries,
                    transitions: o.transitions
                },
                e.updateQueue.baseState = i,
                e.memoizedState = i,
                e.flags & 256) {
                    s = to(Error(O(423)), e),
                    e = eg(t, e, n, r, s);
                    break e
                } else if (n !== s) {
                    s = to(Error(O(424)), e),
                    e = eg(t, e, n, r, s);
                    break e
                } else
                    for ($t = Ln(e.stateNode.containerInfo.firstChild),
                    Dt = e,
                    Oe = !0,
                    gr = null,
                    r = _0(e, null, n, r),
                    e.child = r; r; )
                        r.flags = r.flags & -3 | 4096,
                        r = r.sibling;
            else {
                if (Yi(),
                n === s) {
                    e = Jr(t, e, r);
                    break e
                }
                mt(t, e, n, r)
            }
            e = e.child
        }
        return e;
    case 5:
        return E0(e),
        t === null && rh(e),
        n = e.type,
        s = e.pendingProps,
        i = t !== null ? t.memoizedProps : null,
        o = s.children,
        Zd(n, s) ? o = null : i !== null && Zd(n, i) && (e.flags |= 32),
        J0(t, e),
        mt(t, e, o, r),
        e.child;
    case 6:
        return t === null && rh(e),
        null;
    case 13:
        return Y0(t, e, r);
    case 4:
        return Jf(e, e.stateNode.containerInfo),
        n = e.pendingProps,
        t === null ? e.child = Xi(e, null, n, r) : mt(t, e, n, r),
        e.child;
    case 11:
        return n = e.type,
        s = e.pendingProps,
        s = e.elementType === n ? s : ur(n, s),
        Zm(t, e, n, s, r);
    case 7:
        return mt(t, e, e.pendingProps, r),
        e.child;
    case 8:
        return mt(t, e, e.pendingProps.children, r),
        e.child;
    case 12:
        return mt(t, e, e.pendingProps.children, r),
        e.child;
    case 10:
        e: {
            if (n = e.type._context,
            s = e.pendingProps,
            i = e.memoizedProps,
            o = s.value,
            Ee(lc, n._currentValue),
            n._currentValue = o,
            i !== null)
                if (wr(i.value, o)) {
                    if (i.children === s.children && !Ct.current) {
                        e = Jr(t, e, r);
                        break e
                    }
                } else
                    for (i = e.child,
                    i !== null && (i.return = e); i !== null; ) {
                        var a = i.dependencies;
                        if (a !== null) {
                            o = i.child;
                            for (var l = a.firstContext; l !== null; ) {
                                if (l.context === n) {
                                    if (i.tag === 1) {
                                        l = Kr(-1, r & -r),
                                        l.tag = 2;
                                        var c = i.updateQueue;
                                        if (c !== null) {
                                            c = c.shared;
                                            var u = c.pending;
                                            u === null ? l.next = l : (l.next = u.next,
                                            u.next = l),
                                            c.pending = l
                                        }
                                    }
                                    i.lanes |= r,
                                    l = i.alternate,
                                    l !== null && (l.lanes |= r),
                                    nh(i.return, r, e),
                                    a.lanes |= r;
                                    break
                                }
                                l = l.next
                            }
                        } else if (i.tag === 10)
                            o = i.type === e.type ? null : i.child;
                        else if (i.tag === 18) {
                            if (o = i.return,
                            o === null)
                                throw Error(O(341));
                            o.lanes |= r,
                            a = o.alternate,
                            a !== null && (a.lanes |= r),
                            nh(o, r, e),
                            o = i.sibling
                        } else
                            o = i.child;
                        if (o !== null)
                            o.return = i;
                        else
                            for (o = i; o !== null; ) {
                                if (o === e) {
                                    o = null;
                                    break
                                }
                                if (i = o.sibling,
                                i !== null) {
                                    i.return = o.return,
                                    o = i;
                                    break
                                }
                                o = o.return
                            }
                        i = o
                    }
            mt(t, e, s.children, r),
            e = e.child
        }
        return e;
    case 9:
        return s = e.type,
        n = e.pendingProps.children,
        Ni(e, r),
        s = Xt(s),
        n = n(s),
        e.flags |= 1,
        mt(t, e, n, r),
        e.child;
    case 14:
        return n = e.type,
        s = ur(n, e.pendingProps),
        s = ur(n.type, s),
        Ym(t, e, n, s, r);
    case 15:
        return G0(t, e, e.type, e.pendingProps, r);
    case 17:
        return n = e.type,
        s = e.pendingProps,
        s = e.elementType === n ? s : ur(n, s),
        Fl(t, e),
        e.tag = 1,
        Tt(n) ? (t = !0,
        ic(e)) : t = !1,
        Ni(e, r),
        H0(e, n, s),
        ih(e, n, s, r),
        lh(null, e, n, !0, t, r);
    case 19:
        return X0(t, e, r);
    case 22:
        return Q0(t, e, r)
    }
    throw Error(O(156, e.tag))
}
;
function mw(t, e) {
    return zy(t, e)
}
function zk(t, e, r, n) {
    this.tag = t,
    this.key = r,
    this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null,
    this.index = 0,
    this.ref = null,
    this.pendingProps = e,
    this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null,
    this.mode = n,
    this.subtreeFlags = this.flags = 0,
    this.deletions = null,
    this.childLanes = this.lanes = 0,
    this.alternate = null
}
function Qt(t, e, r, n) {
    return new zk(t,e,r,n)
}
function dp(t) {
    return t = t.prototype,
    !(!t || !t.isReactComponent)
}
function Vk(t) {
    if (typeof t == "function")
        return dp(t) ? 1 : 0;
    if (t != null) {
        if (t = t.$$typeof,
        t === Pf)
            return 11;
        if (t === Af)
            return 14
    }
    return 2
}
function Fn(t, e) {
    var r = t.alternate;
    return r === null ? (r = Qt(t.tag, e, t.key, t.mode),
    r.elementType = t.elementType,
    r.type = t.type,
    r.stateNode = t.stateNode,
    r.alternate = t,
    t.alternate = r) : (r.pendingProps = e,
    r.type = t.type,
    r.flags = 0,
    r.subtreeFlags = 0,
    r.deletions = null),
    r.flags = t.flags & 14680064,
    r.childLanes = t.childLanes,
    r.lanes = t.lanes,
    r.child = t.child,
    r.memoizedProps = t.memoizedProps,
    r.memoizedState = t.memoizedState,
    r.updateQueue = t.updateQueue,
    e = t.dependencies,
    r.dependencies = e === null ? null : {
        lanes: e.lanes,
        firstContext: e.firstContext
    },
    r.sibling = t.sibling,
    r.index = t.index,
    r.ref = t.ref,
    r
}
function zl(t, e, r, n, s, i) {
    var o = 2;
    if (n = t,
    typeof t == "function")
        dp(t) && (o = 1);
    else if (typeof t == "string")
        o = 5;
    else
        e: switch (t) {
        case di:
            return Rs(r.children, s, i, e);
        case Nf:
            o = 8,
            s |= 8;
            break;
        case Nd:
            return t = Qt(12, r, e, s | 2),
            t.elementType = Nd,
            t.lanes = i,
            t;
        case Pd:
            return t = Qt(13, r, e, s),
            t.elementType = Pd,
            t.lanes = i,
            t;
        case Ad:
            return t = Qt(19, r, e, s),
            t.elementType = Ad,
            t.lanes = i,
            t;
        case Ey:
            return Jc(r, s, i, e);
        default:
            if (typeof t == "object" && t !== null)
                switch (t.$$typeof) {
                case Sy:
                    o = 10;
                    break e;
                case ky:
                    o = 9;
                    break e;
                case Pf:
                    o = 11;
                    break e;
                case Af:
                    o = 14;
                    break e;
                case fn:
                    o = 16,
                    n = null;
                    break e
                }
            throw Error(O(130, t == null ? t : typeof t, ""))
        }
    return e = Qt(o, r, e, s),
    e.elementType = t,
    e.type = n,
    e.lanes = i,
    e
}
function Rs(t, e, r, n) {
    return t = Qt(7, t, n, e),
    t.lanes = r,
    t
}
function Jc(t, e, r, n) {
    return t = Qt(22, t, n, e),
    t.elementType = Ey,
    t.lanes = r,
    t.stateNode = {
        isHidden: !1
    },
    t
}
function Xu(t, e, r) {
    return t = Qt(6, t, null, e),
    t.lanes = r,
    t
}
function ed(t, e, r) {
    return e = Qt(4, t.children !== null ? t.children : [], t.key, e),
    e.lanes = r,
    e.stateNode = {
        containerInfo: t.containerInfo,
        pendingChildren: null,
        implementation: t.implementation
    },
    e
}
function Wk(t, e, r, n, s) {
    this.tag = e,
    this.containerInfo = t,
    this.finishedWork = this.pingCache = this.current = this.pendingChildren = null,
    this.timeoutHandle = -1,
    this.callbackNode = this.pendingContext = this.context = null,
    this.callbackPriority = 0,
    this.eventTimes = Iu(0),
    this.expirationTimes = Iu(-1),
    this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0,
    this.entanglements = Iu(0),
    this.identifierPrefix = n,
    this.onRecoverableError = s,
    this.mutableSourceEagerHydrationData = null
}
function hp(t, e, r, n, s, i, o, a, l) {
    return t = new Wk(t,e,r,a,l),
    e === 1 ? (e = 1,
    i === !0 && (e |= 8)) : e = 0,
    i = Qt(3, null, null, e),
    t.current = i,
    i.stateNode = t,
    i.memoizedState = {
        element: n,
        isDehydrated: r,
        cache: null,
        transitions: null,
        pendingSuspenseBoundaries: null
    },
    Qf(i),
    t
}
function Hk(t, e, r) {
    var n = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
    return {
        $$typeof: ui,
        key: n == null ? null : "" + n,
        children: t,
        containerInfo: e,
        implementation: r
    }
}
function gw(t) {
    if (!t)
        return Hn;
    t = t._reactInternals;
    e: {
        if (Us(t) !== t || t.tag !== 1)
            throw Error(O(170));
        var e = t;
        do {
            switch (e.tag) {
            case 3:
                e = e.stateNode.context;
                break e;
            case 1:
                if (Tt(e.type)) {
                    e = e.stateNode.__reactInternalMemoizedMergedChildContext;
                    break e
                }
            }
            e = e.return
        } while (e !== null);
        throw Error(O(171))
    }
    if (t.tag === 1) {
        var r = t.type;
        if (Tt(r))
            return g0(t, r, e)
    }
    return e
}
function vw(t, e, r, n, s, i, o, a, l) {
    return t = hp(r, n, !0, t, s, i, o, a, l),
    t.context = gw(null),
    r = t.current,
    n = vt(),
    s = Mn(r),
    i = Kr(n, s),
    i.callback = e ?? null,
    $n(r, i, s),
    t.current.lanes = s,
    Ma(t, s, n),
    Rt(t, n),
    t
}
function Zc(t, e, r, n) {
    var s = e.current
      , i = vt()
      , o = Mn(s);
    return r = gw(r),
    e.context === null ? e.context = r : e.pendingContext = r,
    e = Kr(i, o),
    e.payload = {
        element: t
    },
    n = n === void 0 ? null : n,
    n !== null && (e.callback = n),
    t = $n(s, e, o),
    t !== null && (yr(t, s, o, i),
    $l(t, s, o)),
    o
}
function yc(t) {
    if (t = t.current,
    !t.child)
        return null;
    switch (t.child.tag) {
    case 5:
        return t.child.stateNode;
    default:
        return t.child.stateNode
    }
}
function ug(t, e) {
    if (t = t.memoizedState,
    t !== null && t.dehydrated !== null) {
        var r = t.retryLane;
        t.retryLane = r !== 0 && r < e ? r : e
    }
}
function fp(t, e) {
    ug(t, e),
    (t = t.alternate) && ug(t, e)
}
function Kk() {
    return null
}
var yw = typeof reportError == "function" ? reportError : function(t) {
    console.error(t)
}
;
function pp(t) {
    this._internalRoot = t
}
Yc.prototype.render = pp.prototype.render = function(t) {
    var e = this._internalRoot;
    if (e === null)
        throw Error(O(409));
    Zc(t, e, null, null)
}
;
Yc.prototype.unmount = pp.prototype.unmount = function() {
    var t = this._internalRoot;
    if (t !== null) {
        this._internalRoot = null;
        var e = t.containerInfo;
        Os(function() {
            Zc(null, t, null, null)
        }),
        e[Gr] = null
    }
}
;
function Yc(t) {
    this._internalRoot = t
}
Yc.prototype.unstable_scheduleHydration = function(t) {
    if (t) {
        var e = Qy();
        t = {
            blockedOn: null,
            target: t,
            priority: e
        };
        for (var r = 0; r < vn.length && e !== 0 && e < vn[r].priority; r++)
            ;
        vn.splice(r, 0, t),
        r === 0 && Zy(t)
    }
}
;
function mp(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11)
}
function Xc(t) {
    return !(!t || t.nodeType !== 1 && t.nodeType !== 9 && t.nodeType !== 11 && (t.nodeType !== 8 || t.nodeValue !== " react-mount-point-unstable "))
}
function dg() {}
function qk(t, e, r, n, s) {
    if (s) {
        if (typeof n == "function") {
            var i = n;
            n = function() {
                var c = yc(o);
                i.call(c)
            }
        }
        var o = vw(e, n, t, 0, null, !1, !1, "", dg);
        return t._reactRootContainer = o,
        t[Gr] = o.current,
        la(t.nodeType === 8 ? t.parentNode : t),
        Os(),
        o
    }
    for (; s = t.lastChild; )
        t.removeChild(s);
    if (typeof n == "function") {
        var a = n;
        n = function() {
            var c = yc(l);
            a.call(c)
        }
    }
    var l = hp(t, 0, !1, null, null, !1, !1, "", dg);
    return t._reactRootContainer = l,
    t[Gr] = l.current,
    la(t.nodeType === 8 ? t.parentNode : t),
    Os(function() {
        Zc(e, l, r, n)
    }),
    l
}
function eu(t, e, r, n, s) {
    var i = r._reactRootContainer;
    if (i) {
        var o = i;
        if (typeof s == "function") {
            var a = s;
            s = function() {
                var l = yc(o);
                a.call(l)
            }
        }
        Zc(e, o, t, s)
    } else
        o = qk(r, e, t, s, n);
    return yc(o)
}
qy = function(t) {
    switch (t.tag) {
    case 3:
        var e = t.stateNode;
        if (e.current.memoizedState.isDehydrated) {
            var r = Lo(e.pendingLanes);
            r !== 0 && (If(e, r | 1),
            Rt(e, He()),
            !(pe & 6) && (ro = He() + 500,
            Xn()))
        }
        break;
    case 13:
        Os(function() {
            var n = Qr(t, 1);
            if (n !== null) {
                var s = vt();
                yr(n, t, 1, s)
            }
        }),
        fp(t, 1)
    }
}
;
Lf = function(t) {
    if (t.tag === 13) {
        var e = Qr(t, 134217728);
        if (e !== null) {
            var r = vt();
            yr(e, t, 134217728, r)
        }
        fp(t, 134217728)
    }
}
;
Gy = function(t) {
    if (t.tag === 13) {
        var e = Mn(t)
          , r = Qr(t, e);
        if (r !== null) {
            var n = vt();
            yr(r, t, e, n)
        }
        fp(t, e)
    }
}
;
Qy = function() {
    return _e
}
;
Jy = function(t, e) {
    var r = _e;
    try {
        return _e = t,
        e()
    } finally {
        _e = r
    }
}
;
Bd = function(t, e, r) {
    switch (e) {
    case "input":
        if (Id(t, r),
        e = r.name,
        r.type === "radio" && e != null) {
            for (r = t; r.parentNode; )
                r = r.parentNode;
            for (r = r.querySelectorAll("input[name=" + JSON.stringify("" + e) + '][type="radio"]'),
            e = 0; e < r.length; e++) {
                var n = r[e];
                if (n !== t && n.form === t.form) {
                    var s = Wc(n);
                    if (!s)
                        throw Error(O(90));
                    Ty(n),
                    Id(n, s)
                }
            }
        }
        break;
    case "textarea":
        Ny(t, r);
        break;
    case "select":
        e = r.value,
        e != null && Ei(t, !!r.multiple, e, !1)
    }
}
;
$y = lp;
Dy = Os;
var Gk = {
    usingClientEntryPoint: !1,
    Events: [Ua, mi, Wc, Iy, Ly, lp]
}
  , Po = {
    findFiberByHostInstance: ps,
    bundleType: 0,
    version: "18.3.1",
    rendererPackageName: "react-dom"
}
  , Qk = {
    bundleType: Po.bundleType,
    version: Po.version,
    rendererPackageName: Po.rendererPackageName,
    rendererConfig: Po.rendererConfig,
    overrideHookState: null,
    overrideHookStateDeletePath: null,
    overrideHookStateRenamePath: null,
    overrideProps: null,
    overridePropsDeletePath: null,
    overridePropsRenamePath: null,
    setErrorHandler: null,
    setSuspenseHandler: null,
    scheduleUpdate: null,
    currentDispatcherRef: en.ReactCurrentDispatcher,
    findHostInstanceByFiber: function(t) {
        return t = Uy(t),
        t === null ? null : t.stateNode
    },
    findFiberByHostInstance: Po.findFiberByHostInstance || Kk,
    findHostInstancesForRefresh: null,
    scheduleRefresh: null,
    scheduleRoot: null,
    setRefreshHandler: null,
    getCurrentFiber: null,
    reconcilerVersion: "18.3.1-next-f1338f8080-20240426"
};
if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") {
    var ml = __REACT_DEVTOOLS_GLOBAL_HOOK__;
    if (!ml.isDisabled && ml.supportsFiber)
        try {
            Uc = ml.inject(Qk),
            Ar = ml
        } catch {}
}
Bt.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Gk;
Bt.createPortal = function(t, e) {
    var r = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null;
    if (!mp(e))
        throw Error(O(200));
    return Hk(t, e, null, r)
}
;
Bt.createRoot = function(t, e) {
    if (!mp(t))
        throw Error(O(299));
    var r = !1
      , n = ""
      , s = yw;
    return e != null && (e.unstable_strictMode === !0 && (r = !0),
    e.identifierPrefix !== void 0 && (n = e.identifierPrefix),
    e.onRecoverableError !== void 0 && (s = e.onRecoverableError)),
    e = hp(t, 1, !1, null, null, r, !1, n, s),
    t[Gr] = e.current,
    la(t.nodeType === 8 ? t.parentNode : t),
    new pp(e)
}
;
Bt.findDOMNode = function(t) {
    if (t == null)
        return null;
    if (t.nodeType === 1)
        return t;
    var e = t._reactInternals;
    if (e === void 0)
        throw typeof t.render == "function" ? Error(O(188)) : (t = Object.keys(t).join(","),
        Error(O(268, t)));
    return t = Uy(e),
    t = t === null ? null : t.stateNode,
    t
}
;
Bt.flushSync = function(t) {
    return Os(t)
}
;
Bt.hydrate = function(t, e, r) {
    if (!Xc(e))
        throw Error(O(200));
    return eu(null, t, e, !0, r)
}
;
Bt.hydrateRoot = function(t, e, r) {
    if (!mp(t))
        throw Error(O(405));
    var n = r != null && r.hydratedSources || null
      , s = !1
      , i = ""
      , o = yw;
    if (r != null && (r.unstable_strictMode === !0 && (s = !0),
    r.identifierPrefix !== void 0 && (i = r.identifierPrefix),
    r.onRecoverableError !== void 0 && (o = r.onRecoverableError)),
    e = vw(e, null, t, 1, r ?? null, s, !1, i, o),
    t[Gr] = e.current,
    la(t),
    n)
        for (t = 0; t < n.length; t++)
            r = n[t],
            s = r._getVersion,
            s = s(r._source),
            e.mutableSourceEagerHydrationData == null ? e.mutableSourceEagerHydrationData = [r, s] : e.mutableSourceEagerHydrationData.push(r, s);
    return new Yc(e)
}
;
Bt.render = function(t, e, r) {
    if (!Xc(e))
        throw Error(O(200));
    return eu(null, t, e, !1, r)
}
;
Bt.unmountComponentAtNode = function(t) {
    if (!Xc(t))
        throw Error(O(40));
    return t._reactRootContainer ? (Os(function() {
        eu(null, null, t, !1, function() {
            t._reactRootContainer = null,
            t[Gr] = null
        })
    }),
    !0) : !1
}
;
Bt.unstable_batchedUpdates = lp;
Bt.unstable_renderSubtreeIntoContainer = function(t, e, r, n) {
    if (!Xc(r))
        throw Error(O(200));
    if (t == null || t._reactInternals === void 0)
        throw Error(O(38));
    return eu(t, e, r, !1, n)
}
;
Bt.version = "18.3.1-next-f1338f8080-20240426";
function ww() {
    if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function"))
        try {
            __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(ww)
        } catch (t) {
            console.error(t)
        }
}
ww(),
wy.exports = Bt;
var Bs = wy.exports;
const xw = ay(Bs);
var bw, hg = Bs;
bw = hg.createRoot,
hg.hydrateRoot;
const Jk = 1
  , Zk = 1e6;
let td = 0;
function Yk() {
    return td = (td + 1) % Number.MAX_SAFE_INTEGER,
    td.toString()
}
const rd = new Map
  , fg = t => {
    if (rd.has(t))
        return;
    const e = setTimeout( () => {
        rd.delete(t),
        Zo({
            type: "REMOVE_TOAST",
            toastId: t
        })
    }
    , Zk);
    rd.set(t, e)
}
  , Xk = (t, e) => {
    switch (e.type) {
    case "ADD_TOAST":
        return {
            ...t,
            toasts: [e.toast, ...t.toasts].slice(0, Jk)
        };
    case "UPDATE_TOAST":
        return {
            ...t,
            toasts: t.toasts.map(r => r.id === e.toast.id ? {
                ...r,
                ...e.toast
            } : r)
        };
    case "DISMISS_TOAST":
        {
            const {toastId: r} = e;
            return r ? fg(r) : t.toasts.forEach(n => {
                fg(n.id)
            }
            ),
            {
                ...t,
                toasts: t.toasts.map(n => n.id === r || r === void 0 ? {
                    ...n,
                    open: !1
                } : n)
            }
        }
    case "REMOVE_TOAST":
        return e.toastId === void 0 ? {
            ...t,
            toasts: []
        } : {
            ...t,
            toasts: t.toasts.filter(r => r.id !== e.toastId)
        }
    }
}
  , Vl = [];
let Wl = {
    toasts: []
};
function Zo(t) {
    Wl = Xk(Wl, t),
    Vl.forEach(e => {
        e(Wl)
    }
    )
}
function eE({...t}) {
    const e = Yk()
      , r = s => Zo({
        type: "UPDATE_TOAST",
        toast: {
            ...s,
            id: e
        }
    })
      , n = () => Zo({
        type: "DISMISS_TOAST",
        toastId: e
    });
    return Zo({
        type: "ADD_TOAST",
        toast: {
            ...t,
            id: e,
            open: !0,
            onOpenChange: s => {
                s || n()
            }
        }
    }),
    {
        id: e,
        dismiss: n,
        update: r
    }
}
function tE() {
    const [t,e] = y.useState(Wl);
    return y.useEffect( () => (Vl.push(e),
    () => {
        const r = Vl.indexOf(e);
        r > -1 && Vl.splice(r, 1)
    }
    ), [t]),
    {
        ...t,
        toast: eE,
        dismiss: r => Zo({
            type: "DISMISS_TOAST",
            toastId: r
        })
    }
}
function te(t, e, {checkForDefaultPrevented: r=!0}={}) {
    return function(s) {
        if (t == null || t(s),
        r === !1 || !s.defaultPrevented)
            return e == null ? void 0 : e(s)
    }
}
function pg(t, e) {
    if (typeof t == "function")
        return t(e);
    t != null && (t.current = e)
}
function _w(...t) {
    return e => {
        let r = !1;
        const n = t.map(s => {
            const i = pg(s, e);
            return !r && typeof i == "function" && (r = !0),
            i
        }
        );
        if (r)
            return () => {
                for (let s = 0; s < n.length; s++) {
                    const i = n[s];
                    typeof i == "function" ? i() : pg(t[s], null)
                }
            }
    }
}
function Ae(...t) {
    return y.useCallback(_w(...t), t)
}
function tn(t, e=[]) {
    let r = [];
    function n(i, o) {
        const a = y.createContext(o)
          , l = r.length;
        r = [...r, o];
        const c = h => {
            var w;
            const {scope: p, children: f, ...b} = h
              , m = ((w = p == null ? void 0 : p[t]) == null ? void 0 : w[l]) || a
              , x = y.useMemo( () => b, Object.values(b));
            return d.jsx(m.Provider, {
                value: x,
                children: f
            })
        }
        ;
        c.displayName = i + "Provider";
        function u(h, p) {
            var m;
            const f = ((m = p == null ? void 0 : p[t]) == null ? void 0 : m[l]) || a
              , b = y.useContext(f);
            if (b)
                return b;
            if (o !== void 0)
                return o;
            throw new Error(`\`${h}\` must be used within \`${i}\``)
        }
        return [c, u]
    }
    const s = () => {
        const i = r.map(o => y.createContext(o));
        return function(a) {
            const l = (a == null ? void 0 : a[t]) || i;
            return y.useMemo( () => ({
                [`__scope${t}`]: {
                    ...a,
                    [t]: l
                }
            }), [a, l])
        }
    }
    ;
    return s.scopeName = t,
    [n, rE(s, ...e)]
}
function rE(...t) {
    const e = t[0];
    if (t.length === 1)
        return e;
    const r = () => {
        const n = t.map(s => ({
            useScope: s(),
            scopeName: s.scopeName
        }));
        return function(i) {
            const o = n.reduce( (a, {useScope: l, scopeName: c}) => {
                const h = l(i)[`__scope${c}`];
                return {
                    ...a,
                    ...h
                }
            }
            , {});
            return y.useMemo( () => ({
                [`__scope${e.scopeName}`]: o
            }), [o])
        }
    }
    ;
    return r.scopeName = e.scopeName,
    r
}
function va(t) {
    const e = sE(t)
      , r = y.forwardRef( (n, s) => {
        const {children: i, ...o} = n
          , a = y.Children.toArray(i)
          , l = a.find(oE);
        if (l) {
            const c = l.props.children
              , u = a.map(h => h === l ? y.Children.count(c) > 1 ? y.Children.only(null) : y.isValidElement(c) ? c.props.children : null : h);
            return d.jsx(e, {
                ...o,
                ref: s,
                children: y.isValidElement(c) ? y.cloneElement(c, void 0, u) : null
            })
        }
        return d.jsx(e, {
            ...o,
            ref: s,
            children: i
        })
    }
    );
    return r.displayName = `${t}.Slot`,
    r
}
var nE = va("Slot");
function sE(t) {
    const e = y.forwardRef( (r, n) => {
        const {children: s, ...i} = r;
        if (y.isValidElement(s)) {
            const o = lE(s)
              , a = aE(i, s.props);
            return s.type !== y.Fragment && (a.ref = n ? _w(n, o) : o),
            y.cloneElement(s, a)
        }
        return y.Children.count(s) > 1 ? y.Children.only(null) : null
    }
    );
    return e.displayName = `${t}.SlotClone`,
    e
}
var Sw = Symbol("radix.slottable");
function iE(t) {
    const e = ({children: r}) => d.jsx(d.Fragment, {
        children: r
    });
    return e.displayName = `${t}.Slottable`,
    e.__radixId = Sw,
    e
}
function oE(t) {
    return y.isValidElement(t) && typeof t.type == "function" && "__radixId"in t.type && t.type.__radixId === Sw
}
function aE(t, e) {
    const r = {
        ...e
    };
    for (const n in e) {
        const s = t[n]
          , i = e[n];
        /^on[A-Z]/.test(n) ? s && i ? r[n] = (...a) => {
            const l = i(...a);
            return s(...a),
            l
        }
        : s && (r[n] = s) : n === "style" ? r[n] = {
            ...s,
            ...i
        } : n === "className" && (r[n] = [s, i].filter(Boolean).join(" "))
    }
    return {
        ...t,
        ...r
    }
}
function lE(t) {
    var n, s;
    let e = (n = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : n.get
      , r = e && "isReactWarning"in e && e.isReactWarning;
    return r ? t.ref : (e = (s = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : s.get,
    r = e && "isReactWarning"in e && e.isReactWarning,
    r ? t.props.ref : t.props.ref || t.ref)
}
function tu(t) {
    const e = t + "CollectionProvider"
      , [r,n] = tn(e)
      , [s,i] = r(e, {
        collectionRef: {
            current: null
        },
        itemMap: new Map
    })
      , o = m => {
        const {scope: x, children: w} = m
          , g = j.useRef(null)
          , v = j.useRef(new Map).current;
        return d.jsx(s, {
            scope: x,
            itemMap: v,
            collectionRef: g,
            children: w
        })
    }
    ;
    o.displayName = e;
    const a = t + "CollectionSlot"
      , l = va(a)
      , c = j.forwardRef( (m, x) => {
        const {scope: w, children: g} = m
          , v = i(a, w)
          , _ = Ae(x, v.collectionRef);
        return d.jsx(l, {
            ref: _,
            children: g
        })
    }
    );
    c.displayName = a;
    const u = t + "CollectionItemSlot"
      , h = "data-radix-collection-item"
      , p = va(u)
      , f = j.forwardRef( (m, x) => {
        const {scope: w, children: g, ...v} = m
          , _ = j.useRef(null)
          , S = Ae(x, _)
          , k = i(u, w);
        return j.useEffect( () => (k.itemMap.set(_, {
            ref: _,
            ...v
        }),
        () => void k.itemMap.delete(_))),
        d.jsx(p, {
            [h]: "",
            ref: S,
            children: g
        })
    }
    );
    f.displayName = u;
    function b(m) {
        const x = i(t + "CollectionConsumer", m);
        return j.useCallback( () => {
            const g = x.collectionRef.current;
            if (!g)
                return [];
            const v = Array.from(g.querySelectorAll(`[${h}]`));
            return Array.from(x.itemMap.values()).sort( (k, C) => v.indexOf(k.ref.current) - v.indexOf(C.ref.current))
        }
        , [x.collectionRef, x.itemMap])
    }
    return [{
        Provider: o,
        Slot: c,
        ItemSlot: f
    }, b, n]
}
var cE = ["a", "button", "div", "form", "h2", "h3", "img", "input", "label", "li", "nav", "ol", "p", "select", "span", "svg", "ul"]
  , le = cE.reduce( (t, e) => {
    const r = va(`Primitive.${e}`)
      , n = y.forwardRef( (s, i) => {
        const {asChild: o, ...a} = s
          , l = o ? r : e;
        return typeof window < "u" && (window[Symbol.for("radix-ui")] = !0),
        d.jsx(l, {
            ...a,
            ref: i
        })
    }
    );
    return n.displayName = `Primitive.${e}`,
    {
        ...t,
        [e]: n
    }
}
, {});
function kw(t, e) {
    t && Bs.flushSync( () => t.dispatchEvent(e))
}
function tr(t) {
    const e = y.useRef(t);
    return y.useEffect( () => {
        e.current = t
    }
    ),
    y.useMemo( () => (...r) => {
        var n;
        return (n = e.current) == null ? void 0 : n.call(e, ...r)
    }
    , [])
}
function uE(t, e=globalThis == null ? void 0 : globalThis.document) {
    const r = tr(t);
    y.useEffect( () => {
        const n = s => {
            s.key === "Escape" && r(s)
        }
        ;
        return e.addEventListener("keydown", n, {
            capture: !0
        }),
        () => e.removeEventListener("keydown", n, {
            capture: !0
        })
    }
    , [r, e])
}
var dE = "DismissableLayer", xh = "dismissableLayer.update", hE = "dismissableLayer.pointerDownOutside", fE = "dismissableLayer.focusOutside", mg, Ew = y.createContext({
    layers: new Set,
    layersWithOutsidePointerEventsDisabled: new Set,
    branches: new Set
}), ru = y.forwardRef( (t, e) => {
    const {disableOutsidePointerEvents: r=!1, onEscapeKeyDown: n, onPointerDownOutside: s, onFocusOutside: i, onInteractOutside: o, onDismiss: a, ...l} = t
      , c = y.useContext(Ew)
      , [u,h] = y.useState(null)
      , p = (u == null ? void 0 : u.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document)
      , [,f] = y.useState({})
      , b = Ae(e, C => h(C))
      , m = Array.from(c.layers)
      , [x] = [...c.layersWithOutsidePointerEventsDisabled].slice(-1)
      , w = m.indexOf(x)
      , g = u ? m.indexOf(u) : -1
      , v = c.layersWithOutsidePointerEventsDisabled.size > 0
      , _ = g >= w
      , S = mE(C => {
        const T = C.target
          , A = [...c.branches].some(P => P.contains(T));
        !_ || A || (s == null || s(C),
        o == null || o(C),
        C.defaultPrevented || a == null || a())
    }
    , p)
      , k = gE(C => {
        const T = C.target;
        [...c.branches].some(P => P.contains(T)) || (i == null || i(C),
        o == null || o(C),
        C.defaultPrevented || a == null || a())
    }
    , p);
    return uE(C => {
        g === c.layers.size - 1 && (n == null || n(C),
        !C.defaultPrevented && a && (C.preventDefault(),
        a()))
    }
    , p),
    y.useEffect( () => {
        if (u)
            return r && (c.layersWithOutsidePointerEventsDisabled.size === 0 && (mg = p.body.style.pointerEvents,
            p.body.style.pointerEvents = "none"),
            c.layersWithOutsidePointerEventsDisabled.add(u)),
            c.layers.add(u),
            gg(),
            () => {
                r && c.layersWithOutsidePointerEventsDisabled.size === 1 && (p.body.style.pointerEvents = mg)
            }
    }
    , [u, p, r, c]),
    y.useEffect( () => () => {
        u && (c.layers.delete(u),
        c.layersWithOutsidePointerEventsDisabled.delete(u),
        gg())
    }
    , [u, c]),
    y.useEffect( () => {
        const C = () => f({});
        return document.addEventListener(xh, C),
        () => document.removeEventListener(xh, C)
    }
    , []),
    d.jsx(le.div, {
        ...l,
        ref: b,
        style: {
            pointerEvents: v ? _ ? "auto" : "none" : void 0,
            ...t.style
        },
        onFocusCapture: te(t.onFocusCapture, k.onFocusCapture),
        onBlurCapture: te(t.onBlurCapture, k.onBlurCapture),
        onPointerDownCapture: te(t.onPointerDownCapture, S.onPointerDownCapture)
    })
}
);
ru.displayName = dE;
var pE = "DismissableLayerBranch"
  , Cw = y.forwardRef( (t, e) => {
    const r = y.useContext(Ew)
      , n = y.useRef(null)
      , s = Ae(e, n);
    return y.useEffect( () => {
        const i = n.current;
        if (i)
            return r.branches.add(i),
            () => {
                r.branches.delete(i)
            }
    }
    , [r.branches]),
    d.jsx(le.div, {
        ...t,
        ref: s
    })
}
);
Cw.displayName = pE;
function mE(t, e=globalThis == null ? void 0 : globalThis.document) {
    const r = tr(t)
      , n = y.useRef(!1)
      , s = y.useRef( () => {}
    );
    return y.useEffect( () => {
        const i = a => {
            if (a.target && !n.current) {
                let l = function() {
                    Tw(hE, r, c, {
                        discrete: !0
                    })
                };
                const c = {
                    originalEvent: a
                };
                a.pointerType === "touch" ? (e.removeEventListener("click", s.current),
                s.current = l,
                e.addEventListener("click", s.current, {
                    once: !0
                })) : l()
            } else
                e.removeEventListener("click", s.current);
            n.current = !1
        }
          , o = window.setTimeout( () => {
            e.addEventListener("pointerdown", i)
        }
        , 0);
        return () => {
            window.clearTimeout(o),
            e.removeEventListener("pointerdown", i),
            e.removeEventListener("click", s.current)
        }
    }
    , [e, r]),
    {
        onPointerDownCapture: () => n.current = !0
    }
}
function gE(t, e=globalThis == null ? void 0 : globalThis.document) {
    const r = tr(t)
      , n = y.useRef(!1);
    return y.useEffect( () => {
        const s = i => {
            i.target && !n.current && Tw(fE, r, {
                originalEvent: i
            }, {
                discrete: !1
            })
        }
        ;
        return e.addEventListener("focusin", s),
        () => e.removeEventListener("focusin", s)
    }
    , [e, r]),
    {
        onFocusCapture: () => n.current = !0,
        onBlurCapture: () => n.current = !1
    }
}
function gg() {
    const t = new CustomEvent(xh);
    document.dispatchEvent(t)
}
function Tw(t, e, r, {discrete: n}) {
    const s = r.originalEvent.target
      , i = new CustomEvent(t,{
        bubbles: !1,
        cancelable: !0,
        detail: r
    });
    e && s.addEventListener(t, e, {
        once: !0
    }),
    n ? kw(s, i) : s.dispatchEvent(i)
}
var vE = ru
  , yE = Cw
  , et = globalThis != null && globalThis.document ? y.useLayoutEffect : () => {}
  , wE = "Portal"
  , gp = y.forwardRef( (t, e) => {
    var a;
    const {container: r, ...n} = t
      , [s,i] = y.useState(!1);
    et( () => i(!0), []);
    const o = r || s && ((a = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : a.body);
    return o ? xw.createPortal(d.jsx(le.div, {
        ...n,
        ref: e
    }), o) : null
}
);
gp.displayName = wE;
function xE(t, e) {
    return y.useReducer( (r, n) => e[r][n] ?? r, t)
}
var za = t => {
    const {present: e, children: r} = t
      , n = bE(e)
      , s = typeof r == "function" ? r({
        present: n.isPresent
    }) : y.Children.only(r)
      , i = Ae(n.ref, _E(s));
    return typeof r == "function" || n.isPresent ? y.cloneElement(s, {
        ref: i
    }) : null
}
;
za.displayName = "Presence";
function bE(t) {
    const [e,r] = y.useState()
      , n = y.useRef(null)
      , s = y.useRef(t)
      , i = y.useRef("none")
      , o = t ? "mounted" : "unmounted"
      , [a,l] = xE(o, {
        mounted: {
            UNMOUNT: "unmounted",
            ANIMATION_OUT: "unmountSuspended"
        },
        unmountSuspended: {
            MOUNT: "mounted",
            ANIMATION_END: "unmounted"
        },
        unmounted: {
            MOUNT: "mounted"
        }
    });
    return y.useEffect( () => {
        const c = gl(n.current);
        i.current = a === "mounted" ? c : "none"
    }
    , [a]),
    et( () => {
        const c = n.current
          , u = s.current;
        if (u !== t) {
            const p = i.current
              , f = gl(c);
            t ? l("MOUNT") : f === "none" || (c == null ? void 0 : c.display) === "none" ? l("UNMOUNT") : l(u && p !== f ? "ANIMATION_OUT" : "UNMOUNT"),
            s.current = t
        }
    }
    , [t, l]),
    et( () => {
        if (e) {
            let c;
            const u = e.ownerDocument.defaultView ?? window
              , h = f => {
                const m = gl(n.current).includes(f.animationName);
                if (f.target === e && m && (l("ANIMATION_END"),
                !s.current)) {
                    const x = e.style.animationFillMode;
                    e.style.animationFillMode = "forwards",
                    c = u.setTimeout( () => {
                        e.style.animationFillMode === "forwards" && (e.style.animationFillMode = x)
                    }
                    )
                }
            }
              , p = f => {
                f.target === e && (i.current = gl(n.current))
            }
            ;
            return e.addEventListener("animationstart", p),
            e.addEventListener("animationcancel", h),
            e.addEventListener("animationend", h),
            () => {
                u.clearTimeout(c),
                e.removeEventListener("animationstart", p),
                e.removeEventListener("animationcancel", h),
                e.removeEventListener("animationend", h)
            }
        } else
            l("ANIMATION_END")
    }
    , [e, l]),
    {
        isPresent: ["mounted", "unmountSuspended"].includes(a),
        ref: y.useCallback(c => {
            n.current = c ? getComputedStyle(c) : null,
            r(c)
        }
        , [])
    }
}
function gl(t) {
    return (t == null ? void 0 : t.animationName) || "none"
}
function _E(t) {
    var n, s;
    let e = (n = Object.getOwnPropertyDescriptor(t.props, "ref")) == null ? void 0 : n.get
      , r = e && "isReactWarning"in e && e.isReactWarning;
    return r ? t.ref : (e = (s = Object.getOwnPropertyDescriptor(t, "ref")) == null ? void 0 : s.get,
    r = e && "isReactWarning"in e && e.isReactWarning,
    r ? t.props.ref : t.props.ref || t.ref)
}
var SE = Ef[" useInsertionEffect ".trim().toString()] || et;
function Kn({prop: t, defaultProp: e, onChange: r= () => {}
, caller: n}) {
    const [s,i,o] = kE({
        defaultProp: e,
        onChange: r
    })
      , a = t !== void 0
      , l = a ? t : s;
    {
        const u = y.useRef(t !== void 0);
        y.useEffect( () => {
            const h = u.current;
            h !== a && console.warn(`${n} is changing from ${h ? "controlled" : "uncontrolled"} to ${a ? "controlled" : "uncontrolled"}. Components should not switch from controlled to uncontrolled (or vice versa). Decide between using a controlled or uncontrolled value for the lifetime of the component.`),
            u.current = a
        }
        , [a, n])
    }
    const c = y.useCallback(u => {
        var h;
        if (a) {
            const p = EE(u) ? u(t) : u;
            p !== t && ((h = o.current) == null || h.call(o, p))
        } else
            i(u)
    }
    , [a, t, i, o]);
    return [l, c]
}
function kE({defaultProp: t, onChange: e}) {
    const [r,n] = y.useState(t)
      , s = y.useRef(r)
      , i = y.useRef(e);
    return SE( () => {
        i.current = e
    }
    , [e]),
    y.useEffect( () => {
        var o;
        s.current !== r && ((o = i.current) == null || o.call(i, r),
        s.current = r)
    }
    , [r, s]),
    [r, n, i]
}
function EE(t) {
    return typeof t == "function"
}
var Rw = Object.freeze({
    position: "absolute",
    border: 0,
    width: 1,
    height: 1,
    padding: 0,
    margin: -1,
    overflow: "hidden",
    clip: "rect(0, 0, 0, 0)",
    whiteSpace: "nowrap",
    wordWrap: "normal"
})
  , CE = "VisuallyHidden"
  , nu = y.forwardRef( (t, e) => d.jsx(le.span, {
    ...t,
    ref: e,
    style: {
        ...Rw,
        ...t.style
    }
}));
nu.displayName = CE;
var TE = nu
  , vp = "ToastProvider"
  , [yp,RE,NE] = tu("Toast")
  , [Nw,AL] = tn("Toast", [NE])
  , [PE,su] = Nw(vp)
  , Pw = t => {
    const {__scopeToast: e, label: r="Notification", duration: n=5e3, swipeDirection: s="right", swipeThreshold: i=50, children: o} = t
      , [a,l] = y.useState(null)
      , [c,u] = y.useState(0)
      , h = y.useRef(!1)
      , p = y.useRef(!1);
    return r.trim() || console.error(`Invalid prop \`label\` supplied to \`${vp}\`. Expected non-empty \`string\`.`),
    d.jsx(yp.Provider, {
        scope: e,
        children: d.jsx(PE, {
            scope: e,
            label: r,
            duration: n,
            swipeDirection: s,
            swipeThreshold: i,
            toastCount: c,
            viewport: a,
            onViewportChange: l,
            onToastAdd: y.useCallback( () => u(f => f + 1), []),
            onToastRemove: y.useCallback( () => u(f => f - 1), []),
            isFocusedToastEscapeKeyDownRef: h,
            isClosePausedRef: p,
            children: o
        })
    })
}
;
Pw.displayName = vp;
var Aw = "ToastViewport"
  , AE = ["F8"]
  , bh = "toast.viewportPause"
  , _h = "toast.viewportResume"
  , jw = y.forwardRef( (t, e) => {
    const {__scopeToast: r, hotkey: n=AE, label: s="Notifications ({hotkey})", ...i} = t
      , o = su(Aw, r)
      , a = RE(r)
      , l = y.useRef(null)
      , c = y.useRef(null)
      , u = y.useRef(null)
      , h = y.useRef(null)
      , p = Ae(e, h, o.onViewportChange)
      , f = n.join("+").replace(/Key/g, "").replace(/Digit/g, "")
      , b = o.toastCount > 0;
    y.useEffect( () => {
        const x = w => {
            var v;
            n.length !== 0 && n.every(_ => w[_] || w.code === _) && ((v = h.current) == null || v.focus())
        }
        ;
        return document.addEventListener("keydown", x),
        () => document.removeEventListener("keydown", x)
    }
    , [n]),
    y.useEffect( () => {
        const x = l.current
          , w = h.current;
        if (b && x && w) {
            const g = () => {
                if (!o.isClosePausedRef.current) {
                    const k = new CustomEvent(bh);
                    w.dispatchEvent(k),
                    o.isClosePausedRef.current = !0
                }
            }
              , v = () => {
                if (o.isClosePausedRef.current) {
                    const k = new CustomEvent(_h);
                    w.dispatchEvent(k),
                    o.isClosePausedRef.current = !1
                }
            }
              , _ = k => {
                !x.contains(k.relatedTarget) && v()
            }
              , S = () => {
                x.contains(document.activeElement) || v()
            }
            ;
            return x.addEventListener("focusin", g),
            x.addEventListener("focusout", _),
            x.addEventListener("pointermove", g),
            x.addEventListener("pointerleave", S),
            window.addEventListener("blur", g),
            window.addEventListener("focus", v),
            () => {
                x.removeEventListener("focusin", g),
                x.removeEventListener("focusout", _),
                x.removeEventListener("pointermove", g),
                x.removeEventListener("pointerleave", S),
                window.removeEventListener("blur", g),
                window.removeEventListener("focus", v)
            }
        }
    }
    , [b, o.isClosePausedRef]);
    const m = y.useCallback( ({tabbingDirection: x}) => {
        const g = a().map(v => {
            const _ = v.ref.current
              , S = [_, ...WE(_)];
            return x === "forwards" ? S : S.reverse()
        }
        );
        return (x === "forwards" ? g.reverse() : g).flat()
    }
    , [a]);
    return y.useEffect( () => {
        const x = h.current;
        if (x) {
            const w = g => {
                var S, k, C;
                const v = g.altKey || g.ctrlKey || g.metaKey;
                if (g.key === "Tab" && !v) {
                    const T = document.activeElement
                      , A = g.shiftKey;
                    if (g.target === x && A) {
                        (S = c.current) == null || S.focus();
                        return
                    }
                    const L = m({
                        tabbingDirection: A ? "backwards" : "forwards"
                    })
                      , G = L.findIndex($ => $ === T);
                    nd(L.slice(G + 1)) ? g.preventDefault() : A ? (k = c.current) == null || k.focus() : (C = u.current) == null || C.focus()
                }
            }
            ;
            return x.addEventListener("keydown", w),
            () => x.removeEventListener("keydown", w)
        }
    }
    , [a, m]),
    d.jsxs(yE, {
        ref: l,
        role: "region",
        "aria-label": s.replace("{hotkey}", f),
        tabIndex: -1,
        style: {
            pointerEvents: b ? void 0 : "none"
        },
        children: [b && d.jsx(Sh, {
            ref: c,
            onFocusFromOutsideViewport: () => {
                const x = m({
                    tabbingDirection: "forwards"
                });
                nd(x)
            }
        }), d.jsx(yp.Slot, {
            scope: r,
            children: d.jsx(le.ol, {
                tabIndex: -1,
                ...i,
                ref: p
            })
        }), b && d.jsx(Sh, {
            ref: u,
            onFocusFromOutsideViewport: () => {
                const x = m({
                    tabbingDirection: "backwards"
                });
                nd(x)
            }
        })]
    })
}
);
jw.displayName = Aw;
var Ow = "ToastFocusProxy"
  , Sh = y.forwardRef( (t, e) => {
    const {__scopeToast: r, onFocusFromOutsideViewport: n, ...s} = t
      , i = su(Ow, r);
    return d.jsx(nu, {
        "aria-hidden": !0,
        tabIndex: 0,
        ...s,
        ref: e,
        style: {
            position: "fixed"
        },
        onFocus: o => {
            var c;
            const a = o.relatedTarget;
            !((c = i.viewport) != null && c.contains(a)) && n()
        }
    })
}
);
Sh.displayName = Ow;
var Va = "Toast"
  , jE = "toast.swipeStart"
  , OE = "toast.swipeMove"
  , IE = "toast.swipeCancel"
  , LE = "toast.swipeEnd"
  , Iw = y.forwardRef( (t, e) => {
    const {forceMount: r, open: n, defaultOpen: s, onOpenChange: i, ...o} = t
      , [a,l] = Kn({
        prop: n,
        defaultProp: s ?? !0,
        onChange: i,
        caller: Va
    });
    return d.jsx(za, {
        present: r || a,
        children: d.jsx(ME, {
            open: a,
            ...o,
            ref: e,
            onClose: () => l(!1),
            onPause: tr(t.onPause),
            onResume: tr(t.onResume),
            onSwipeStart: te(t.onSwipeStart, c => {
                c.currentTarget.setAttribute("data-swipe", "start")
            }
            ),
            onSwipeMove: te(t.onSwipeMove, c => {
                const {x: u, y: h} = c.detail.delta;
                c.currentTarget.setAttribute("data-swipe", "move"),
                c.currentTarget.style.setProperty("--radix-toast-swipe-move-x", `${u}px`),
                c.currentTarget.style.setProperty("--radix-toast-swipe-move-y", `${h}px`)
            }
            ),
            onSwipeCancel: te(t.onSwipeCancel, c => {
                c.currentTarget.setAttribute("data-swipe", "cancel"),
                c.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"),
                c.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"),
                c.currentTarget.style.removeProperty("--radix-toast-swipe-end-x"),
                c.currentTarget.style.removeProperty("--radix-toast-swipe-end-y")
            }
            ),
            onSwipeEnd: te(t.onSwipeEnd, c => {
                const {x: u, y: h} = c.detail.delta;
                c.currentTarget.setAttribute("data-swipe", "end"),
                c.currentTarget.style.removeProperty("--radix-toast-swipe-move-x"),
                c.currentTarget.style.removeProperty("--radix-toast-swipe-move-y"),
                c.currentTarget.style.setProperty("--radix-toast-swipe-end-x", `${u}px`),
                c.currentTarget.style.setProperty("--radix-toast-swipe-end-y", `${h}px`),
                l(!1)
            }
            )
        })
    })
}
);
Iw.displayName = Va;
var [$E,DE] = Nw(Va, {
    onClose() {}
})
  , ME = y.forwardRef( (t, e) => {
    const {__scopeToast: r, type: n="foreground", duration: s, open: i, onClose: o, onEscapeKeyDown: a, onPause: l, onResume: c, onSwipeStart: u, onSwipeMove: h, onSwipeCancel: p, onSwipeEnd: f, ...b} = t
      , m = su(Va, r)
      , [x,w] = y.useState(null)
      , g = Ae(e, $ => w($))
      , v = y.useRef(null)
      , _ = y.useRef(null)
      , S = s || m.duration
      , k = y.useRef(0)
      , C = y.useRef(S)
      , T = y.useRef(0)
      , {onToastAdd: A, onToastRemove: P} = m
      , B = tr( () => {
        var Y;
        (x == null ? void 0 : x.contains(document.activeElement)) && ((Y = m.viewport) == null || Y.focus()),
        o()
    }
    )
      , L = y.useCallback($ => {
        !$ || $ === 1 / 0 || (window.clearTimeout(T.current),
        k.current = new Date().getTime(),
        T.current = window.setTimeout(B, $))
    }
    , [B]);
    y.useEffect( () => {
        const $ = m.viewport;
        if ($) {
            const Y = () => {
                L(C.current),
                c == null || c()
            }
              , U = () => {
                const Q = new Date().getTime() - k.current;
                C.current = C.current - Q,
                window.clearTimeout(T.current),
                l == null || l()
            }
            ;
            return $.addEventListener(bh, U),
            $.addEventListener(_h, Y),
            () => {
                $.removeEventListener(bh, U),
                $.removeEventListener(_h, Y)
            }
        }
    }
    , [m.viewport, S, l, c, L]),
    y.useEffect( () => {
        i && !m.isClosePausedRef.current && L(S)
    }
    , [i, S, m.isClosePausedRef, L]),
    y.useEffect( () => (A(),
    () => P()), [A, P]);
    const G = y.useMemo( () => x ? Bw(x) : null, [x]);
    return m.viewport ? d.jsxs(d.Fragment, {
        children: [G && d.jsx(FE, {
            __scopeToast: r,
            role: "status",
            "aria-live": n === "foreground" ? "assertive" : "polite",
            "aria-atomic": !0,
            children: G
        }), d.jsx($E, {
            scope: r,
            onClose: B,
            children: Bs.createPortal(d.jsx(yp.ItemSlot, {
                scope: r,
                children: d.jsx(vE, {
                    asChild: !0,
                    onEscapeKeyDown: te(a, () => {
                        m.isFocusedToastEscapeKeyDownRef.current || B(),
                        m.isFocusedToastEscapeKeyDownRef.current = !1
                    }
                    ),
                    children: d.jsx(le.li, {
                        role: "status",
                        "aria-live": "off",
                        "aria-atomic": !0,
                        tabIndex: 0,
                        "data-state": i ? "open" : "closed",
                        "data-swipe-direction": m.swipeDirection,
                        ...b,
                        ref: g,
                        style: {
                            userSelect: "none",
                            touchAction: "none",
                            ...t.style
                        },
                        onKeyDown: te(t.onKeyDown, $ => {
                            $.key === "Escape" && (a == null || a($.nativeEvent),
                            $.nativeEvent.defaultPrevented || (m.isFocusedToastEscapeKeyDownRef.current = !0,
                            B()))
                        }
                        ),
                        onPointerDown: te(t.onPointerDown, $ => {
                            $.button === 0 && (v.current = {
                                x: $.clientX,
                                y: $.clientY
                            })
                        }
                        ),
                        onPointerMove: te(t.onPointerMove, $ => {
                            if (!v.current)
                                return;
                            const Y = $.clientX - v.current.x
                              , U = $.clientY - v.current.y
                              , Q = !!_.current
                              , R = ["left", "right"].includes(m.swipeDirection)
                              , N = ["left", "up"].includes(m.swipeDirection) ? Math.min : Math.max
                              , D = R ? N(0, Y) : 0
                              , ee = R ? 0 : N(0, U)
                              , q = $.pointerType === "touch" ? 10 : 2
                              , oe = {
                                x: D,
                                y: ee
                            }
                              , se = {
                                originalEvent: $,
                                delta: oe
                            };
                            Q ? (_.current = oe,
                            vl(OE, h, se, {
                                discrete: !1
                            })) : vg(oe, m.swipeDirection, q) ? (_.current = oe,
                            vl(jE, u, se, {
                                discrete: !1
                            }),
                            $.target.setPointerCapture($.pointerId)) : (Math.abs(Y) > q || Math.abs(U) > q) && (v.current = null)
                        }
                        ),
                        onPointerUp: te(t.onPointerUp, $ => {
                            const Y = _.current
                              , U = $.target;
                            if (U.hasPointerCapture($.pointerId) && U.releasePointerCapture($.pointerId),
                            _.current = null,
                            v.current = null,
                            Y) {
                                const Q = $.currentTarget
                                  , R = {
                                    originalEvent: $,
                                    delta: Y
                                };
                                vg(Y, m.swipeDirection, m.swipeThreshold) ? vl(LE, f, R, {
                                    discrete: !0
                                }) : vl(IE, p, R, {
                                    discrete: !0
                                }),
                                Q.addEventListener("click", N => N.preventDefault(), {
                                    once: !0
                                })
                            }
                        }
                        )
                    })
                })
            }), m.viewport)
        })]
    }) : null
}
)
  , FE = t => {
    const {__scopeToast: e, children: r, ...n} = t
      , s = su(Va, e)
      , [i,o] = y.useState(!1)
      , [a,l] = y.useState(!1);
    return zE( () => o(!0)),
    y.useEffect( () => {
        const c = window.setTimeout( () => l(!0), 1e3);
        return () => window.clearTimeout(c)
    }
    , []),
    a ? null : d.jsx(gp, {
        asChild: !0,
        children: d.jsx(nu, {
            ...n,
            children: i && d.jsxs(d.Fragment, {
                children: [s.label, " ", r]
            })
        })
    })
}
  , UE = "ToastTitle"
  , Lw = y.forwardRef( (t, e) => {
    const {__scopeToast: r, ...n} = t;
    return d.jsx(le.div, {
        ...n,
        ref: e
    })
}
);
Lw.displayName = UE;
var BE = "ToastDescription"
  , $w = y.forwardRef( (t, e) => {
    const {__scopeToast: r, ...n} = t;
    return d.jsx(le.div, {
        ...n,
        ref: e
    })
}
);
$w.displayName = BE;
var Dw = "ToastAction"
  , Mw = y.forwardRef( (t, e) => {
    const {altText: r, ...n} = t;
    return r.trim() ? d.jsx(Uw, {
        altText: r,
        asChild: !0,
        children: d.jsx(wp, {
            ...n,
            ref: e
        })
    }) : (console.error(`Invalid prop \`altText\` supplied to \`${Dw}\`. Expected non-empty \`string\`.`),
    null)
}
);
Mw.displayName = Dw;
var Fw = "ToastClose"
  , wp = y.forwardRef( (t, e) => {
    const {__scopeToast: r, ...n} = t
      , s = DE(Fw, r);
    return d.jsx(Uw, {
        asChild: !0,
        children: d.jsx(le.button, {
            type: "button",
            ...n,
            ref: e,
            onClick: te(t.onClick, s.onClose)
        })
    })
}
);
wp.displayName = Fw;
var Uw = y.forwardRef( (t, e) => {
    const {__scopeToast: r, altText: n, ...s} = t;
    return d.jsx(le.div, {
        "data-radix-toast-announce-exclude": "",
        "data-radix-toast-announce-alt": n || void 0,
        ...s,
        ref: e
    })
}
);
function Bw(t) {
    const e = [];
    return Array.from(t.childNodes).forEach(n => {
        if (n.nodeType === n.TEXT_NODE && n.textContent && e.push(n.textContent),
        VE(n)) {
            const s = n.ariaHidden || n.hidden || n.style.display === "none"
              , i = n.dataset.radixToastAnnounceExclude === "";
            if (!s)
                if (i) {
                    const o = n.dataset.radixToastAnnounceAlt;
                    o && e.push(o)
                } else
                    e.push(...Bw(n))
        }
    }
    ),
    e
}
function vl(t, e, r, {discrete: n}) {
    const s = r.originalEvent.currentTarget
      , i = new CustomEvent(t,{
        bubbles: !0,
        cancelable: !0,
        detail: r
    });
    e && s.addEventListener(t, e, {
        once: !0
    }),
    n ? kw(s, i) : s.dispatchEvent(i)
}
var vg = (t, e, r=0) => {
    const n = Math.abs(t.x)
      , s = Math.abs(t.y)
      , i = n > s;
    return e === "left" || e === "right" ? i && n > r : !i && s > r
}
;
function zE(t= () => {}
) {
    const e = tr(t);
    et( () => {
        let r = 0
          , n = 0;
        return r = window.requestAnimationFrame( () => n = window.requestAnimationFrame(e)),
        () => {
            window.cancelAnimationFrame(r),
            window.cancelAnimationFrame(n)
        }
    }
    , [e])
}
function VE(t) {
    return t.nodeType === t.ELEMENT_NODE
}
function WE(t) {
    const e = []
      , r = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
        acceptNode: n => {
            const s = n.tagName === "INPUT" && n.type === "hidden";
            return n.disabled || n.hidden || s ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        }
    });
    for (; r.nextNode(); )
        e.push(r.currentNode);
    return e
}
function nd(t) {
    const e = document.activeElement;
    return t.some(r => r === e ? !0 : (r.focus(),
    document.activeElement !== e))
}
var HE = Pw
  , zw = jw
  , Vw = Iw
  , Ww = Lw
  , Hw = $w
  , Kw = Mw
  , qw = wp;
function Gw(t) {
    var e, r, n = "";
    if (typeof t == "string" || typeof t == "number")
        n += t;
    else if (typeof t == "object")
        if (Array.isArray(t)) {
            var s = t.length;
            for (e = 0; e < s; e++)
                t[e] && (r = Gw(t[e])) && (n && (n += " "),
                n += r)
        } else
            for (r in t)
                t[r] && (n && (n += " "),
                n += r);
    return n
}
function Qw() {
    for (var t, e, r = 0, n = "", s = arguments.length; r < s; r++)
        (t = arguments[r]) && (e = Gw(t)) && (n && (n += " "),
        n += e);
    return n
}
const yg = t => typeof t == "boolean" ? `${t}` : t === 0 ? "0" : t
  , wg = Qw
  , iu = (t, e) => r => {
    var n;
    if ((e == null ? void 0 : e.variants) == null)
        return wg(t, r == null ? void 0 : r.class, r == null ? void 0 : r.className);
    const {variants: s, defaultVariants: i} = e
      , o = Object.keys(s).map(c => {
        const u = r == null ? void 0 : r[c]
          , h = i == null ? void 0 : i[c];
        if (u === null)
            return null;
        const p = yg(u) || yg(h);
        return s[c][p]
    }
    )
      , a = r && Object.entries(r).reduce( (c, u) => {
        let[h,p] = u;
        return p === void 0 || (c[h] = p),
        c
    }
    , {})
      , l = e == null || (n = e.compoundVariants) === null || n === void 0 ? void 0 : n.reduce( (c, u) => {
        let {class: h, className: p, ...f} = u;
        return Object.entries(f).every(b => {
            let[m,x] = b;
            return Array.isArray(x) ? x.includes({
                ...i,
                ...a
            }[m]) : {
                ...i,
                ...a
            }[m] === x
        }
        ) ? [...c, h, p] : c
    }
    , []);
    return wg(t, o, l, r == null ? void 0 : r.class, r == null ? void 0 : r.className)
}
;
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const KE = t => t.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase()
  , Jw = (...t) => t.filter( (e, r, n) => !!e && e.trim() !== "" && n.indexOf(e) === r).join(" ").trim();
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var qE = {
    xmlns: "http://www.w3.org/2000/svg",
    width: 24,
    height: 24,
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: 2,
    strokeLinecap: "round",
    strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const GE = y.forwardRef( ({color: t="currentColor", size: e=24, strokeWidth: r=2, absoluteStrokeWidth: n, className: s="", children: i, iconNode: o, ...a}, l) => y.createElement("svg", {
    ref: l,
    ...qE,
    width: e,
    height: e,
    stroke: t,
    strokeWidth: n ? Number(r) * 24 / Number(e) : r,
    className: Jw("lucide", s),
    ...a
}, [...o.map( ([c,u]) => y.createElement(c, u)), ...Array.isArray(i) ? i : [i]]));
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ce = (t, e) => {
    const r = y.forwardRef( ({className: n, ...s}, i) => y.createElement(GE, {
        ref: i,
        iconNode: e,
        className: Jw(`lucide-${KE(t)}`, n),
        ...s
    }));
    return r.displayName = `${t}`,
    r
}
;
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Zw = Ce("Activity", [["path", {
    d: "M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2",
    key: "169zse"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Yw = Ce("ArrowLeft", [["path", {
    d: "m12 19-7-7 7-7",
    key: "1l729n"
}], ["path", {
    d: "M19 12H5",
    key: "x3x0zl"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const kh = Ce("Check", [["path", {
    d: "M20 6 9 17l-5-5",
    key: "1gmf2c"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const xp = Ce("ChevronDown", [["path", {
    d: "m6 9 6 6 6-6",
    key: "qrunsl"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const QE = Ce("ChevronUp", [["path", {
    d: "m18 15-6-6-6 6",
    key: "153udz"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const JE = Ce("CircleCheckBig", [["path", {
    d: "M21.801 10A10 10 0 1 1 17 3.335",
    key: "yps3ct"
}], ["path", {
    d: "m9 11 3 3L22 4",
    key: "1pflzl"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ZE = Ce("CircleX", [["circle", {
    cx: "12",
    cy: "12",
    r: "10",
    key: "1mglay"
}], ["path", {
    d: "m15 9-6 6",
    key: "1uzhvr"
}], ["path", {
    d: "m9 9 6 6",
    key: "z0biqf"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const YE = Ce("Code", [["polyline", {
    points: "16 18 22 12 16 6",
    key: "z7tu5w"
}], ["polyline", {
    points: "8 6 2 12 8 18",
    key: "1eg1df"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const XE = Ce("Copy", [["rect", {
    width: "14",
    height: "14",
    x: "8",
    y: "8",
    rx: "2",
    ry: "2",
    key: "17jyea"
}], ["path", {
    d: "M4 16c-1.1 0-2-.9-2-2V4c0-1.1.9-2 2-2h10c1.1 0 2 .9 2 2",
    key: "zix9uf"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const _i = Ce("Crown", [["path", {
    d: "M11.562 3.266a.5.5 0 0 1 .876 0L15.39 8.87a1 1 0 0 0 1.516.294L21.183 5.5a.5.5 0 0 1 .798.519l-2.834 10.246a1 1 0 0 1-.956.734H5.81a1 1 0 0 1-.957-.734L2.02 6.02a.5.5 0 0 1 .798-.519l4.276 3.664a1 1 0 0 0 1.516-.294z",
    key: "1vdc57"
}], ["path", {
    d: "M5 21h14",
    key: "11awu3"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const eC = Ce("ExternalLink", [["path", {
    d: "M15 3h6v6",
    key: "1q9fwt"
}], ["path", {
    d: "M10 14 21 3",
    key: "gplh6r"
}], ["path", {
    d: "M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6",
    key: "a6xqqp"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const tC = Ce("Gamepad2", [["line", {
    x1: "6",
    x2: "10",
    y1: "11",
    y2: "11",
    key: "1gktln"
}], ["line", {
    x1: "8",
    x2: "8",
    y1: "9",
    y2: "13",
    key: "qnk9ow"
}], ["line", {
    x1: "15",
    x2: "15.01",
    y1: "12",
    y2: "12",
    key: "krot7o"
}], ["line", {
    x1: "18",
    x2: "18.01",
    y1: "10",
    y2: "10",
    key: "1lcuu1"
}], ["path", {
    d: "M17.32 5H6.68a4 4 0 0 0-3.978 3.59c-.006.052-.01.101-.017.152C2.604 9.416 2 14.456 2 16a3 3 0 0 0 3 3c1 0 1.5-.5 2-1l1.414-1.414A2 2 0 0 1 9.828 16h4.344a2 2 0 0 1 1.414.586L17 18c.5.5 1 1 2 1a3 3 0 0 0 3-3c0-1.545-.604-6.584-.685-7.258-.007-.05-.011-.1-.017-.151A4 4 0 0 0 17.32 5z",
    key: "mfqc10"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const rC = Ce("Key", [["path", {
    d: "m15.5 7.5 2.3 2.3a1 1 0 0 0 1.4 0l2.1-2.1a1 1 0 0 0 0-1.4L19 4",
    key: "g0fldk"
}], ["path", {
    d: "m21 2-9.6 9.6",
    key: "1j0ho8"
}], ["circle", {
    cx: "7.5",
    cy: "15.5",
    r: "5.5",
    key: "yqb3hr"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const nC = Ce("ListChecks", [["path", {
    d: "m3 17 2 2 4-4",
    key: "1jhpwq"
}], ["path", {
    d: "m3 7 2 2 4-4",
    key: "1obspn"
}], ["path", {
    d: "M13 6h8",
    key: "15sg57"
}], ["path", {
    d: "M13 12h8",
    key: "h98zly"
}], ["path", {
    d: "M13 18h8",
    key: "oe0vm4"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Un = Ce("LoaderCircle", [["path", {
    d: "M21 12a9 9 0 1 1-6.219-8.56",
    key: "13zald"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const sC = Ce("LogOut", [["path", {
    d: "M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4",
    key: "1uf3rs"
}], ["polyline", {
    points: "16 17 21 12 16 7",
    key: "1gabdz"
}], ["line", {
    x1: "21",
    x2: "9",
    y1: "12",
    y2: "12",
    key: "1uyos4"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Do = Ce("MessageCircle", [["path", {
    d: "M7.9 20A9 9 0 1 0 4 16.1L2 22Z",
    key: "vv11sd"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const iC = Ce("Package", [["path", {
    d: "M11 21.73a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73z",
    key: "1a0edw"
}], ["path", {
    d: "M12 22V12",
    key: "d0xqtd"
}], ["path", {
    d: "m3.3 7 7.703 4.734a2 2 0 0 0 1.994 0L20.7 7",
    key: "yx3hmr"
}], ["path", {
    d: "m7.5 4.27 9 5.15",
    key: "1c824w"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const oC = Ce("RefreshCw", [["path", {
    d: "M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8",
    key: "v9h5vc"
}], ["path", {
    d: "M21 3v5h-5",
    key: "1q7to0"
}], ["path", {
    d: "M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16",
    key: "3uifl3"
}], ["path", {
    d: "M8 16H3v5",
    key: "1cv678"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const xg = Ce("Save", [["path", {
    d: "M15.2 3a2 2 0 0 1 1.4.6l3.8 3.8a2 2 0 0 1 .6 1.4V19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2z",
    key: "1c8476"
}], ["path", {
    d: "M17 21v-7a1 1 0 0 0-1-1H8a1 1 0 0 0-1 1v7",
    key: "1ydtos"
}], ["path", {
    d: "M7 3v4a1 1 0 0 0 1 1h7",
    key: "t51u73"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const aC = Ce("Server", [["rect", {
    width: "20",
    height: "8",
    x: "2",
    y: "2",
    rx: "2",
    ry: "2",
    key: "ngkwjq"
}], ["rect", {
    width: "20",
    height: "8",
    x: "2",
    y: "14",
    rx: "2",
    ry: "2",
    key: "iecqi9"
}], ["line", {
    x1: "6",
    x2: "6.01",
    y1: "6",
    y2: "6",
    key: "16zg32"
}], ["line", {
    x1: "6",
    x2: "6.01",
    y1: "18",
    y2: "18",
    key: "nzw8ys"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Ai = Ce("Shield", [["path", {
    d: "M20 13c0 5-3.5 7.5-7.66 8.95a1 1 0 0 1-.67-.01C7.5 20.5 4 18 4 13V6a1 1 0 0 1 1-1c2 0 4.5-1.2 6.24-2.72a1.17 1.17 0 0 1 1.52 0C14.51 3.81 17 5 19 5a1 1 0 0 1 1 1z",
    key: "oel41y"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Wa = Ce("Sparkles", [["path", {
    d: "M9.937 15.5A2 2 0 0 0 8.5 14.063l-6.135-1.582a.5.5 0 0 1 0-.962L8.5 9.936A2 2 0 0 0 9.937 8.5l1.582-6.135a.5.5 0 0 1 .963 0L14.063 8.5A2 2 0 0 0 15.5 9.937l6.135 1.581a.5.5 0 0 1 0 .964L15.5 14.063a2 2 0 0 0-1.437 1.437l-1.582 6.135a.5.5 0 0 1-.963 0z",
    key: "4pj2yx"
}], ["path", {
    d: "M20 3v4",
    key: "1olli1"
}], ["path", {
    d: "M22 5h-4",
    key: "1gvqau"
}], ["path", {
    d: "M4 17v2",
    key: "vumght"
}], ["path", {
    d: "M5 18H3",
    key: "zchphs"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const sd = Ce("Upload", [["path", {
    d: "M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4",
    key: "ih7n3h"
}], ["polyline", {
    points: "17 8 12 3 7 8",
    key: "t8dd8p"
}], ["line", {
    x1: "12",
    x2: "12",
    y1: "3",
    y2: "15",
    key: "widbto"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const lC = Ce("X", [["path", {
    d: "M18 6 6 18",
    key: "1bl5f8"
}], ["path", {
    d: "m6 6 12 12",
    key: "d8bk6v"
}]]);
/**
 * @license lucide-react v0.462.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const wc = Ce("Zap", [["path", {
    d: "M4 14a1 1 0 0 1-.78-1.63l9.9-10.2a.5.5 0 0 1 .86.46l-1.92 6.02A1 1 0 0 0 13 10h7a1 1 0 0 1 .78 1.63l-9.9 10.2a.5.5 0 0 1-.86-.46l1.92-6.02A1 1 0 0 0 11 14z",
    key: "1xq2db"
}]])
  , bp = "-"
  , cC = t => {
    const e = dC(t)
      , {conflictingClassGroups: r, conflictingClassGroupModifiers: n} = t;
    return {
        getClassGroupId: o => {
            const a = o.split(bp);
            return a[0] === "" && a.length !== 1 && a.shift(),
            Xw(a, e) || uC(o)
        }
        ,
        getConflictingClassGroupIds: (o, a) => {
            const l = r[o] || [];
            return a && n[o] ? [...l, ...n[o]] : l
        }
    }
}
  , Xw = (t, e) => {
    var o;
    if (t.length === 0)
        return e.classGroupId;
    const r = t[0]
      , n = e.nextPart.get(r)
      , s = n ? Xw(t.slice(1), n) : void 0;
    if (s)
        return s;
    if (e.validators.length === 0)
        return;
    const i = t.join(bp);
    return (o = e.validators.find( ({validator: a}) => a(i))) == null ? void 0 : o.classGroupId
}
  , bg = /^\[(.+)\]$/
  , uC = t => {
    if (bg.test(t)) {
        const e = bg.exec(t)[1]
          , r = e == null ? void 0 : e.substring(0, e.indexOf(":"));
        if (r)
            return "arbitrary.." + r
    }
}
  , dC = t => {
    const {theme: e, prefix: r} = t
      , n = {
        nextPart: new Map,
        validators: []
    };
    return fC(Object.entries(t.classGroups), r).forEach( ([i,o]) => {
        Eh(o, n, i, e)
    }
    ),
    n
}
  , Eh = (t, e, r, n) => {
    t.forEach(s => {
        if (typeof s == "string") {
            const i = s === "" ? e : _g(e, s);
            i.classGroupId = r;
            return
        }
        if (typeof s == "function") {
            if (hC(s)) {
                Eh(s(n), e, r, n);
                return
            }
            e.validators.push({
                validator: s,
                classGroupId: r
            });
            return
        }
        Object.entries(s).forEach( ([i,o]) => {
            Eh(o, _g(e, i), r, n)
        }
        )
    }
    )
}
  , _g = (t, e) => {
    let r = t;
    return e.split(bp).forEach(n => {
        r.nextPart.has(n) || r.nextPart.set(n, {
            nextPart: new Map,
            validators: []
        }),
        r = r.nextPart.get(n)
    }
    ),
    r
}
  , hC = t => t.isThemeGetter
  , fC = (t, e) => e ? t.map( ([r,n]) => {
    const s = n.map(i => typeof i == "string" ? e + i : typeof i == "object" ? Object.fromEntries(Object.entries(i).map( ([o,a]) => [e + o, a])) : i);
    return [r, s]
}
) : t
  , pC = t => {
    if (t < 1)
        return {
            get: () => {}
            ,
            set: () => {}
        };
    let e = 0
      , r = new Map
      , n = new Map;
    const s = (i, o) => {
        r.set(i, o),
        e++,
        e > t && (e = 0,
        n = r,
        r = new Map)
    }
    ;
    return {
        get(i) {
            let o = r.get(i);
            if (o !== void 0)
                return o;
            if ((o = n.get(i)) !== void 0)
                return s(i, o),
                o
        },
        set(i, o) {
            r.has(i) ? r.set(i, o) : s(i, o)
        }
    }
}
  , ex = "!"
  , mC = t => {
    const {separator: e, experimentalParseClassName: r} = t
      , n = e.length === 1
      , s = e[0]
      , i = e.length
      , o = a => {
        const l = [];
        let c = 0, u = 0, h;
        for (let x = 0; x < a.length; x++) {
            let w = a[x];
            if (c === 0) {
                if (w === s && (n || a.slice(x, x + i) === e)) {
                    l.push(a.slice(u, x)),
                    u = x + i;
                    continue
                }
                if (w === "/") {
                    h = x;
                    continue
                }
            }
            w === "[" ? c++ : w === "]" && c--
        }
        const p = l.length === 0 ? a : a.substring(u)
          , f = p.startsWith(ex)
          , b = f ? p.substring(1) : p
          , m = h && h > u ? h - u : void 0;
        return {
            modifiers: l,
            hasImportantModifier: f,
            baseClassName: b,
            maybePostfixModifierPosition: m
        }
    }
    ;
    return r ? a => r({
        className: a,
        parseClassName: o
    }) : o
}
  , gC = t => {
    if (t.length <= 1)
        return t;
    const e = [];
    let r = [];
    return t.forEach(n => {
        n[0] === "[" ? (e.push(...r.sort(), n),
        r = []) : r.push(n)
    }
    ),
    e.push(...r.sort()),
    e
}
  , vC = t => ({
    cache: pC(t.cacheSize),
    parseClassName: mC(t),
    ...cC(t)
})
  , yC = /\s+/
  , wC = (t, e) => {
    const {parseClassName: r, getClassGroupId: n, getConflictingClassGroupIds: s} = e
      , i = []
      , o = t.trim().split(yC);
    let a = "";
    for (let l = o.length - 1; l >= 0; l -= 1) {
        const c = o[l]
          , {modifiers: u, hasImportantModifier: h, baseClassName: p, maybePostfixModifierPosition: f} = r(c);
        let b = !!f
          , m = n(b ? p.substring(0, f) : p);
        if (!m) {
            if (!b) {
                a = c + (a.length > 0 ? " " + a : a);
                continue
            }
            if (m = n(p),
            !m) {
                a = c + (a.length > 0 ? " " + a : a);
                continue
            }
            b = !1
        }
        const x = gC(u).join(":")
          , w = h ? x + ex : x
          , g = w + m;
        if (i.includes(g))
            continue;
        i.push(g);
        const v = s(m, b);
        for (let _ = 0; _ < v.length; ++_) {
            const S = v[_];
            i.push(w + S)
        }
        a = c + (a.length > 0 ? " " + a : a)
    }
    return a
}
;
function xC() {
    let t = 0, e, r, n = "";
    for (; t < arguments.length; )
        (e = arguments[t++]) && (r = tx(e)) && (n && (n += " "),
        n += r);
    return n
}
const tx = t => {
    if (typeof t == "string")
        return t;
    let e, r = "";
    for (let n = 0; n < t.length; n++)
        t[n] && (e = tx(t[n])) && (r && (r += " "),
        r += e);
    return r
}
;
function bC(t, ...e) {
    let r, n, s, i = o;
    function o(l) {
        const c = e.reduce( (u, h) => h(u), t());
        return r = vC(c),
        n = r.cache.get,
        s = r.cache.set,
        i = a,
        a(l)
    }
    function a(l) {
        const c = n(l);
        if (c)
            return c;
        const u = wC(l, r);
        return s(l, u),
        u
    }
    return function() {
        return i(xC.apply(null, arguments))
    }
}
const Re = t => {
    const e = r => r[t] || [];
    return e.isThemeGetter = !0,
    e
}
  , rx = /^\[(?:([a-z-]+):)?(.+)\]$/i
  , _C = /^\d+\/\d+$/
  , SC = new Set(["px", "full", "screen"])
  , kC = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/
  , EC = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/
  , CC = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/
  , TC = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/
  , RC = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/
  , Dr = t => ji(t) || SC.has(t) || _C.test(t)
  , cn = t => mo(t, "length", $C)
  , ji = t => !!t && !Number.isNaN(Number(t))
  , id = t => mo(t, "number", ji)
  , Ao = t => !!t && Number.isInteger(Number(t))
  , NC = t => t.endsWith("%") && ji(t.slice(0, -1))
  , ae = t => rx.test(t)
  , un = t => kC.test(t)
  , PC = new Set(["length", "size", "percentage"])
  , AC = t => mo(t, PC, nx)
  , jC = t => mo(t, "position", nx)
  , OC = new Set(["image", "url"])
  , IC = t => mo(t, OC, MC)
  , LC = t => mo(t, "", DC)
  , jo = () => !0
  , mo = (t, e, r) => {
    const n = rx.exec(t);
    return n ? n[1] ? typeof e == "string" ? n[1] === e : e.has(n[1]) : r(n[2]) : !1
}
  , $C = t => EC.test(t) && !CC.test(t)
  , nx = () => !1
  , DC = t => TC.test(t)
  , MC = t => RC.test(t)
  , FC = () => {
    const t = Re("colors")
      , e = Re("spacing")
      , r = Re("blur")
      , n = Re("brightness")
      , s = Re("borderColor")
      , i = Re("borderRadius")
      , o = Re("borderSpacing")
      , a = Re("borderWidth")
      , l = Re("contrast")
      , c = Re("grayscale")
      , u = Re("hueRotate")
      , h = Re("invert")
      , p = Re("gap")
      , f = Re("gradientColorStops")
      , b = Re("gradientColorStopPositions")
      , m = Re("inset")
      , x = Re("margin")
      , w = Re("opacity")
      , g = Re("padding")
      , v = Re("saturate")
      , _ = Re("scale")
      , S = Re("sepia")
      , k = Re("skew")
      , C = Re("space")
      , T = Re("translate")
      , A = () => ["auto", "contain", "none"]
      , P = () => ["auto", "hidden", "clip", "visible", "scroll"]
      , B = () => ["auto", ae, e]
      , L = () => [ae, e]
      , G = () => ["", Dr, cn]
      , $ = () => ["auto", ji, ae]
      , Y = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"]
      , U = () => ["solid", "dashed", "dotted", "double", "none"]
      , Q = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"]
      , R = () => ["start", "end", "center", "between", "around", "evenly", "stretch"]
      , N = () => ["", "0", ae]
      , D = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"]
      , ee = () => [ji, ae];
    return {
        cacheSize: 500,
        separator: ":",
        theme: {
            colors: [jo],
            spacing: [Dr, cn],
            blur: ["none", "", un, ae],
            brightness: ee(),
            borderColor: [t],
            borderRadius: ["none", "", "full", un, ae],
            borderSpacing: L(),
            borderWidth: G(),
            contrast: ee(),
            grayscale: N(),
            hueRotate: ee(),
            invert: N(),
            gap: L(),
            gradientColorStops: [t],
            gradientColorStopPositions: [NC, cn],
            inset: B(),
            margin: B(),
            opacity: ee(),
            padding: L(),
            saturate: ee(),
            scale: ee(),
            sepia: N(),
            skew: ee(),
            space: L(),
            translate: L()
        },
        classGroups: {
            aspect: [{
                aspect: ["auto", "square", "video", ae]
            }],
            container: ["container"],
            columns: [{
                columns: [un]
            }],
            "break-after": [{
                "break-after": D()
            }],
            "break-before": [{
                "break-before": D()
            }],
            "break-inside": [{
                "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
            }],
            "box-decoration": [{
                "box-decoration": ["slice", "clone"]
            }],
            box: [{
                box: ["border", "content"]
            }],
            display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
            float: [{
                float: ["right", "left", "none", "start", "end"]
            }],
            clear: [{
                clear: ["left", "right", "both", "none", "start", "end"]
            }],
            isolation: ["isolate", "isolation-auto"],
            "object-fit": [{
                object: ["contain", "cover", "fill", "none", "scale-down"]
            }],
            "object-position": [{
                object: [...Y(), ae]
            }],
            overflow: [{
                overflow: P()
            }],
            "overflow-x": [{
                "overflow-x": P()
            }],
            "overflow-y": [{
                "overflow-y": P()
            }],
            overscroll: [{
                overscroll: A()
            }],
            "overscroll-x": [{
                "overscroll-x": A()
            }],
            "overscroll-y": [{
                "overscroll-y": A()
            }],
            position: ["static", "fixed", "absolute", "relative", "sticky"],
            inset: [{
                inset: [m]
            }],
            "inset-x": [{
                "inset-x": [m]
            }],
            "inset-y": [{
                "inset-y": [m]
            }],
            start: [{
                start: [m]
            }],
            end: [{
                end: [m]
            }],
            top: [{
                top: [m]
            }],
            right: [{
                right: [m]
            }],
            bottom: [{
                bottom: [m]
            }],
            left: [{
                left: [m]
            }],
            visibility: ["visible", "invisible", "collapse"],
            z: [{
                z: ["auto", Ao, ae]
            }],
            basis: [{
                basis: B()
            }],
            "flex-direction": [{
                flex: ["row", "row-reverse", "col", "col-reverse"]
            }],
            "flex-wrap": [{
                flex: ["wrap", "wrap-reverse", "nowrap"]
            }],
            flex: [{
                flex: ["1", "auto", "initial", "none", ae]
            }],
            grow: [{
                grow: N()
            }],
            shrink: [{
                shrink: N()
            }],
            order: [{
                order: ["first", "last", "none", Ao, ae]
            }],
            "grid-cols": [{
                "grid-cols": [jo]
            }],
            "col-start-end": [{
                col: ["auto", {
                    span: ["full", Ao, ae]
                }, ae]
            }],
            "col-start": [{
                "col-start": $()
            }],
            "col-end": [{
                "col-end": $()
            }],
            "grid-rows": [{
                "grid-rows": [jo]
            }],
            "row-start-end": [{
                row: ["auto", {
                    span: [Ao, ae]
                }, ae]
            }],
            "row-start": [{
                "row-start": $()
            }],
            "row-end": [{
                "row-end": $()
            }],
            "grid-flow": [{
                "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
            }],
            "auto-cols": [{
                "auto-cols": ["auto", "min", "max", "fr", ae]
            }],
            "auto-rows": [{
                "auto-rows": ["auto", "min", "max", "fr", ae]
            }],
            gap: [{
                gap: [p]
            }],
            "gap-x": [{
                "gap-x": [p]
            }],
            "gap-y": [{
                "gap-y": [p]
            }],
            "justify-content": [{
                justify: ["normal", ...R()]
            }],
            "justify-items": [{
                "justify-items": ["start", "end", "center", "stretch"]
            }],
            "justify-self": [{
                "justify-self": ["auto", "start", "end", "center", "stretch"]
            }],
            "align-content": [{
                content: ["normal", ...R(), "baseline"]
            }],
            "align-items": [{
                items: ["start", "end", "center", "baseline", "stretch"]
            }],
            "align-self": [{
                self: ["auto", "start", "end", "center", "stretch", "baseline"]
            }],
            "place-content": [{
                "place-content": [...R(), "baseline"]
            }],
            "place-items": [{
                "place-items": ["start", "end", "center", "baseline", "stretch"]
            }],
            "place-self": [{
                "place-self": ["auto", "start", "end", "center", "stretch"]
            }],
            p: [{
                p: [g]
            }],
            px: [{
                px: [g]
            }],
            py: [{
                py: [g]
            }],
            ps: [{
                ps: [g]
            }],
            pe: [{
                pe: [g]
            }],
            pt: [{
                pt: [g]
            }],
            pr: [{
                pr: [g]
            }],
            pb: [{
                pb: [g]
            }],
            pl: [{
                pl: [g]
            }],
            m: [{
                m: [x]
            }],
            mx: [{
                mx: [x]
            }],
            my: [{
                my: [x]
            }],
            ms: [{
                ms: [x]
            }],
            me: [{
                me: [x]
            }],
            mt: [{
                mt: [x]
            }],
            mr: [{
                mr: [x]
            }],
            mb: [{
                mb: [x]
            }],
            ml: [{
                ml: [x]
            }],
            "space-x": [{
                "space-x": [C]
            }],
            "space-x-reverse": ["space-x-reverse"],
            "space-y": [{
                "space-y": [C]
            }],
            "space-y-reverse": ["space-y-reverse"],
            w: [{
                w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", ae, e]
            }],
            "min-w": [{
                "min-w": [ae, e, "min", "max", "fit"]
            }],
            "max-w": [{
                "max-w": [ae, e, "none", "full", "min", "max", "fit", "prose", {
                    screen: [un]
                }, un]
            }],
            h: [{
                h: [ae, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
            }],
            "min-h": [{
                "min-h": [ae, e, "min", "max", "fit", "svh", "lvh", "dvh"]
            }],
            "max-h": [{
                "max-h": [ae, e, "min", "max", "fit", "svh", "lvh", "dvh"]
            }],
            size: [{
                size: [ae, e, "auto", "min", "max", "fit"]
            }],
            "font-size": [{
                text: ["base", un, cn]
            }],
            "font-smoothing": ["antialiased", "subpixel-antialiased"],
            "font-style": ["italic", "not-italic"],
            "font-weight": [{
                font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", id]
            }],
            "font-family": [{
                font: [jo]
            }],
            "fvn-normal": ["normal-nums"],
            "fvn-ordinal": ["ordinal"],
            "fvn-slashed-zero": ["slashed-zero"],
            "fvn-figure": ["lining-nums", "oldstyle-nums"],
            "fvn-spacing": ["proportional-nums", "tabular-nums"],
            "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
            tracking: [{
                tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", ae]
            }],
            "line-clamp": [{
                "line-clamp": ["none", ji, id]
            }],
            leading: [{
                leading: ["none", "tight", "snug", "normal", "relaxed", "loose", Dr, ae]
            }],
            "list-image": [{
                "list-image": ["none", ae]
            }],
            "list-style-type": [{
                list: ["none", "disc", "decimal", ae]
            }],
            "list-style-position": [{
                list: ["inside", "outside"]
            }],
            "placeholder-color": [{
                placeholder: [t]
            }],
            "placeholder-opacity": [{
                "placeholder-opacity": [w]
            }],
            "text-alignment": [{
                text: ["left", "center", "right", "justify", "start", "end"]
            }],
            "text-color": [{
                text: [t]
            }],
            "text-opacity": [{
                "text-opacity": [w]
            }],
            "text-decoration": ["underline", "overline", "line-through", "no-underline"],
            "text-decoration-style": [{
                decoration: [...U(), "wavy"]
            }],
            "text-decoration-thickness": [{
                decoration: ["auto", "from-font", Dr, cn]
            }],
            "underline-offset": [{
                "underline-offset": ["auto", Dr, ae]
            }],
            "text-decoration-color": [{
                decoration: [t]
            }],
            "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
            "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
            "text-wrap": [{
                text: ["wrap", "nowrap", "balance", "pretty"]
            }],
            indent: [{
                indent: L()
            }],
            "vertical-align": [{
                align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", ae]
            }],
            whitespace: [{
                whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
            }],
            break: [{
                break: ["normal", "words", "all", "keep"]
            }],
            hyphens: [{
                hyphens: ["none", "manual", "auto"]
            }],
            content: [{
                content: ["none", ae]
            }],
            "bg-attachment": [{
                bg: ["fixed", "local", "scroll"]
            }],
            "bg-clip": [{
                "bg-clip": ["border", "padding", "content", "text"]
            }],
            "bg-opacity": [{
                "bg-opacity": [w]
            }],
            "bg-origin": [{
                "bg-origin": ["border", "padding", "content"]
            }],
            "bg-position": [{
                bg: [...Y(), jC]
            }],
            "bg-repeat": [{
                bg: ["no-repeat", {
                    repeat: ["", "x", "y", "round", "space"]
                }]
            }],
            "bg-size": [{
                bg: ["auto", "cover", "contain", AC]
            }],
            "bg-image": [{
                bg: ["none", {
                    "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                }, IC]
            }],
            "bg-color": [{
                bg: [t]
            }],
            "gradient-from-pos": [{
                from: [b]
            }],
            "gradient-via-pos": [{
                via: [b]
            }],
            "gradient-to-pos": [{
                to: [b]
            }],
            "gradient-from": [{
                from: [f]
            }],
            "gradient-via": [{
                via: [f]
            }],
            "gradient-to": [{
                to: [f]
            }],
            rounded: [{
                rounded: [i]
            }],
            "rounded-s": [{
                "rounded-s": [i]
            }],
            "rounded-e": [{
                "rounded-e": [i]
            }],
            "rounded-t": [{
                "rounded-t": [i]
            }],
            "rounded-r": [{
                "rounded-r": [i]
            }],
            "rounded-b": [{
                "rounded-b": [i]
            }],
            "rounded-l": [{
                "rounded-l": [i]
            }],
            "rounded-ss": [{
                "rounded-ss": [i]
            }],
            "rounded-se": [{
                "rounded-se": [i]
            }],
            "rounded-ee": [{
                "rounded-ee": [i]
            }],
            "rounded-es": [{
                "rounded-es": [i]
            }],
            "rounded-tl": [{
                "rounded-tl": [i]
            }],
            "rounded-tr": [{
                "rounded-tr": [i]
            }],
            "rounded-br": [{
                "rounded-br": [i]
            }],
            "rounded-bl": [{
                "rounded-bl": [i]
            }],
            "border-w": [{
                border: [a]
            }],
            "border-w-x": [{
                "border-x": [a]
            }],
            "border-w-y": [{
                "border-y": [a]
            }],
            "border-w-s": [{
                "border-s": [a]
            }],
            "border-w-e": [{
                "border-e": [a]
            }],
            "border-w-t": [{
                "border-t": [a]
            }],
            "border-w-r": [{
                "border-r": [a]
            }],
            "border-w-b": [{
                "border-b": [a]
            }],
            "border-w-l": [{
                "border-l": [a]
            }],
            "border-opacity": [{
                "border-opacity": [w]
            }],
            "border-style": [{
                border: [...U(), "hidden"]
            }],
            "divide-x": [{
                "divide-x": [a]
            }],
            "divide-x-reverse": ["divide-x-reverse"],
            "divide-y": [{
                "divide-y": [a]
            }],
            "divide-y-reverse": ["divide-y-reverse"],
            "divide-opacity": [{
                "divide-opacity": [w]
            }],
            "divide-style": [{
                divide: U()
            }],
            "border-color": [{
                border: [s]
            }],
            "border-color-x": [{
                "border-x": [s]
            }],
            "border-color-y": [{
                "border-y": [s]
            }],
            "border-color-s": [{
                "border-s": [s]
            }],
            "border-color-e": [{
                "border-e": [s]
            }],
            "border-color-t": [{
                "border-t": [s]
            }],
            "border-color-r": [{
                "border-r": [s]
            }],
            "border-color-b": [{
                "border-b": [s]
            }],
            "border-color-l": [{
                "border-l": [s]
            }],
            "divide-color": [{
                divide: [s]
            }],
            "outline-style": [{
                outline: ["", ...U()]
            }],
            "outline-offset": [{
                "outline-offset": [Dr, ae]
            }],
            "outline-w": [{
                outline: [Dr, cn]
            }],
            "outline-color": [{
                outline: [t]
            }],
            "ring-w": [{
                ring: G()
            }],
            "ring-w-inset": ["ring-inset"],
            "ring-color": [{
                ring: [t]
            }],
            "ring-opacity": [{
                "ring-opacity": [w]
            }],
            "ring-offset-w": [{
                "ring-offset": [Dr, cn]
            }],
            "ring-offset-color": [{
                "ring-offset": [t]
            }],
            shadow: [{
                shadow: ["", "inner", "none", un, LC]
            }],
            "shadow-color": [{
                shadow: [jo]
            }],
            opacity: [{
                opacity: [w]
            }],
            "mix-blend": [{
                "mix-blend": [...Q(), "plus-lighter", "plus-darker"]
            }],
            "bg-blend": [{
                "bg-blend": Q()
            }],
            filter: [{
                filter: ["", "none"]
            }],
            blur: [{
                blur: [r]
            }],
            brightness: [{
                brightness: [n]
            }],
            contrast: [{
                contrast: [l]
            }],
            "drop-shadow": [{
                "drop-shadow": ["", "none", un, ae]
            }],
            grayscale: [{
                grayscale: [c]
            }],
            "hue-rotate": [{
                "hue-rotate": [u]
            }],
            invert: [{
                invert: [h]
            }],
            saturate: [{
                saturate: [v]
            }],
            sepia: [{
                sepia: [S]
            }],
            "backdrop-filter": [{
                "backdrop-filter": ["", "none"]
            }],
            "backdrop-blur": [{
                "backdrop-blur": [r]
            }],
            "backdrop-brightness": [{
                "backdrop-brightness": [n]
            }],
            "backdrop-contrast": [{
                "backdrop-contrast": [l]
            }],
            "backdrop-grayscale": [{
                "backdrop-grayscale": [c]
            }],
            "backdrop-hue-rotate": [{
                "backdrop-hue-rotate": [u]
            }],
            "backdrop-invert": [{
                "backdrop-invert": [h]
            }],
            "backdrop-opacity": [{
                "backdrop-opacity": [w]
            }],
            "backdrop-saturate": [{
                "backdrop-saturate": [v]
            }],
            "backdrop-sepia": [{
                "backdrop-sepia": [S]
            }],
            "border-collapse": [{
                border: ["collapse", "separate"]
            }],
            "border-spacing": [{
                "border-spacing": [o]
            }],
            "border-spacing-x": [{
                "border-spacing-x": [o]
            }],
            "border-spacing-y": [{
                "border-spacing-y": [o]
            }],
            "table-layout": [{
                table: ["auto", "fixed"]
            }],
            caption: [{
                caption: ["top", "bottom"]
            }],
            transition: [{
                transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", ae]
            }],
            duration: [{
                duration: ee()
            }],
            ease: [{
                ease: ["linear", "in", "out", "in-out", ae]
            }],
            delay: [{
                delay: ee()
            }],
            animate: [{
                animate: ["none", "spin", "ping", "pulse", "bounce", ae]
            }],
            transform: [{
                transform: ["", "gpu", "none"]
            }],
            scale: [{
                scale: [_]
            }],
            "scale-x": [{
                "scale-x": [_]
            }],
            "scale-y": [{
                "scale-y": [_]
            }],
            rotate: [{
                rotate: [Ao, ae]
            }],
            "translate-x": [{
                "translate-x": [T]
            }],
            "translate-y": [{
                "translate-y": [T]
            }],
            "skew-x": [{
                "skew-x": [k]
            }],
            "skew-y": [{
                "skew-y": [k]
            }],
            "transform-origin": [{
                origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", ae]
            }],
            accent: [{
                accent: ["auto", t]
            }],
            appearance: [{
                appearance: ["none", "auto"]
            }],
            cursor: [{
                cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", ae]
            }],
            "caret-color": [{
                caret: [t]
            }],
            "pointer-events": [{
                "pointer-events": ["none", "auto"]
            }],
            resize: [{
                resize: ["none", "y", "x", ""]
            }],
            "scroll-behavior": [{
                scroll: ["auto", "smooth"]
            }],
            "scroll-m": [{
                "scroll-m": L()
            }],
            "scroll-mx": [{
                "scroll-mx": L()
            }],
            "scroll-my": [{
                "scroll-my": L()
            }],
            "scroll-ms": [{
                "scroll-ms": L()
            }],
            "scroll-me": [{
                "scroll-me": L()
            }],
            "scroll-mt": [{
                "scroll-mt": L()
            }],
            "scroll-mr": [{
                "scroll-mr": L()
            }],
            "scroll-mb": [{
                "scroll-mb": L()
            }],
            "scroll-ml": [{
                "scroll-ml": L()
            }],
            "scroll-p": [{
                "scroll-p": L()
            }],
            "scroll-px": [{
                "scroll-px": L()
            }],
            "scroll-py": [{
                "scroll-py": L()
            }],
            "scroll-ps": [{
                "scroll-ps": L()
            }],
            "scroll-pe": [{
                "scroll-pe": L()
            }],
            "scroll-pt": [{
                "scroll-pt": L()
            }],
            "scroll-pr": [{
                "scroll-pr": L()
            }],
            "scroll-pb": [{
                "scroll-pb": L()
            }],
            "scroll-pl": [{
                "scroll-pl": L()
            }],
            "snap-align": [{
                snap: ["start", "end", "center", "align-none"]
            }],
            "snap-stop": [{
                snap: ["normal", "always"]
            }],
            "snap-type": [{
                snap: ["none", "x", "y", "both"]
            }],
            "snap-strictness": [{
                snap: ["mandatory", "proximity"]
            }],
            touch: [{
                touch: ["auto", "none", "manipulation"]
            }],
            "touch-x": [{
                "touch-pan": ["x", "left", "right"]
            }],
            "touch-y": [{
                "touch-pan": ["y", "up", "down"]
            }],
            "touch-pz": ["touch-pinch-zoom"],
            select: [{
                select: ["none", "text", "all", "auto"]
            }],
            "will-change": [{
                "will-change": ["auto", "scroll", "contents", "transform", ae]
            }],
            fill: [{
                fill: [t, "none"]
            }],
            "stroke-w": [{
                stroke: [Dr, cn, id]
            }],
            stroke: [{
                stroke: [t, "none"]
            }],
            sr: ["sr-only", "not-sr-only"],
            "forced-color-adjust": [{
                "forced-color-adjust": ["auto", "none"]
            }]
        },
        conflictingClassGroups: {
            overflow: ["overflow-x", "overflow-y"],
            overscroll: ["overscroll-x", "overscroll-y"],
            inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
            "inset-x": ["right", "left"],
            "inset-y": ["top", "bottom"],
            flex: ["basis", "grow", "shrink"],
            gap: ["gap-x", "gap-y"],
            p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
            px: ["pr", "pl"],
            py: ["pt", "pb"],
            m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
            mx: ["mr", "ml"],
            my: ["mt", "mb"],
            size: ["w", "h"],
            "font-size": ["leading"],
            "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
            "fvn-ordinal": ["fvn-normal"],
            "fvn-slashed-zero": ["fvn-normal"],
            "fvn-figure": ["fvn-normal"],
            "fvn-spacing": ["fvn-normal"],
            "fvn-fraction": ["fvn-normal"],
            "line-clamp": ["display", "overflow"],
            rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
            "rounded-s": ["rounded-ss", "rounded-es"],
            "rounded-e": ["rounded-se", "rounded-ee"],
            "rounded-t": ["rounded-tl", "rounded-tr"],
            "rounded-r": ["rounded-tr", "rounded-br"],
            "rounded-b": ["rounded-br", "rounded-bl"],
            "rounded-l": ["rounded-tl", "rounded-bl"],
            "border-spacing": ["border-spacing-x", "border-spacing-y"],
            "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
            "border-w-x": ["border-w-r", "border-w-l"],
            "border-w-y": ["border-w-t", "border-w-b"],
            "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
            "border-color-x": ["border-color-r", "border-color-l"],
            "border-color-y": ["border-color-t", "border-color-b"],
            "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
            "scroll-mx": ["scroll-mr", "scroll-ml"],
            "scroll-my": ["scroll-mt", "scroll-mb"],
            "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
            "scroll-px": ["scroll-pr", "scroll-pl"],
            "scroll-py": ["scroll-pt", "scroll-pb"],
            touch: ["touch-x", "touch-y", "touch-pz"],
            "touch-x": ["touch"],
            "touch-y": ["touch"],
            "touch-pz": ["touch"]
        },
        conflictingClassGroupModifiers: {
            "font-size": ["leading"]
        }
    }
}
  , UC = bC(FC);
function me(...t) {
    return UC(Qw(t))
}
const BC = HE
  , sx = y.forwardRef( ({className: t, ...e}, r) => d.jsx(zw, {
    ref: r,
    className: me("fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]", t),
    ...e
}));
sx.displayName = zw.displayName;
const zC = iu("group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full", {
    variants: {
        variant: {
            default: "border bg-background text-foreground",
            destructive: "destructive group border-destructive bg-destructive text-destructive-foreground"
        }
    },
    defaultVariants: {
        variant: "default"
    }
})
  , ix = y.forwardRef( ({className: t, variant: e, ...r}, n) => d.jsx(Vw, {
    ref: n,
    className: me(zC({
        variant: e
    }), t),
    ...r
}));
ix.displayName = Vw.displayName;
const VC = y.forwardRef( ({className: t, ...e}, r) => d.jsx(Kw, {
    ref: r,
    className: me("inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors group-[.destructive]:border-muted/40 hover:bg-secondary group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 group-[.destructive]:focus:ring-destructive disabled:pointer-events-none disabled:opacity-50", t),
    ...e
}));
VC.displayName = Kw.displayName;
const ox = y.forwardRef( ({className: t, ...e}, r) => d.jsx(qw, {
    ref: r,
    className: me("absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity group-hover:opacity-100 group-[.destructive]:text-red-300 hover:text-foreground group-[.destructive]:hover:text-red-50 focus:opacity-100 focus:outline-none focus:ring-2 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600", t),
    "toast-close": "",
    ...e,
    children: d.jsx(lC, {
        className: "h-4 w-4"
    })
}));
ox.displayName = qw.displayName;
const ax = y.forwardRef( ({className: t, ...e}, r) => d.jsx(Ww, {
    ref: r,
    className: me("text-sm font-semibold", t),
    ...e
}));
ax.displayName = Ww.displayName;
const lx = y.forwardRef( ({className: t, ...e}, r) => d.jsx(Hw, {
    ref: r,
    className: me("text-sm opacity-90", t),
    ...e
}));
lx.displayName = Hw.displayName;
function WC() {
    const {toasts: t} = tE();
    return d.jsxs(BC, {
        children: [t.map(function({id: e, title: r, description: n, action: s, ...i}) {
            return d.jsxs(ix, {
                ...i,
                children: [d.jsxs("div", {
                    className: "grid gap-1",
                    children: [r && d.jsx(ax, {
                        children: r
                    }), n && d.jsx(lx, {
                        children: n
                    })]
                }), s, d.jsx(ox, {})]
            }, e)
        }), d.jsx(sx, {})]
    })
}
var Sg = ["light", "dark"]
  , HC = "(prefers-color-scheme: dark)"
  , KC = y.createContext(void 0)
  , qC = {
    setTheme: t => {}
    ,
    themes: []
}
  , GC = () => {
    var t;
    return (t = y.useContext(KC)) != null ? t : qC
}
;
y.memo( ({forcedTheme: t, storageKey: e, attribute: r, enableSystem: n, enableColorScheme: s, defaultTheme: i, value: o, attrs: a, nonce: l}) => {
    let c = i === "system"
      , u = r === "class" ? `var d=document.documentElement,c=d.classList;${`c.remove(${a.map(b => `'${b}'`).join(",")})`};` : `var d=document.documentElement,n='${r}',s='setAttribute';`
      , h = s ? Sg.includes(i) && i ? `if(e==='light'||e==='dark'||!e)d.style.colorScheme=e||'${i}'` : "if(e==='light'||e==='dark')d.style.colorScheme=e" : ""
      , p = (b, m=!1, x=!0) => {
        let w = o ? o[b] : b
          , g = m ? b + "|| ''" : `'${w}'`
          , v = "";
        return s && x && !m && Sg.includes(b) && (v += `d.style.colorScheme = '${b}';`),
        r === "class" ? m || w ? v += `c.add(${g})` : v += "null" : w && (v += `d[s](n,${g})`),
        v
    }
      , f = t ? `!function(){${u}${p(t)}}()` : n ? `!function(){try{${u}var e=localStorage.getItem('${e}');if('system'===e||(!e&&${c})){var t='${HC}',m=window.matchMedia(t);if(m.media!==t||m.matches){${p("dark")}}else{${p("light")}}}else if(e){${o ? `var x=${JSON.stringify(o)};` : ""}${p(o ? "x[e]" : "e", !0)}}${c ? "" : "else{" + p(i, !1, !1) + "}"}${h}}catch(e){}}()` : `!function(){try{${u}var e=localStorage.getItem('${e}');if(e){${o ? `var x=${JSON.stringify(o)};` : ""}${p(o ? "x[e]" : "e", !0)}}else{${p(i, !1, !1)};}${h}}catch(t){}}();`;
    return y.createElement("script", {
        nonce: l,
        dangerouslySetInnerHTML: {
            __html: f
        }
    })
}
);
var QC = t => {
    switch (t) {
    case "success":
        return YC;
    case "info":
        return eT;
    case "warning":
        return XC;
    case "error":
        return tT;
    default:
        return null
    }
}
  , JC = Array(12).fill(0)
  , ZC = ({visible: t, className: e}) => j.createElement("div", {
    className: ["sonner-loading-wrapper", e].filter(Boolean).join(" "),
    "data-visible": t
}, j.createElement("div", {
    className: "sonner-spinner"
}, JC.map( (r, n) => j.createElement("div", {
    className: "sonner-loading-bar",
    key: `spinner-bar-${n}`
}))))
  , YC = j.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    height: "20",
    width: "20"
}, j.createElement("path", {
    fillRule: "evenodd",
    d: "M10 18a8 8 0 100-16 8 8 0 000 16zm3.857-9.809a.75.75 0 00-1.214-.882l-3.483 4.79-1.88-1.88a.75.75 0 10-1.06 1.061l2.5 2.5a.75.75 0 001.137-.089l4-5.5z",
    clipRule: "evenodd"
}))
  , XC = j.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    fill: "currentColor",
    height: "20",
    width: "20"
}, j.createElement("path", {
    fillRule: "evenodd",
    d: "M9.401 3.003c1.155-2 4.043-2 5.197 0l7.355 12.748c1.154 2-.29 4.5-2.599 4.5H4.645c-2.309 0-3.752-2.5-2.598-4.5L9.4 3.003zM12 8.25a.75.75 0 01.75.75v3.75a.75.75 0 01-1.5 0V9a.75.75 0 01.75-.75zm0 8.25a.75.75 0 100-1.5.75.75 0 000 1.5z",
    clipRule: "evenodd"
}))
  , eT = j.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    height: "20",
    width: "20"
}, j.createElement("path", {
    fillRule: "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7-4a1 1 0 11-2 0 1 1 0 012 0zM9 9a.75.75 0 000 1.5h.253a.25.25 0 01.244.304l-.459 2.066A1.75 1.75 0 0010.747 15H11a.75.75 0 000-1.5h-.253a.25.25 0 01-.244-.304l.459-2.066A1.75 1.75 0 009.253 9H9z",
    clipRule: "evenodd"
}))
  , tT = j.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 20 20",
    fill: "currentColor",
    height: "20",
    width: "20"
}, j.createElement("path", {
    fillRule: "evenodd",
    d: "M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-8-5a.75.75 0 01.75.75v4.5a.75.75 0 01-1.5 0v-4.5A.75.75 0 0110 5zm0 10a1 1 0 100-2 1 1 0 000 2z",
    clipRule: "evenodd"
}))
  , rT = j.createElement("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    width: "12",
    height: "12",
    viewBox: "0 0 24 24",
    fill: "none",
    stroke: "currentColor",
    strokeWidth: "1.5",
    strokeLinecap: "round",
    strokeLinejoin: "round"
}, j.createElement("line", {
    x1: "18",
    y1: "6",
    x2: "6",
    y2: "18"
}), j.createElement("line", {
    x1: "6",
    y1: "6",
    x2: "18",
    y2: "18"
}))
  , nT = () => {
    let[t,e] = j.useState(document.hidden);
    return j.useEffect( () => {
        let r = () => {
            e(document.hidden)
        }
        ;
        return document.addEventListener("visibilitychange", r),
        () => window.removeEventListener("visibilitychange", r)
    }
    , []),
    t
}
  , Ch = 1
  , sT = class {
    constructor() {
        this.subscribe = t => (this.subscribers.push(t),
        () => {
            let e = this.subscribers.indexOf(t);
            this.subscribers.splice(e, 1)
        }
        ),
        this.publish = t => {
            this.subscribers.forEach(e => e(t))
        }
        ,
        this.addToast = t => {
            this.publish(t),
            this.toasts = [...this.toasts, t]
        }
        ,
        this.create = t => {
            var e;
            let {message: r, ...n} = t
              , s = typeof (t == null ? void 0 : t.id) == "number" || ((e = t.id) == null ? void 0 : e.length) > 0 ? t.id : Ch++
              , i = this.toasts.find(a => a.id === s)
              , o = t.dismissible === void 0 ? !0 : t.dismissible;
            return this.dismissedToasts.has(s) && this.dismissedToasts.delete(s),
            i ? this.toasts = this.toasts.map(a => a.id === s ? (this.publish({
                ...a,
                ...t,
                id: s,
                title: r
            }),
            {
                ...a,
                ...t,
                id: s,
                dismissible: o,
                title: r
            }) : a) : this.addToast({
                title: r,
                ...n,
                dismissible: o,
                id: s
            }),
            s
        }
        ,
        this.dismiss = t => (this.dismissedToasts.add(t),
        t || this.toasts.forEach(e => {
            this.subscribers.forEach(r => r({
                id: e.id,
                dismiss: !0
            }))
        }
        ),
        this.subscribers.forEach(e => e({
            id: t,
            dismiss: !0
        })),
        t),
        this.message = (t, e) => this.create({
            ...e,
            message: t
        }),
        this.error = (t, e) => this.create({
            ...e,
            message: t,
            type: "error"
        }),
        this.success = (t, e) => this.create({
            ...e,
            type: "success",
            message: t
        }),
        this.info = (t, e) => this.create({
            ...e,
            type: "info",
            message: t
        }),
        this.warning = (t, e) => this.create({
            ...e,
            type: "warning",
            message: t
        }),
        this.loading = (t, e) => this.create({
            ...e,
            type: "loading",
            message: t
        }),
        this.promise = (t, e) => {
            if (!e)
                return;
            let r;
            e.loading !== void 0 && (r = this.create({
                ...e,
                promise: t,
                type: "loading",
                message: e.loading,
                description: typeof e.description != "function" ? e.description : void 0
            }));
            let n = t instanceof Promise ? t : t(), s = r !== void 0, i, o = n.then(async l => {
                if (i = ["resolve", l],
                j.isValidElement(l))
                    s = !1,
                    this.create({
                        id: r,
                        type: "default",
                        message: l
                    });
                else if (oT(l) && !l.ok) {
                    s = !1;
                    let c = typeof e.error == "function" ? await e.error(`HTTP error! status: ${l.status}`) : e.error
                      , u = typeof e.description == "function" ? await e.description(`HTTP error! status: ${l.status}`) : e.description;
                    this.create({
                        id: r,
                        type: "error",
                        message: c,
                        description: u
                    })
                } else if (e.success !== void 0) {
                    s = !1;
                    let c = typeof e.success == "function" ? await e.success(l) : e.success
                      , u = typeof e.description == "function" ? await e.description(l) : e.description;
                    this.create({
                        id: r,
                        type: "success",
                        message: c,
                        description: u
                    })
                }
            }
            ).catch(async l => {
                if (i = ["reject", l],
                e.error !== void 0) {
                    s = !1;
                    let c = typeof e.error == "function" ? await e.error(l) : e.error
                      , u = typeof e.description == "function" ? await e.description(l) : e.description;
                    this.create({
                        id: r,
                        type: "error",
                        message: c,
                        description: u
                    })
                }
            }
            ).finally( () => {
                var l;
                s && (this.dismiss(r),
                r = void 0),
                (l = e.finally) == null || l.call(e)
            }
            ), a = () => new Promise( (l, c) => o.then( () => i[0] === "reject" ? c(i[1]) : l(i[1])).catch(c));
            return typeof r != "string" && typeof r != "number" ? {
                unwrap: a
            } : Object.assign(r, {
                unwrap: a
            })
        }
        ,
        this.custom = (t, e) => {
            let r = (e == null ? void 0 : e.id) || Ch++;
            return this.create({
                jsx: t(r),
                id: r,
                ...e
            }),
            r
        }
        ,
        this.getActiveToasts = () => this.toasts.filter(t => !this.dismissedToasts.has(t.id)),
        this.subscribers = [],
        this.toasts = [],
        this.dismissedToasts = new Set
    }
}
  , bt = new sT
  , iT = (t, e) => {
    let r = (e == null ? void 0 : e.id) || Ch++;
    return bt.addToast({
        title: t,
        ...e,
        id: r
    }),
    r
}
  , oT = t => t && typeof t == "object" && "ok"in t && typeof t.ok == "boolean" && "status"in t && typeof t.status == "number"
  , aT = iT
  , lT = () => bt.toasts
  , cT = () => bt.getActiveToasts()
  , St = Object.assign(aT, {
    success: bt.success,
    info: bt.info,
    warning: bt.warning,
    error: bt.error,
    custom: bt.custom,
    message: bt.message,
    promise: bt.promise,
    dismiss: bt.dismiss,
    loading: bt.loading
}, {
    getHistory: lT,
    getToasts: cT
});
function uT(t, {insertAt: e}={}) {
    if (typeof document > "u")
        return;
    let r = document.head || document.getElementsByTagName("head")[0]
      , n = document.createElement("style");
    n.type = "text/css",
    e === "top" && r.firstChild ? r.insertBefore(n, r.firstChild) : r.appendChild(n),
    n.styleSheet ? n.styleSheet.cssText = t : n.appendChild(document.createTextNode(t))
}
uT(`:where(html[dir="ltr"]),:where([data-sonner-toaster][dir="ltr"]){--toast-icon-margin-start: -3px;--toast-icon-margin-end: 4px;--toast-svg-margin-start: -1px;--toast-svg-margin-end: 0px;--toast-button-margin-start: auto;--toast-button-margin-end: 0;--toast-close-button-start: 0;--toast-close-button-end: unset;--toast-close-button-transform: translate(-35%, -35%)}:where(html[dir="rtl"]),:where([data-sonner-toaster][dir="rtl"]){--toast-icon-margin-start: 4px;--toast-icon-margin-end: -3px;--toast-svg-margin-start: 0px;--toast-svg-margin-end: -1px;--toast-button-margin-start: 0;--toast-button-margin-end: auto;--toast-close-button-start: unset;--toast-close-button-end: 0;--toast-close-button-transform: translate(35%, -35%)}:where([data-sonner-toaster]){position:fixed;width:var(--width);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;--gray1: hsl(0, 0%, 99%);--gray2: hsl(0, 0%, 97.3%);--gray3: hsl(0, 0%, 95.1%);--gray4: hsl(0, 0%, 93%);--gray5: hsl(0, 0%, 90.9%);--gray6: hsl(0, 0%, 88.7%);--gray7: hsl(0, 0%, 85.8%);--gray8: hsl(0, 0%, 78%);--gray9: hsl(0, 0%, 56.1%);--gray10: hsl(0, 0%, 52.3%);--gray11: hsl(0, 0%, 43.5%);--gray12: hsl(0, 0%, 9%);--border-radius: 8px;box-sizing:border-box;padding:0;margin:0;list-style:none;outline:none;z-index:999999999;transition:transform .4s ease}:where([data-sonner-toaster][data-lifted="true"]){transform:translateY(-10px)}@media (hover: none) and (pointer: coarse){:where([data-sonner-toaster][data-lifted="true"]){transform:none}}:where([data-sonner-toaster][data-x-position="right"]){right:var(--offset-right)}:where([data-sonner-toaster][data-x-position="left"]){left:var(--offset-left)}:where([data-sonner-toaster][data-x-position="center"]){left:50%;transform:translate(-50%)}:where([data-sonner-toaster][data-y-position="top"]){top:var(--offset-top)}:where([data-sonner-toaster][data-y-position="bottom"]){bottom:var(--offset-bottom)}:where([data-sonner-toast]){--y: translateY(100%);--lift-amount: calc(var(--lift) * var(--gap));z-index:var(--z-index);position:absolute;opacity:0;transform:var(--y);filter:blur(0);touch-action:none;transition:transform .4s,opacity .4s,height .4s,box-shadow .2s;box-sizing:border-box;outline:none;overflow-wrap:anywhere}:where([data-sonner-toast][data-styled="true"]){padding:16px;background:var(--normal-bg);border:1px solid var(--normal-border);color:var(--normal-text);border-radius:var(--border-radius);box-shadow:0 4px 12px #0000001a;width:var(--width);font-size:13px;display:flex;align-items:center;gap:6px}:where([data-sonner-toast]:focus-visible){box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast][data-y-position="top"]){top:0;--y: translateY(-100%);--lift: 1;--lift-amount: calc(1 * var(--gap))}:where([data-sonner-toast][data-y-position="bottom"]){bottom:0;--y: translateY(100%);--lift: -1;--lift-amount: calc(var(--lift) * var(--gap))}:where([data-sonner-toast]) :where([data-description]){font-weight:400;line-height:1.4;color:inherit}:where([data-sonner-toast]) :where([data-title]){font-weight:500;line-height:1.5;color:inherit}:where([data-sonner-toast]) :where([data-icon]){display:flex;height:16px;width:16px;position:relative;justify-content:flex-start;align-items:center;flex-shrink:0;margin-left:var(--toast-icon-margin-start);margin-right:var(--toast-icon-margin-end)}:where([data-sonner-toast][data-promise="true"]) :where([data-icon])>svg{opacity:0;transform:scale(.8);transform-origin:center;animation:sonner-fade-in .3s ease forwards}:where([data-sonner-toast]) :where([data-icon])>*{flex-shrink:0}:where([data-sonner-toast]) :where([data-icon]) svg{margin-left:var(--toast-svg-margin-start);margin-right:var(--toast-svg-margin-end)}:where([data-sonner-toast]) :where([data-content]){display:flex;flex-direction:column;gap:2px}[data-sonner-toast][data-styled=true] [data-button]{border-radius:4px;padding-left:8px;padding-right:8px;height:24px;font-size:12px;color:var(--normal-bg);background:var(--normal-text);margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end);border:none;cursor:pointer;outline:none;display:flex;align-items:center;flex-shrink:0;transition:opacity .4s,box-shadow .2s}:where([data-sonner-toast]) :where([data-button]):focus-visible{box-shadow:0 0 0 2px #0006}:where([data-sonner-toast]) :where([data-button]):first-of-type{margin-left:var(--toast-button-margin-start);margin-right:var(--toast-button-margin-end)}:where([data-sonner-toast]) :where([data-cancel]){color:var(--normal-text);background:rgba(0,0,0,.08)}:where([data-sonner-toast][data-theme="dark"]) :where([data-cancel]){background:rgba(255,255,255,.3)}:where([data-sonner-toast]) :where([data-close-button]){position:absolute;left:var(--toast-close-button-start);right:var(--toast-close-button-end);top:0;height:20px;width:20px;display:flex;justify-content:center;align-items:center;padding:0;color:var(--gray12);border:1px solid var(--gray4);transform:var(--toast-close-button-transform);border-radius:50%;cursor:pointer;z-index:1;transition:opacity .1s,background .2s,border-color .2s}[data-sonner-toast] [data-close-button]{background:var(--gray1)}:where([data-sonner-toast]) :where([data-close-button]):focus-visible{box-shadow:0 4px 12px #0000001a,0 0 0 2px #0003}:where([data-sonner-toast]) :where([data-disabled="true"]){cursor:not-allowed}:where([data-sonner-toast]):hover :where([data-close-button]):hover{background:var(--gray2);border-color:var(--gray5)}:where([data-sonner-toast][data-swiping="true"]):before{content:"";position:absolute;left:-50%;right:-50%;height:100%;z-index:-1}:where([data-sonner-toast][data-y-position="top"][data-swiping="true"]):before{bottom:50%;transform:scaleY(3) translateY(50%)}:where([data-sonner-toast][data-y-position="bottom"][data-swiping="true"]):before{top:50%;transform:scaleY(3) translateY(-50%)}:where([data-sonner-toast][data-swiping="false"][data-removed="true"]):before{content:"";position:absolute;inset:0;transform:scaleY(2)}:where([data-sonner-toast]):after{content:"";position:absolute;left:0;height:calc(var(--gap) + 1px);bottom:100%;width:100%}:where([data-sonner-toast][data-mounted="true"]){--y: translateY(0);opacity:1}:where([data-sonner-toast][data-expanded="false"][data-front="false"]){--scale: var(--toasts-before) * .05 + 1;--y: translateY(calc(var(--lift-amount) * var(--toasts-before))) scale(calc(-1 * var(--scale)));height:var(--front-toast-height)}:where([data-sonner-toast])>*{transition:opacity .4s}:where([data-sonner-toast][data-expanded="false"][data-front="false"][data-styled="true"])>*{opacity:0}:where([data-sonner-toast][data-visible="false"]){opacity:0;pointer-events:none}:where([data-sonner-toast][data-mounted="true"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset)));height:var(--initial-height)}:where([data-sonner-toast][data-removed="true"][data-front="true"][data-swipe-out="false"]){--y: translateY(calc(var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="true"]){--y: translateY(calc(var(--lift) * var(--offset) + var(--lift) * -100%));opacity:0}:where([data-sonner-toast][data-removed="true"][data-front="false"][data-swipe-out="false"][data-expanded="false"]){--y: translateY(40%);opacity:0;transition:transform .5s,opacity .2s}:where([data-sonner-toast][data-removed="true"][data-front="false"]):before{height:calc(var(--initial-height) + 20%)}[data-sonner-toast][data-swiping=true]{transform:var(--y) translateY(var(--swipe-amount-y, 0px)) translate(var(--swipe-amount-x, 0px));transition:none}[data-sonner-toast][data-swiped=true]{user-select:none}[data-sonner-toast][data-swipe-out=true][data-y-position=bottom],[data-sonner-toast][data-swipe-out=true][data-y-position=top]{animation-duration:.2s;animation-timing-function:ease-out;animation-fill-mode:forwards}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=left]{animation-name:swipe-out-left}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=right]{animation-name:swipe-out-right}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=up]{animation-name:swipe-out-up}[data-sonner-toast][data-swipe-out=true][data-swipe-direction=down]{animation-name:swipe-out-down}@keyframes swipe-out-left{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) - 100%));opacity:0}}@keyframes swipe-out-right{0%{transform:var(--y) translate(var(--swipe-amount-x));opacity:1}to{transform:var(--y) translate(calc(var(--swipe-amount-x) + 100%));opacity:0}}@keyframes swipe-out-up{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) - 100%));opacity:0}}@keyframes swipe-out-down{0%{transform:var(--y) translateY(var(--swipe-amount-y));opacity:1}to{transform:var(--y) translateY(calc(var(--swipe-amount-y) + 100%));opacity:0}}@media (max-width: 600px){[data-sonner-toaster]{position:fixed;right:var(--mobile-offset-right);left:var(--mobile-offset-left);width:100%}[data-sonner-toaster][dir=rtl]{left:calc(var(--mobile-offset-left) * -1)}[data-sonner-toaster] [data-sonner-toast]{left:0;right:0;width:calc(100% - var(--mobile-offset-left) * 2)}[data-sonner-toaster][data-x-position=left]{left:var(--mobile-offset-left)}[data-sonner-toaster][data-y-position=bottom]{bottom:var(--mobile-offset-bottom)}[data-sonner-toaster][data-y-position=top]{top:var(--mobile-offset-top)}[data-sonner-toaster][data-x-position=center]{left:var(--mobile-offset-left);right:var(--mobile-offset-right);transform:none}}[data-sonner-toaster][data-theme=light]{--normal-bg: #fff;--normal-border: var(--gray4);--normal-text: var(--gray12);--success-bg: hsl(143, 85%, 96%);--success-border: hsl(145, 92%, 91%);--success-text: hsl(140, 100%, 27%);--info-bg: hsl(208, 100%, 97%);--info-border: hsl(221, 91%, 91%);--info-text: hsl(210, 92%, 45%);--warning-bg: hsl(49, 100%, 97%);--warning-border: hsl(49, 91%, 91%);--warning-text: hsl(31, 92%, 45%);--error-bg: hsl(359, 100%, 97%);--error-border: hsl(359, 100%, 94%);--error-text: hsl(360, 100%, 45%)}[data-sonner-toaster][data-theme=light] [data-sonner-toast][data-invert=true]{--normal-bg: #000;--normal-border: hsl(0, 0%, 20%);--normal-text: var(--gray1)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast][data-invert=true]{--normal-bg: #fff;--normal-border: var(--gray3);--normal-text: var(--gray12)}[data-sonner-toaster][data-theme=dark]{--normal-bg: #000;--normal-bg-hover: hsl(0, 0%, 12%);--normal-border: hsl(0, 0%, 20%);--normal-border-hover: hsl(0, 0%, 25%);--normal-text: var(--gray1);--success-bg: hsl(150, 100%, 6%);--success-border: hsl(147, 100%, 12%);--success-text: hsl(150, 86%, 65%);--info-bg: hsl(215, 100%, 6%);--info-border: hsl(223, 100%, 12%);--info-text: hsl(216, 87%, 65%);--warning-bg: hsl(64, 100%, 6%);--warning-border: hsl(60, 100%, 12%);--warning-text: hsl(46, 87%, 65%);--error-bg: hsl(358, 76%, 10%);--error-border: hsl(357, 89%, 16%);--error-text: hsl(358, 100%, 81%)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]{background:var(--normal-bg);border-color:var(--normal-border);color:var(--normal-text)}[data-sonner-toaster][data-theme=dark] [data-sonner-toast] [data-close-button]:hover{background:var(--normal-bg-hover);border-color:var(--normal-border-hover)}[data-rich-colors=true][data-sonner-toast][data-type=success],[data-rich-colors=true][data-sonner-toast][data-type=success] [data-close-button]{background:var(--success-bg);border-color:var(--success-border);color:var(--success-text)}[data-rich-colors=true][data-sonner-toast][data-type=info],[data-rich-colors=true][data-sonner-toast][data-type=info] [data-close-button]{background:var(--info-bg);border-color:var(--info-border);color:var(--info-text)}[data-rich-colors=true][data-sonner-toast][data-type=warning],[data-rich-colors=true][data-sonner-toast][data-type=warning] [data-close-button]{background:var(--warning-bg);border-color:var(--warning-border);color:var(--warning-text)}[data-rich-colors=true][data-sonner-toast][data-type=error],[data-rich-colors=true][data-sonner-toast][data-type=error] [data-close-button]{background:var(--error-bg);border-color:var(--error-border);color:var(--error-text)}.sonner-loading-wrapper{--size: 16px;height:var(--size);width:var(--size);position:absolute;inset:0;z-index:10}.sonner-loading-wrapper[data-visible=false]{transform-origin:center;animation:sonner-fade-out .2s ease forwards}.sonner-spinner{position:relative;top:50%;left:50%;height:var(--size);width:var(--size)}.sonner-loading-bar{animation:sonner-spin 1.2s linear infinite;background:var(--gray11);border-radius:6px;height:8%;left:-10%;position:absolute;top:-3.9%;width:24%}.sonner-loading-bar:nth-child(1){animation-delay:-1.2s;transform:rotate(.0001deg) translate(146%)}.sonner-loading-bar:nth-child(2){animation-delay:-1.1s;transform:rotate(30deg) translate(146%)}.sonner-loading-bar:nth-child(3){animation-delay:-1s;transform:rotate(60deg) translate(146%)}.sonner-loading-bar:nth-child(4){animation-delay:-.9s;transform:rotate(90deg) translate(146%)}.sonner-loading-bar:nth-child(5){animation-delay:-.8s;transform:rotate(120deg) translate(146%)}.sonner-loading-bar:nth-child(6){animation-delay:-.7s;transform:rotate(150deg) translate(146%)}.sonner-loading-bar:nth-child(7){animation-delay:-.6s;transform:rotate(180deg) translate(146%)}.sonner-loading-bar:nth-child(8){animation-delay:-.5s;transform:rotate(210deg) translate(146%)}.sonner-loading-bar:nth-child(9){animation-delay:-.4s;transform:rotate(240deg) translate(146%)}.sonner-loading-bar:nth-child(10){animation-delay:-.3s;transform:rotate(270deg) translate(146%)}.sonner-loading-bar:nth-child(11){animation-delay:-.2s;transform:rotate(300deg) translate(146%)}.sonner-loading-bar:nth-child(12){animation-delay:-.1s;transform:rotate(330deg) translate(146%)}@keyframes sonner-fade-in{0%{opacity:0;transform:scale(.8)}to{opacity:1;transform:scale(1)}}@keyframes sonner-fade-out{0%{opacity:1;transform:scale(1)}to{opacity:0;transform:scale(.8)}}@keyframes sonner-spin{0%{opacity:1}to{opacity:.15}}@media (prefers-reduced-motion){[data-sonner-toast],[data-sonner-toast]>*,.sonner-loading-bar{transition:none!important;animation:none!important}}.sonner-loader{position:absolute;top:50%;left:50%;transform:translate(-50%,-50%);transform-origin:center;transition:opacity .2s,transform .2s}.sonner-loader[data-visible=false]{opacity:0;transform:scale(.8) translate(-50%,-50%)}
`);
function yl(t) {
    return t.label !== void 0
}
var dT = 3
  , hT = "32px"
  , fT = "16px"
  , kg = 4e3
  , pT = 356
  , mT = 14
  , gT = 20
  , vT = 200;
function ar(...t) {
    return t.filter(Boolean).join(" ")
}
function yT(t) {
    let[e,r] = t.split("-")
      , n = [];
    return e && n.push(e),
    r && n.push(r),
    n
}
var wT = t => {
    var e, r, n, s, i, o, a, l, c, u, h;
    let {invert: p, toast: f, unstyled: b, interacting: m, setHeights: x, visibleToasts: w, heights: g, index: v, toasts: _, expanded: S, removeToast: k, defaultRichColors: C, closeButton: T, style: A, cancelButtonStyle: P, actionButtonStyle: B, className: L="", descriptionClassName: G="", duration: $, position: Y, gap: U, loadingIcon: Q, expandByDefault: R, classNames: N, icons: D, closeButtonAriaLabel: ee="Close toast", pauseWhenPageIsHidden: q} = t
      , [oe,se] = j.useState(null)
      , [Te,Me] = j.useState(null)
      , [M,be] = j.useState(!1)
      , [Fe,we] = j.useState(!1)
      , [fe,ve] = j.useState(!1)
      , [at,Vt] = j.useState(!1)
      , [ns,nn] = j.useState(!1)
      , [ss,bo] = j.useState(0)
      , [Hs,Zp] = j.useState(0)
      , _o = j.useRef(f.duration || $ || kg)
      , Yp = j.useRef(null)
      , is = j.useRef(null)
      , mS = v === 0
      , gS = v + 1 <= w
      , Wt = f.type
      , Ks = f.dismissible !== !1
      , vS = f.className || ""
      , yS = f.descriptionClassName || ""
      , Za = j.useMemo( () => g.findIndex(ie => ie.toastId === f.id) || 0, [g, f.id])
      , wS = j.useMemo( () => {
        var ie;
        return (ie = f.closeButton) != null ? ie : T
    }
    , [f.closeButton, T])
      , Xp = j.useMemo( () => f.duration || $ || kg, [f.duration, $])
      , Cu = j.useRef(0)
      , qs = j.useRef(0)
      , em = j.useRef(0)
      , Gs = j.useRef(null)
      , [xS,bS] = Y.split("-")
      , tm = j.useMemo( () => g.reduce( (ie, Se, je) => je >= Za ? ie : ie + Se.height, 0), [g, Za])
      , rm = nT()
      , _S = f.invert || p
      , Tu = Wt === "loading";
    qs.current = j.useMemo( () => Za * U + tm, [Za, tm]),
    j.useEffect( () => {
        _o.current = Xp
    }
    , [Xp]),
    j.useEffect( () => {
        be(!0)
    }
    , []),
    j.useEffect( () => {
        let ie = is.current;
        if (ie) {
            let Se = ie.getBoundingClientRect().height;
            return Zp(Se),
            x(je => [{
                toastId: f.id,
                height: Se,
                position: f.position
            }, ...je]),
            () => x(je => je.filter(nr => nr.toastId !== f.id))
        }
    }
    , [x, f.id]),
    j.useLayoutEffect( () => {
        if (!M)
            return;
        let ie = is.current
          , Se = ie.style.height;
        ie.style.height = "auto";
        let je = ie.getBoundingClientRect().height;
        ie.style.height = Se,
        Zp(je),
        x(nr => nr.find(sr => sr.toastId === f.id) ? nr.map(sr => sr.toastId === f.id ? {
            ...sr,
            height: je
        } : sr) : [{
            toastId: f.id,
            height: je,
            position: f.position
        }, ...nr])
    }
    , [M, f.title, f.description, x, f.id]);
    let sn = j.useCallback( () => {
        we(!0),
        bo(qs.current),
        x(ie => ie.filter(Se => Se.toastId !== f.id)),
        setTimeout( () => {
            k(f)
        }
        , vT)
    }
    , [f, k, x, qs]);
    j.useEffect( () => {
        if (f.promise && Wt === "loading" || f.duration === 1 / 0 || f.type === "loading")
            return;
        let ie;
        return S || m || q && rm ? ( () => {
            if (em.current < Cu.current) {
                let Se = new Date().getTime() - Cu.current;
                _o.current = _o.current - Se
            }
            em.current = new Date().getTime()
        }
        )() : _o.current !== 1 / 0 && (Cu.current = new Date().getTime(),
        ie = setTimeout( () => {
            var Se;
            (Se = f.onAutoClose) == null || Se.call(f, f),
            sn()
        }
        , _o.current)),
        () => clearTimeout(ie)
    }
    , [S, m, f, Wt, q, rm, sn]),
    j.useEffect( () => {
        f.delete && sn()
    }
    , [sn, f.delete]);
    function SS() {
        var ie, Se, je;
        return D != null && D.loading ? j.createElement("div", {
            className: ar(N == null ? void 0 : N.loader, (ie = f == null ? void 0 : f.classNames) == null ? void 0 : ie.loader, "sonner-loader"),
            "data-visible": Wt === "loading"
        }, D.loading) : Q ? j.createElement("div", {
            className: ar(N == null ? void 0 : N.loader, (Se = f == null ? void 0 : f.classNames) == null ? void 0 : Se.loader, "sonner-loader"),
            "data-visible": Wt === "loading"
        }, Q) : j.createElement(ZC, {
            className: ar(N == null ? void 0 : N.loader, (je = f == null ? void 0 : f.classNames) == null ? void 0 : je.loader),
            visible: Wt === "loading"
        })
    }
    return j.createElement("li", {
        tabIndex: 0,
        ref: is,
        className: ar(L, vS, N == null ? void 0 : N.toast, (e = f == null ? void 0 : f.classNames) == null ? void 0 : e.toast, N == null ? void 0 : N.default, N == null ? void 0 : N[Wt], (r = f == null ? void 0 : f.classNames) == null ? void 0 : r[Wt]),
        "data-sonner-toast": "",
        "data-rich-colors": (n = f.richColors) != null ? n : C,
        "data-styled": !(f.jsx || f.unstyled || b),
        "data-mounted": M,
        "data-promise": !!f.promise,
        "data-swiped": ns,
        "data-removed": Fe,
        "data-visible": gS,
        "data-y-position": xS,
        "data-x-position": bS,
        "data-index": v,
        "data-front": mS,
        "data-swiping": fe,
        "data-dismissible": Ks,
        "data-type": Wt,
        "data-invert": _S,
        "data-swipe-out": at,
        "data-swipe-direction": Te,
        "data-expanded": !!(S || R && M),
        style: {
            "--index": v,
            "--toasts-before": v,
            "--z-index": _.length - v,
            "--offset": `${Fe ? ss : qs.current}px`,
            "--initial-height": R ? "auto" : `${Hs}px`,
            ...A,
            ...f.style
        },
        onDragEnd: () => {
            ve(!1),
            se(null),
            Gs.current = null
        }
        ,
        onPointerDown: ie => {
            Tu || !Ks || (Yp.current = new Date,
            bo(qs.current),
            ie.target.setPointerCapture(ie.pointerId),
            ie.target.tagName !== "BUTTON" && (ve(!0),
            Gs.current = {
                x: ie.clientX,
                y: ie.clientY
            }))
        }
        ,
        onPointerUp: () => {
            var ie, Se, je, nr;
            if (at || !Ks)
                return;
            Gs.current = null;
            let sr = Number(((ie = is.current) == null ? void 0 : ie.style.getPropertyValue("--swipe-amount-x").replace("px", "")) || 0)
              , on = Number(((Se = is.current) == null ? void 0 : Se.style.getPropertyValue("--swipe-amount-y").replace("px", "")) || 0)
              , os = new Date().getTime() - ((je = Yp.current) == null ? void 0 : je.getTime())
              , ir = oe === "x" ? sr : on
              , an = Math.abs(ir) / os;
            if (Math.abs(ir) >= gT || an > .11) {
                bo(qs.current),
                (nr = f.onDismiss) == null || nr.call(f, f),
                Me(oe === "x" ? sr > 0 ? "right" : "left" : on > 0 ? "down" : "up"),
                sn(),
                Vt(!0),
                nn(!1);
                return
            }
            ve(!1),
            se(null)
        }
        ,
        onPointerMove: ie => {
            var Se, je, nr, sr;
            if (!Gs.current || !Ks || ((Se = window.getSelection()) == null ? void 0 : Se.toString().length) > 0)
                return;
            let on = ie.clientY - Gs.current.y
              , os = ie.clientX - Gs.current.x
              , ir = (je = t.swipeDirections) != null ? je : yT(Y);
            !oe && (Math.abs(os) > 1 || Math.abs(on) > 1) && se(Math.abs(os) > Math.abs(on) ? "x" : "y");
            let an = {
                x: 0,
                y: 0
            };
            oe === "y" ? (ir.includes("top") || ir.includes("bottom")) && (ir.includes("top") && on < 0 || ir.includes("bottom") && on > 0) && (an.y = on) : oe === "x" && (ir.includes("left") || ir.includes("right")) && (ir.includes("left") && os < 0 || ir.includes("right") && os > 0) && (an.x = os),
            (Math.abs(an.x) > 0 || Math.abs(an.y) > 0) && nn(!0),
            (nr = is.current) == null || nr.style.setProperty("--swipe-amount-x", `${an.x}px`),
            (sr = is.current) == null || sr.style.setProperty("--swipe-amount-y", `${an.y}px`)
        }
    }, wS && !f.jsx ? j.createElement("button", {
        "aria-label": ee,
        "data-disabled": Tu,
        "data-close-button": !0,
        onClick: Tu || !Ks ? () => {}
        : () => {
            var ie;
            sn(),
            (ie = f.onDismiss) == null || ie.call(f, f)
        }
        ,
        className: ar(N == null ? void 0 : N.closeButton, (s = f == null ? void 0 : f.classNames) == null ? void 0 : s.closeButton)
    }, (i = D == null ? void 0 : D.close) != null ? i : rT) : null, f.jsx || y.isValidElement(f.title) ? f.jsx ? f.jsx : typeof f.title == "function" ? f.title() : f.title : j.createElement(j.Fragment, null, Wt || f.icon || f.promise ? j.createElement("div", {
        "data-icon": "",
        className: ar(N == null ? void 0 : N.icon, (o = f == null ? void 0 : f.classNames) == null ? void 0 : o.icon)
    }, f.promise || f.type === "loading" && !f.icon ? f.icon || SS() : null, f.type !== "loading" ? f.icon || (D == null ? void 0 : D[Wt]) || QC(Wt) : null) : null, j.createElement("div", {
        "data-content": "",
        className: ar(N == null ? void 0 : N.content, (a = f == null ? void 0 : f.classNames) == null ? void 0 : a.content)
    }, j.createElement("div", {
        "data-title": "",
        className: ar(N == null ? void 0 : N.title, (l = f == null ? void 0 : f.classNames) == null ? void 0 : l.title)
    }, typeof f.title == "function" ? f.title() : f.title), f.description ? j.createElement("div", {
        "data-description": "",
        className: ar(G, yS, N == null ? void 0 : N.description, (c = f == null ? void 0 : f.classNames) == null ? void 0 : c.description)
    }, typeof f.description == "function" ? f.description() : f.description) : null), y.isValidElement(f.cancel) ? f.cancel : f.cancel && yl(f.cancel) ? j.createElement("button", {
        "data-button": !0,
        "data-cancel": !0,
        style: f.cancelButtonStyle || P,
        onClick: ie => {
            var Se, je;
            yl(f.cancel) && Ks && ((je = (Se = f.cancel).onClick) == null || je.call(Se, ie),
            sn())
        }
        ,
        className: ar(N == null ? void 0 : N.cancelButton, (u = f == null ? void 0 : f.classNames) == null ? void 0 : u.cancelButton)
    }, f.cancel.label) : null, y.isValidElement(f.action) ? f.action : f.action && yl(f.action) ? j.createElement("button", {
        "data-button": !0,
        "data-action": !0,
        style: f.actionButtonStyle || B,
        onClick: ie => {
            var Se, je;
            yl(f.action) && ((je = (Se = f.action).onClick) == null || je.call(Se, ie),
            !ie.defaultPrevented && sn())
        }
        ,
        className: ar(N == null ? void 0 : N.actionButton, (h = f == null ? void 0 : f.classNames) == null ? void 0 : h.actionButton)
    }, f.action.label) : null))
}
;
function Eg() {
    if (typeof window > "u" || typeof document > "u")
        return "ltr";
    let t = document.documentElement.getAttribute("dir");
    return t === "auto" || !t ? window.getComputedStyle(document.documentElement).direction : t
}
function xT(t, e) {
    let r = {};
    return [t, e].forEach( (n, s) => {
        let i = s === 1
          , o = i ? "--mobile-offset" : "--offset"
          , a = i ? fT : hT;
        function l(c) {
            ["top", "right", "bottom", "left"].forEach(u => {
                r[`${o}-${u}`] = typeof c == "number" ? `${c}px` : c
            }
            )
        }
        typeof n == "number" || typeof n == "string" ? l(n) : typeof n == "object" ? ["top", "right", "bottom", "left"].forEach(c => {
            n[c] === void 0 ? r[`${o}-${c}`] = a : r[`${o}-${c}`] = typeof n[c] == "number" ? `${n[c]}px` : n[c]
        }
        ) : l(a)
    }
    ),
    r
}
var bT = y.forwardRef(function(t, e) {
    let {invert: r, position: n="bottom-right", hotkey: s=["altKey", "KeyT"], expand: i, closeButton: o, className: a, offset: l, mobileOffset: c, theme: u="light", richColors: h, duration: p, style: f, visibleToasts: b=dT, toastOptions: m, dir: x=Eg(), gap: w=mT, loadingIcon: g, icons: v, containerAriaLabel: _="Notifications", pauseWhenPageIsHidden: S} = t
      , [k,C] = j.useState([])
      , T = j.useMemo( () => Array.from(new Set([n].concat(k.filter(q => q.position).map(q => q.position)))), [k, n])
      , [A,P] = j.useState([])
      , [B,L] = j.useState(!1)
      , [G,$] = j.useState(!1)
      , [Y,U] = j.useState(u !== "system" ? u : typeof window < "u" && window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light")
      , Q = j.useRef(null)
      , R = s.join("+").replace(/Key/g, "").replace(/Digit/g, "")
      , N = j.useRef(null)
      , D = j.useRef(!1)
      , ee = j.useCallback(q => {
        C(oe => {
            var se;
            return (se = oe.find(Te => Te.id === q.id)) != null && se.delete || bt.dismiss(q.id),
            oe.filter( ({id: Te}) => Te !== q.id)
        }
        )
    }
    , []);
    return j.useEffect( () => bt.subscribe(q => {
        if (q.dismiss) {
            C(oe => oe.map(se => se.id === q.id ? {
                ...se,
                delete: !0
            } : se));
            return
        }
        setTimeout( () => {
            xw.flushSync( () => {
                C(oe => {
                    let se = oe.findIndex(Te => Te.id === q.id);
                    return se !== -1 ? [...oe.slice(0, se), {
                        ...oe[se],
                        ...q
                    }, ...oe.slice(se + 1)] : [q, ...oe]
                }
                )
            }
            )
        }
        )
    }
    ), []),
    j.useEffect( () => {
        if (u !== "system") {
            U(u);
            return
        }
        if (u === "system" && (window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches ? U("dark") : U("light")),
        typeof window > "u")
            return;
        let q = window.matchMedia("(prefers-color-scheme: dark)");
        try {
            q.addEventListener("change", ({matches: oe}) => {
                U(oe ? "dark" : "light")
            }
            )
        } catch {
            q.addListener( ({matches: se}) => {
                try {
                    U(se ? "dark" : "light")
                } catch (Te) {
                    console.error(Te)
                }
            }
            )
        }
    }
    , [u]),
    j.useEffect( () => {
        k.length <= 1 && L(!1)
    }
    , [k]),
    j.useEffect( () => {
        let q = oe => {
            var se, Te;
            s.every(Me => oe[Me] || oe.code === Me) && (L(!0),
            (se = Q.current) == null || se.focus()),
            oe.code === "Escape" && (document.activeElement === Q.current || (Te = Q.current) != null && Te.contains(document.activeElement)) && L(!1)
        }
        ;
        return document.addEventListener("keydown", q),
        () => document.removeEventListener("keydown", q)
    }
    , [s]),
    j.useEffect( () => {
        if (Q.current)
            return () => {
                N.current && (N.current.focus({
                    preventScroll: !0
                }),
                N.current = null,
                D.current = !1)
            }
    }
    , [Q.current]),
    j.createElement("section", {
        ref: e,
        "aria-label": `${_} ${R}`,
        tabIndex: -1,
        "aria-live": "polite",
        "aria-relevant": "additions text",
        "aria-atomic": "false",
        suppressHydrationWarning: !0
    }, T.map( (q, oe) => {
        var se;
        let[Te,Me] = q.split("-");
        return k.length ? j.createElement("ol", {
            key: q,
            dir: x === "auto" ? Eg() : x,
            tabIndex: -1,
            ref: Q,
            className: a,
            "data-sonner-toaster": !0,
            "data-theme": Y,
            "data-y-position": Te,
            "data-lifted": B && k.length > 1 && !i,
            "data-x-position": Me,
            style: {
                "--front-toast-height": `${((se = A[0]) == null ? void 0 : se.height) || 0}px`,
                "--width": `${pT}px`,
                "--gap": `${w}px`,
                ...f,
                ...xT(l, c)
            },
            onBlur: M => {
                D.current && !M.currentTarget.contains(M.relatedTarget) && (D.current = !1,
                N.current && (N.current.focus({
                    preventScroll: !0
                }),
                N.current = null))
            }
            ,
            onFocus: M => {
                M.target instanceof HTMLElement && M.target.dataset.dismissible === "false" || D.current || (D.current = !0,
                N.current = M.relatedTarget)
            }
            ,
            onMouseEnter: () => L(!0),
            onMouseMove: () => L(!0),
            onMouseLeave: () => {
                G || L(!1)
            }
            ,
            onDragEnd: () => L(!1),
            onPointerDown: M => {
                M.target instanceof HTMLElement && M.target.dataset.dismissible === "false" || $(!0)
            }
            ,
            onPointerUp: () => $(!1)
        }, k.filter(M => !M.position && oe === 0 || M.position === q).map( (M, be) => {
            var Fe, we;
            return j.createElement(wT, {
                key: M.id,
                icons: v,
                index: be,
                toast: M,
                defaultRichColors: h,
                duration: (Fe = m == null ? void 0 : m.duration) != null ? Fe : p,
                className: m == null ? void 0 : m.className,
                descriptionClassName: m == null ? void 0 : m.descriptionClassName,
                invert: r,
                visibleToasts: b,
                closeButton: (we = m == null ? void 0 : m.closeButton) != null ? we : o,
                interacting: G,
                position: q,
                style: m == null ? void 0 : m.style,
                unstyled: m == null ? void 0 : m.unstyled,
                classNames: m == null ? void 0 : m.classNames,
                cancelButtonStyle: m == null ? void 0 : m.cancelButtonStyle,
                actionButtonStyle: m == null ? void 0 : m.actionButtonStyle,
                removeToast: ee,
                toasts: k.filter(fe => fe.position == M.position),
                heights: A.filter(fe => fe.position == M.position),
                setHeights: P,
                expandByDefault: i,
                gap: w,
                loadingIcon: g,
                expanded: B,
                pauseWhenPageIsHidden: S,
                swipeDirections: t.swipeDirections
            })
        }
        )) : null
    }
    ))
});
const _T = ({...t}) => {
    const {theme: e="system"} = GC();
    return d.jsx(bT, {
        theme: e,
        className: "toaster group",
        toastOptions: {
            classNames: {
                toast: "group toast group-[.toaster]:bg-background group-[.toaster]:text-foreground group-[.toaster]:border-border group-[.toaster]:shadow-lg",
                description: "group-[.toast]:text-muted-foreground",
                actionButton: "group-[.toast]:bg-primary group-[.toast]:text-primary-foreground",
                cancelButton: "group-[.toast]:bg-muted group-[.toast]:text-muted-foreground"
            }
        },
        ...t
    })
}
;
var ST = Ef[" useId ".trim().toString()] || ( () => {}
)
  , kT = 0;
function zs(t) {
    const [e,r] = y.useState(ST());
    return et( () => {
        r(n => n ?? String(kT++))
    }
    , [t]),
    e ? `radix-${e}` : ""
}
const ET = ["top", "right", "bottom", "left"]
  , qn = Math.min
  , At = Math.max
  , xc = Math.round
  , wl = Math.floor
  , Or = t => ({
    x: t,
    y: t
})
  , CT = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
}
  , TT = {
    start: "end",
    end: "start"
};
function Th(t, e, r) {
    return At(t, qn(e, r))
}
function Zr(t, e) {
    return typeof t == "function" ? t(e) : t
}
function Yr(t) {
    return t.split("-")[0]
}
function go(t) {
    return t.split("-")[1]
}
function _p(t) {
    return t === "x" ? "y" : "x"
}
function Sp(t) {
    return t === "y" ? "height" : "width"
}
const RT = new Set(["top", "bottom"]);
function Pr(t) {
    return RT.has(Yr(t)) ? "y" : "x"
}
function kp(t) {
    return _p(Pr(t))
}
function NT(t, e, r) {
    r === void 0 && (r = !1);
    const n = go(t)
      , s = kp(t)
      , i = Sp(s);
    let o = s === "x" ? n === (r ? "end" : "start") ? "right" : "left" : n === "start" ? "bottom" : "top";
    return e.reference[i] > e.floating[i] && (o = bc(o)),
    [o, bc(o)]
}
function PT(t) {
    const e = bc(t);
    return [Rh(t), e, Rh(e)]
}
function Rh(t) {
    return t.replace(/start|end/g, e => TT[e])
}
const Cg = ["left", "right"]
  , Tg = ["right", "left"]
  , AT = ["top", "bottom"]
  , jT = ["bottom", "top"];
function OT(t, e, r) {
    switch (t) {
    case "top":
    case "bottom":
        return r ? e ? Tg : Cg : e ? Cg : Tg;
    case "left":
    case "right":
        return e ? AT : jT;
    default:
        return []
    }
}
function IT(t, e, r, n) {
    const s = go(t);
    let i = OT(Yr(t), r === "start", n);
    return s && (i = i.map(o => o + "-" + s),
    e && (i = i.concat(i.map(Rh)))),
    i
}
function bc(t) {
    return t.replace(/left|right|bottom|top/g, e => CT[e])
}
function LT(t) {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...t
    }
}
function cx(t) {
    return typeof t != "number" ? LT(t) : {
        top: t,
        right: t,
        bottom: t,
        left: t
    }
}
function _c(t) {
    const {x: e, y: r, width: n, height: s} = t;
    return {
        width: n,
        height: s,
        top: r,
        left: e,
        right: e + n,
        bottom: r + s,
        x: e,
        y: r
    }
}
function Rg(t, e, r) {
    let {reference: n, floating: s} = t;
    const i = Pr(e)
      , o = kp(e)
      , a = Sp(o)
      , l = Yr(e)
      , c = i === "y"
      , u = n.x + n.width / 2 - s.width / 2
      , h = n.y + n.height / 2 - s.height / 2
      , p = n[a] / 2 - s[a] / 2;
    let f;
    switch (l) {
    case "top":
        f = {
            x: u,
            y: n.y - s.height
        };
        break;
    case "bottom":
        f = {
            x: u,
            y: n.y + n.height
        };
        break;
    case "right":
        f = {
            x: n.x + n.width,
            y: h
        };
        break;
    case "left":
        f = {
            x: n.x - s.width,
            y: h
        };
        break;
    default:
        f = {
            x: n.x,
            y: n.y
        }
    }
    switch (go(e)) {
    case "start":
        f[o] -= p * (r && c ? -1 : 1);
        break;
    case "end":
        f[o] += p * (r && c ? -1 : 1);
        break
    }
    return f
}
const $T = async (t, e, r) => {
    const {placement: n="bottom", strategy: s="absolute", middleware: i=[], platform: o} = r
      , a = i.filter(Boolean)
      , l = await (o.isRTL == null ? void 0 : o.isRTL(e));
    let c = await o.getElementRects({
        reference: t,
        floating: e,
        strategy: s
    })
      , {x: u, y: h} = Rg(c, n, l)
      , p = n
      , f = {}
      , b = 0;
    for (let m = 0; m < a.length; m++) {
        const {name: x, fn: w} = a[m]
          , {x: g, y: v, data: _, reset: S} = await w({
            x: u,
            y: h,
            initialPlacement: n,
            placement: p,
            strategy: s,
            middlewareData: f,
            rects: c,
            platform: o,
            elements: {
                reference: t,
                floating: e
            }
        });
        u = g ?? u,
        h = v ?? h,
        f = {
            ...f,
            [x]: {
                ...f[x],
                ..._
            }
        },
        S && b <= 50 && (b++,
        typeof S == "object" && (S.placement && (p = S.placement),
        S.rects && (c = S.rects === !0 ? await o.getElementRects({
            reference: t,
            floating: e,
            strategy: s
        }) : S.rects),
        {x: u, y: h} = Rg(c, p, l)),
        m = -1)
    }
    return {
        x: u,
        y: h,
        placement: p,
        strategy: s,
        middlewareData: f
    }
}
;
async function ya(t, e) {
    var r;
    e === void 0 && (e = {});
    const {x: n, y: s, platform: i, rects: o, elements: a, strategy: l} = t
      , {boundary: c="clippingAncestors", rootBoundary: u="viewport", elementContext: h="floating", altBoundary: p=!1, padding: f=0} = Zr(e, t)
      , b = cx(f)
      , x = a[p ? h === "floating" ? "reference" : "floating" : h]
      , w = _c(await i.getClippingRect({
        element: (r = await (i.isElement == null ? void 0 : i.isElement(x))) == null || r ? x : x.contextElement || await (i.getDocumentElement == null ? void 0 : i.getDocumentElement(a.floating)),
        boundary: c,
        rootBoundary: u,
        strategy: l
    }))
      , g = h === "floating" ? {
        x: n,
        y: s,
        width: o.floating.width,
        height: o.floating.height
    } : o.reference
      , v = await (i.getOffsetParent == null ? void 0 : i.getOffsetParent(a.floating))
      , _ = await (i.isElement == null ? void 0 : i.isElement(v)) ? await (i.getScale == null ? void 0 : i.getScale(v)) || {
        x: 1,
        y: 1
    } : {
        x: 1,
        y: 1
    }
      , S = _c(i.convertOffsetParentRelativeRectToViewportRelativeRect ? await i.convertOffsetParentRelativeRectToViewportRelativeRect({
        elements: a,
        rect: g,
        offsetParent: v,
        strategy: l
    }) : g);
    return {
        top: (w.top - S.top + b.top) / _.y,
        bottom: (S.bottom - w.bottom + b.bottom) / _.y,
        left: (w.left - S.left + b.left) / _.x,
        right: (S.right - w.right + b.right) / _.x
    }
}
const DT = t => ({
    name: "arrow",
    options: t,
    async fn(e) {
        const {x: r, y: n, placement: s, rects: i, platform: o, elements: a, middlewareData: l} = e
          , {element: c, padding: u=0} = Zr(t, e) || {};
        if (c == null)
            return {};
        const h = cx(u)
          , p = {
            x: r,
            y: n
        }
          , f = kp(s)
          , b = Sp(f)
          , m = await o.getDimensions(c)
          , x = f === "y"
          , w = x ? "top" : "left"
          , g = x ? "bottom" : "right"
          , v = x ? "clientHeight" : "clientWidth"
          , _ = i.reference[b] + i.reference[f] - p[f] - i.floating[b]
          , S = p[f] - i.reference[f]
          , k = await (o.getOffsetParent == null ? void 0 : o.getOffsetParent(c));
        let C = k ? k[v] : 0;
        (!C || !await (o.isElement == null ? void 0 : o.isElement(k))) && (C = a.floating[v] || i.floating[b]);
        const T = _ / 2 - S / 2
          , A = C / 2 - m[b] / 2 - 1
          , P = qn(h[w], A)
          , B = qn(h[g], A)
          , L = P
          , G = C - m[b] - B
          , $ = C / 2 - m[b] / 2 + T
          , Y = Th(L, $, G)
          , U = !l.arrow && go(s) != null && $ !== Y && i.reference[b] / 2 - ($ < L ? P : B) - m[b] / 2 < 0
          , Q = U ? $ < L ? $ - L : $ - G : 0;
        return {
            [f]: p[f] + Q,
            data: {
                [f]: Y,
                centerOffset: $ - Y - Q,
                ...U && {
                    alignmentOffset: Q
                }
            },
            reset: U
        }
    }
})
  , MT = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "flip",
        options: t,
        async fn(e) {
            var r, n;
            const {placement: s, middlewareData: i, rects: o, initialPlacement: a, platform: l, elements: c} = e
              , {mainAxis: u=!0, crossAxis: h=!0, fallbackPlacements: p, fallbackStrategy: f="bestFit", fallbackAxisSideDirection: b="none", flipAlignment: m=!0, ...x} = Zr(t, e);
            if ((r = i.arrow) != null && r.alignmentOffset)
                return {};
            const w = Yr(s)
              , g = Pr(a)
              , v = Yr(a) === a
              , _ = await (l.isRTL == null ? void 0 : l.isRTL(c.floating))
              , S = p || (v || !m ? [bc(a)] : PT(a))
              , k = b !== "none";
            !p && k && S.push(...IT(a, m, b, _));
            const C = [a, ...S]
              , T = await ya(e, x)
              , A = [];
            let P = ((n = i.flip) == null ? void 0 : n.overflows) || [];
            if (u && A.push(T[w]),
            h) {
                const $ = NT(s, o, _);
                A.push(T[$[0]], T[$[1]])
            }
            if (P = [...P, {
                placement: s,
                overflows: A
            }],
            !A.every($ => $ <= 0)) {
                var B, L;
                const $ = (((B = i.flip) == null ? void 0 : B.index) || 0) + 1
                  , Y = C[$];
                if (Y && (!(h === "alignment" ? g !== Pr(Y) : !1) || P.every(R => R.overflows[0] > 0 && Pr(R.placement) === g)))
                    return {
                        data: {
                            index: $,
                            overflows: P
                        },
                        reset: {
                            placement: Y
                        }
                    };
                let U = (L = P.filter(Q => Q.overflows[0] <= 0).sort( (Q, R) => Q.overflows[1] - R.overflows[1])[0]) == null ? void 0 : L.placement;
                if (!U)
                    switch (f) {
                    case "bestFit":
                        {
                            var G;
                            const Q = (G = P.filter(R => {
                                if (k) {
                                    const N = Pr(R.placement);
                                    return N === g || N === "y"
                                }
                                return !0
                            }
                            ).map(R => [R.placement, R.overflows.filter(N => N > 0).reduce( (N, D) => N + D, 0)]).sort( (R, N) => R[1] - N[1])[0]) == null ? void 0 : G[0];
                            Q && (U = Q);
                            break
                        }
                    case "initialPlacement":
                        U = a;
                        break
                    }
                if (s !== U)
                    return {
                        reset: {
                            placement: U
                        }
                    }
            }
            return {}
        }
    }
};
function Ng(t, e) {
    return {
        top: t.top - e.height,
        right: t.right - e.width,
        bottom: t.bottom - e.height,
        left: t.left - e.width
    }
}
function Pg(t) {
    return ET.some(e => t[e] >= 0)
}
const FT = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "hide",
        options: t,
        async fn(e) {
            const {rects: r} = e
              , {strategy: n="referenceHidden", ...s} = Zr(t, e);
            switch (n) {
            case "referenceHidden":
                {
                    const i = await ya(e, {
                        ...s,
                        elementContext: "reference"
                    })
                      , o = Ng(i, r.reference);
                    return {
                        data: {
                            referenceHiddenOffsets: o,
                            referenceHidden: Pg(o)
                        }
                    }
                }
            case "escaped":
                {
                    const i = await ya(e, {
                        ...s,
                        altBoundary: !0
                    })
                      , o = Ng(i, r.floating);
                    return {
                        data: {
                            escapedOffsets: o,
                            escaped: Pg(o)
                        }
                    }
                }
            default:
                return {}
            }
        }
    }
}
  , ux = new Set(["left", "top"]);
async function UT(t, e) {
    const {placement: r, platform: n, elements: s} = t
      , i = await (n.isRTL == null ? void 0 : n.isRTL(s.floating))
      , o = Yr(r)
      , a = go(r)
      , l = Pr(r) === "y"
      , c = ux.has(o) ? -1 : 1
      , u = i && l ? -1 : 1
      , h = Zr(e, t);
    let {mainAxis: p, crossAxis: f, alignmentAxis: b} = typeof h == "number" ? {
        mainAxis: h,
        crossAxis: 0,
        alignmentAxis: null
    } : {
        mainAxis: h.mainAxis || 0,
        crossAxis: h.crossAxis || 0,
        alignmentAxis: h.alignmentAxis
    };
    return a && typeof b == "number" && (f = a === "end" ? b * -1 : b),
    l ? {
        x: f * u,
        y: p * c
    } : {
        x: p * c,
        y: f * u
    }
}
const BT = function(t) {
    return t === void 0 && (t = 0),
    {
        name: "offset",
        options: t,
        async fn(e) {
            var r, n;
            const {x: s, y: i, placement: o, middlewareData: a} = e
              , l = await UT(e, t);
            return o === ((r = a.offset) == null ? void 0 : r.placement) && (n = a.arrow) != null && n.alignmentOffset ? {} : {
                x: s + l.x,
                y: i + l.y,
                data: {
                    ...l,
                    placement: o
                }
            }
        }
    }
}
  , zT = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "shift",
        options: t,
        async fn(e) {
            const {x: r, y: n, placement: s} = e
              , {mainAxis: i=!0, crossAxis: o=!1, limiter: a={
                fn: x => {
                    let {x: w, y: g} = x;
                    return {
                        x: w,
                        y: g
                    }
                }
            }, ...l} = Zr(t, e)
              , c = {
                x: r,
                y: n
            }
              , u = await ya(e, l)
              , h = Pr(Yr(s))
              , p = _p(h);
            let f = c[p]
              , b = c[h];
            if (i) {
                const x = p === "y" ? "top" : "left"
                  , w = p === "y" ? "bottom" : "right"
                  , g = f + u[x]
                  , v = f - u[w];
                f = Th(g, f, v)
            }
            if (o) {
                const x = h === "y" ? "top" : "left"
                  , w = h === "y" ? "bottom" : "right"
                  , g = b + u[x]
                  , v = b - u[w];
                b = Th(g, b, v)
            }
            const m = a.fn({
                ...e,
                [p]: f,
                [h]: b
            });
            return {
                ...m,
                data: {
                    x: m.x - r,
                    y: m.y - n,
                    enabled: {
                        [p]: i,
                        [h]: o
                    }
                }
            }
        }
    }
}
  , VT = function(t) {
    return t === void 0 && (t = {}),
    {
        options: t,
        fn(e) {
            const {x: r, y: n, placement: s, rects: i, middlewareData: o} = e
              , {offset: a=0, mainAxis: l=!0, crossAxis: c=!0} = Zr(t, e)
              , u = {
                x: r,
                y: n
            }
              , h = Pr(s)
              , p = _p(h);
            let f = u[p]
              , b = u[h];
            const m = Zr(a, e)
              , x = typeof m == "number" ? {
                mainAxis: m,
                crossAxis: 0
            } : {
                mainAxis: 0,
                crossAxis: 0,
                ...m
            };
            if (l) {
                const v = p === "y" ? "height" : "width"
                  , _ = i.reference[p] - i.floating[v] + x.mainAxis
                  , S = i.reference[p] + i.reference[v] - x.mainAxis;
                f < _ ? f = _ : f > S && (f = S)
            }
            if (c) {
                var w, g;
                const v = p === "y" ? "width" : "height"
                  , _ = ux.has(Yr(s))
                  , S = i.reference[h] - i.floating[v] + (_ && ((w = o.offset) == null ? void 0 : w[h]) || 0) + (_ ? 0 : x.crossAxis)
                  , k = i.reference[h] + i.reference[v] + (_ ? 0 : ((g = o.offset) == null ? void 0 : g[h]) || 0) - (_ ? x.crossAxis : 0);
                b < S ? b = S : b > k && (b = k)
            }
            return {
                [p]: f,
                [h]: b
            }
        }
    }
}
  , WT = function(t) {
    return t === void 0 && (t = {}),
    {
        name: "size",
        options: t,
        async fn(e) {
            var r, n;
            const {placement: s, rects: i, platform: o, elements: a} = e
              , {apply: l= () => {}
            , ...c} = Zr(t, e)
              , u = await ya(e, c)
              , h = Yr(s)
              , p = go(s)
              , f = Pr(s) === "y"
              , {width: b, height: m} = i.floating;
            let x, w;
            h === "top" || h === "bottom" ? (x = h,
            w = p === (await (o.isRTL == null ? void 0 : o.isRTL(a.floating)) ? "start" : "end") ? "left" : "right") : (w = h,
            x = p === "end" ? "top" : "bottom");
            const g = m - u.top - u.bottom
              , v = b - u.left - u.right
              , _ = qn(m - u[x], g)
              , S = qn(b - u[w], v)
              , k = !e.middlewareData.shift;
            let C = _
              , T = S;
            if ((r = e.middlewareData.shift) != null && r.enabled.x && (T = v),
            (n = e.middlewareData.shift) != null && n.enabled.y && (C = g),
            k && !p) {
                const P = At(u.left, 0)
                  , B = At(u.right, 0)
                  , L = At(u.top, 0)
                  , G = At(u.bottom, 0);
                f ? T = b - 2 * (P !== 0 || B !== 0 ? P + B : At(u.left, u.right)) : C = m - 2 * (L !== 0 || G !== 0 ? L + G : At(u.top, u.bottom))
            }
            await l({
                ...e,
                availableWidth: T,
                availableHeight: C
            });
            const A = await o.getDimensions(a.floating);
            return b !== A.width || m !== A.height ? {
                reset: {
                    rects: !0
                }
            } : {}
        }
    }
};
function ou() {
    return typeof window < "u"
}
function vo(t) {
    return dx(t) ? (t.nodeName || "").toLowerCase() : "#document"
}
function Mt(t) {
    var e;
    return (t == null || (e = t.ownerDocument) == null ? void 0 : e.defaultView) || window
}
function $r(t) {
    var e;
    return (e = (dx(t) ? t.ownerDocument : t.document) || window.document) == null ? void 0 : e.documentElement
}
function dx(t) {
    return ou() ? t instanceof Node || t instanceof Mt(t).Node : !1
}
function xr(t) {
    return ou() ? t instanceof Element || t instanceof Mt(t).Element : !1
}
function Lr(t) {
    return ou() ? t instanceof HTMLElement || t instanceof Mt(t).HTMLElement : !1
}
function Ag(t) {
    return !ou() || typeof ShadowRoot > "u" ? !1 : t instanceof ShadowRoot || t instanceof Mt(t).ShadowRoot
}
const HT = new Set(["inline", "contents"]);
function Ha(t) {
    const {overflow: e, overflowX: r, overflowY: n, display: s} = br(t);
    return /auto|scroll|overlay|hidden|clip/.test(e + n + r) && !HT.has(s)
}
const KT = new Set(["table", "td", "th"]);
function qT(t) {
    return KT.has(vo(t))
}
const GT = [":popover-open", ":modal"];
function au(t) {
    return GT.some(e => {
        try {
            return t.matches(e)
        } catch {
            return !1
        }
    }
    )
}
const QT = ["transform", "translate", "scale", "rotate", "perspective"]
  , JT = ["transform", "translate", "scale", "rotate", "perspective", "filter"]
  , ZT = ["paint", "layout", "strict", "content"];
function Ep(t) {
    const e = Cp()
      , r = xr(t) ? br(t) : t;
    return QT.some(n => r[n] ? r[n] !== "none" : !1) || (r.containerType ? r.containerType !== "normal" : !1) || !e && (r.backdropFilter ? r.backdropFilter !== "none" : !1) || !e && (r.filter ? r.filter !== "none" : !1) || JT.some(n => (r.willChange || "").includes(n)) || ZT.some(n => (r.contain || "").includes(n))
}
function YT(t) {
    let e = Gn(t);
    for (; Lr(e) && !no(e); ) {
        if (Ep(e))
            return e;
        if (au(e))
            return null;
        e = Gn(e)
    }
    return null
}
function Cp() {
    return typeof CSS > "u" || !CSS.supports ? !1 : CSS.supports("-webkit-backdrop-filter", "none")
}
const XT = new Set(["html", "body", "#document"]);
function no(t) {
    return XT.has(vo(t))
}
function br(t) {
    return Mt(t).getComputedStyle(t)
}
function lu(t) {
    return xr(t) ? {
        scrollLeft: t.scrollLeft,
        scrollTop: t.scrollTop
    } : {
        scrollLeft: t.scrollX,
        scrollTop: t.scrollY
    }
}
function Gn(t) {
    if (vo(t) === "html")
        return t;
    const e = t.assignedSlot || t.parentNode || Ag(t) && t.host || $r(t);
    return Ag(e) ? e.host : e
}
function hx(t) {
    const e = Gn(t);
    return no(e) ? t.ownerDocument ? t.ownerDocument.body : t.body : Lr(e) && Ha(e) ? e : hx(e)
}
function wa(t, e, r) {
    var n;
    e === void 0 && (e = []),
    r === void 0 && (r = !0);
    const s = hx(t)
      , i = s === ((n = t.ownerDocument) == null ? void 0 : n.body)
      , o = Mt(s);
    if (i) {
        const a = Nh(o);
        return e.concat(o, o.visualViewport || [], Ha(s) ? s : [], a && r ? wa(a) : [])
    }
    return e.concat(s, wa(s, [], r))
}
function Nh(t) {
    return t.parent && Object.getPrototypeOf(t.parent) ? t.frameElement : null
}
function fx(t) {
    const e = br(t);
    let r = parseFloat(e.width) || 0
      , n = parseFloat(e.height) || 0;
    const s = Lr(t)
      , i = s ? t.offsetWidth : r
      , o = s ? t.offsetHeight : n
      , a = xc(r) !== i || xc(n) !== o;
    return a && (r = i,
    n = o),
    {
        width: r,
        height: n,
        $: a
    }
}
function Tp(t) {
    return xr(t) ? t : t.contextElement
}
function Oi(t) {
    const e = Tp(t);
    if (!Lr(e))
        return Or(1);
    const r = e.getBoundingClientRect()
      , {width: n, height: s, $: i} = fx(e);
    let o = (i ? xc(r.width) : r.width) / n
      , a = (i ? xc(r.height) : r.height) / s;
    return (!o || !Number.isFinite(o)) && (o = 1),
    (!a || !Number.isFinite(a)) && (a = 1),
    {
        x: o,
        y: a
    }
}
const eR = Or(0);
function px(t) {
    const e = Mt(t);
    return !Cp() || !e.visualViewport ? eR : {
        x: e.visualViewport.offsetLeft,
        y: e.visualViewport.offsetTop
    }
}
function tR(t, e, r) {
    return e === void 0 && (e = !1),
    !r || e && r !== Mt(t) ? !1 : e
}
function Is(t, e, r, n) {
    e === void 0 && (e = !1),
    r === void 0 && (r = !1);
    const s = t.getBoundingClientRect()
      , i = Tp(t);
    let o = Or(1);
    e && (n ? xr(n) && (o = Oi(n)) : o = Oi(t));
    const a = tR(i, r, n) ? px(i) : Or(0);
    let l = (s.left + a.x) / o.x
      , c = (s.top + a.y) / o.y
      , u = s.width / o.x
      , h = s.height / o.y;
    if (i) {
        const p = Mt(i)
          , f = n && xr(n) ? Mt(n) : n;
        let b = p
          , m = Nh(b);
        for (; m && n && f !== b; ) {
            const x = Oi(m)
              , w = m.getBoundingClientRect()
              , g = br(m)
              , v = w.left + (m.clientLeft + parseFloat(g.paddingLeft)) * x.x
              , _ = w.top + (m.clientTop + parseFloat(g.paddingTop)) * x.y;
            l *= x.x,
            c *= x.y,
            u *= x.x,
            h *= x.y,
            l += v,
            c += _,
            b = Mt(m),
            m = Nh(b)
        }
    }
    return _c({
        width: u,
        height: h,
        x: l,
        y: c
    })
}
function Rp(t, e) {
    const r = lu(t).scrollLeft;
    return e ? e.left + r : Is($r(t)).left + r
}
function mx(t, e, r) {
    r === void 0 && (r = !1);
    const n = t.getBoundingClientRect()
      , s = n.left + e.scrollLeft - (r ? 0 : Rp(t, n))
      , i = n.top + e.scrollTop;
    return {
        x: s,
        y: i
    }
}
function rR(t) {
    let {elements: e, rect: r, offsetParent: n, strategy: s} = t;
    const i = s === "fixed"
      , o = $r(n)
      , a = e ? au(e.floating) : !1;
    if (n === o || a && i)
        return r;
    let l = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , c = Or(1);
    const u = Or(0)
      , h = Lr(n);
    if ((h || !h && !i) && ((vo(n) !== "body" || Ha(o)) && (l = lu(n)),
    Lr(n))) {
        const f = Is(n);
        c = Oi(n),
        u.x = f.x + n.clientLeft,
        u.y = f.y + n.clientTop
    }
    const p = o && !h && !i ? mx(o, l, !0) : Or(0);
    return {
        width: r.width * c.x,
        height: r.height * c.y,
        x: r.x * c.x - l.scrollLeft * c.x + u.x + p.x,
        y: r.y * c.y - l.scrollTop * c.y + u.y + p.y
    }
}
function nR(t) {
    return Array.from(t.getClientRects())
}
function sR(t) {
    const e = $r(t)
      , r = lu(t)
      , n = t.ownerDocument.body
      , s = At(e.scrollWidth, e.clientWidth, n.scrollWidth, n.clientWidth)
      , i = At(e.scrollHeight, e.clientHeight, n.scrollHeight, n.clientHeight);
    let o = -r.scrollLeft + Rp(t);
    const a = -r.scrollTop;
    return br(n).direction === "rtl" && (o += At(e.clientWidth, n.clientWidth) - s),
    {
        width: s,
        height: i,
        x: o,
        y: a
    }
}
function iR(t, e) {
    const r = Mt(t)
      , n = $r(t)
      , s = r.visualViewport;
    let i = n.clientWidth
      , o = n.clientHeight
      , a = 0
      , l = 0;
    if (s) {
        i = s.width,
        o = s.height;
        const c = Cp();
        (!c || c && e === "fixed") && (a = s.offsetLeft,
        l = s.offsetTop)
    }
    return {
        width: i,
        height: o,
        x: a,
        y: l
    }
}
const oR = new Set(["absolute", "fixed"]);
function aR(t, e) {
    const r = Is(t, !0, e === "fixed")
      , n = r.top + t.clientTop
      , s = r.left + t.clientLeft
      , i = Lr(t) ? Oi(t) : Or(1)
      , o = t.clientWidth * i.x
      , a = t.clientHeight * i.y
      , l = s * i.x
      , c = n * i.y;
    return {
        width: o,
        height: a,
        x: l,
        y: c
    }
}
function jg(t, e, r) {
    let n;
    if (e === "viewport")
        n = iR(t, r);
    else if (e === "document")
        n = sR($r(t));
    else if (xr(e))
        n = aR(e, r);
    else {
        const s = px(t);
        n = {
            x: e.x - s.x,
            y: e.y - s.y,
            width: e.width,
            height: e.height
        }
    }
    return _c(n)
}
function gx(t, e) {
    const r = Gn(t);
    return r === e || !xr(r) || no(r) ? !1 : br(r).position === "fixed" || gx(r, e)
}
function lR(t, e) {
    const r = e.get(t);
    if (r)
        return r;
    let n = wa(t, [], !1).filter(a => xr(a) && vo(a) !== "body")
      , s = null;
    const i = br(t).position === "fixed";
    let o = i ? Gn(t) : t;
    for (; xr(o) && !no(o); ) {
        const a = br(o)
          , l = Ep(o);
        !l && a.position === "fixed" && (s = null),
        (i ? !l && !s : !l && a.position === "static" && !!s && oR.has(s.position) || Ha(o) && !l && gx(t, o)) ? n = n.filter(u => u !== o) : s = a,
        o = Gn(o)
    }
    return e.set(t, n),
    n
}
function cR(t) {
    let {element: e, boundary: r, rootBoundary: n, strategy: s} = t;
    const o = [...r === "clippingAncestors" ? au(e) ? [] : lR(e, this._c) : [].concat(r), n]
      , a = o[0]
      , l = o.reduce( (c, u) => {
        const h = jg(e, u, s);
        return c.top = At(h.top, c.top),
        c.right = qn(h.right, c.right),
        c.bottom = qn(h.bottom, c.bottom),
        c.left = At(h.left, c.left),
        c
    }
    , jg(e, a, s));
    return {
        width: l.right - l.left,
        height: l.bottom - l.top,
        x: l.left,
        y: l.top
    }
}
function uR(t) {
    const {width: e, height: r} = fx(t);
    return {
        width: e,
        height: r
    }
}
function dR(t, e, r) {
    const n = Lr(e)
      , s = $r(e)
      , i = r === "fixed"
      , o = Is(t, !0, i, e);
    let a = {
        scrollLeft: 0,
        scrollTop: 0
    };
    const l = Or(0);
    function c() {
        l.x = Rp(s)
    }
    if (n || !n && !i)
        if ((vo(e) !== "body" || Ha(s)) && (a = lu(e)),
        n) {
            const f = Is(e, !0, i, e);
            l.x = f.x + e.clientLeft,
            l.y = f.y + e.clientTop
        } else
            s && c();
    i && !n && s && c();
    const u = s && !n && !i ? mx(s, a) : Or(0)
      , h = o.left + a.scrollLeft - l.x - u.x
      , p = o.top + a.scrollTop - l.y - u.y;
    return {
        x: h,
        y: p,
        width: o.width,
        height: o.height
    }
}
function od(t) {
    return br(t).position === "static"
}
function Og(t, e) {
    if (!Lr(t) || br(t).position === "fixed")
        return null;
    if (e)
        return e(t);
    let r = t.offsetParent;
    return $r(t) === r && (r = r.ownerDocument.body),
    r
}
function vx(t, e) {
    const r = Mt(t);
    if (au(t))
        return r;
    if (!Lr(t)) {
        let s = Gn(t);
        for (; s && !no(s); ) {
            if (xr(s) && !od(s))
                return s;
            s = Gn(s)
        }
        return r
    }
    let n = Og(t, e);
    for (; n && qT(n) && od(n); )
        n = Og(n, e);
    return n && no(n) && od(n) && !Ep(n) ? r : n || YT(t) || r
}
const hR = async function(t) {
    const e = this.getOffsetParent || vx
      , r = this.getDimensions
      , n = await r(t.floating);
    return {
        reference: dR(t.reference, await e(t.floating), t.strategy),
        floating: {
            x: 0,
            y: 0,
            width: n.width,
            height: n.height
        }
    }
};
function fR(t) {
    return br(t).direction === "rtl"
}
const pR = {
    convertOffsetParentRelativeRectToViewportRelativeRect: rR,
    getDocumentElement: $r,
    getClippingRect: cR,
    getOffsetParent: vx,
    getElementRects: hR,
    getClientRects: nR,
    getDimensions: uR,
    getScale: Oi,
    isElement: xr,
    isRTL: fR
};
function yx(t, e) {
    return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height
}
function mR(t, e) {
    let r = null, n;
    const s = $r(t);
    function i() {
        var a;
        clearTimeout(n),
        (a = r) == null || a.disconnect(),
        r = null
    }
    function o(a, l) {
        a === void 0 && (a = !1),
        l === void 0 && (l = 1),
        i();
        const c = t.getBoundingClientRect()
          , {left: u, top: h, width: p, height: f} = c;
        if (a || e(),
        !p || !f)
            return;
        const b = wl(h)
          , m = wl(s.clientWidth - (u + p))
          , x = wl(s.clientHeight - (h + f))
          , w = wl(u)
          , v = {
            rootMargin: -b + "px " + -m + "px " + -x + "px " + -w + "px",
            threshold: At(0, qn(1, l)) || 1
        };
        let _ = !0;
        function S(k) {
            const C = k[0].intersectionRatio;
            if (C !== l) {
                if (!_)
                    return o();
                C ? o(!1, C) : n = setTimeout( () => {
                    o(!1, 1e-7)
                }
                , 1e3)
            }
            C === 1 && !yx(c, t.getBoundingClientRect()) && o(),
            _ = !1
        }
        try {
            r = new IntersectionObserver(S,{
                ...v,
                root: s.ownerDocument
            })
        } catch {
            r = new IntersectionObserver(S,v)
        }
        r.observe(t)
    }
    return o(!0),
    i
}
function gR(t, e, r, n) {
    n === void 0 && (n = {});
    const {ancestorScroll: s=!0, ancestorResize: i=!0, elementResize: o=typeof ResizeObserver == "function", layoutShift: a=typeof IntersectionObserver == "function", animationFrame: l=!1} = n
      , c = Tp(t)
      , u = s || i ? [...c ? wa(c) : [], ...wa(e)] : [];
    u.forEach(w => {
        s && w.addEventListener("scroll", r, {
            passive: !0
        }),
        i && w.addEventListener("resize", r)
    }
    );
    const h = c && a ? mR(c, r) : null;
    let p = -1
      , f = null;
    o && (f = new ResizeObserver(w => {
        let[g] = w;
        g && g.target === c && f && (f.unobserve(e),
        cancelAnimationFrame(p),
        p = requestAnimationFrame( () => {
            var v;
            (v = f) == null || v.observe(e)
        }
        )),
        r()
    }
    ),
    c && !l && f.observe(c),
    f.observe(e));
    let b, m = l ? Is(t) : null;
    l && x();
    function x() {
        const w = Is(t);
        m && !yx(m, w) && r(),
        m = w,
        b = requestAnimationFrame(x)
    }
    return r(),
    () => {
        var w;
        u.forEach(g => {
            s && g.removeEventListener("scroll", r),
            i && g.removeEventListener("resize", r)
        }
        ),
        h == null || h(),
        (w = f) == null || w.disconnect(),
        f = null,
        l && cancelAnimationFrame(b)
    }
}
const vR = BT
  , yR = zT
  , wR = MT
  , xR = WT
  , bR = FT
  , Ig = DT
  , _R = VT
  , SR = (t, e, r) => {
    const n = new Map
      , s = {
        platform: pR,
        ...r
    }
      , i = {
        ...s.platform,
        _c: n
    };
    return $T(t, e, {
        ...s,
        platform: i
    })
}
;
var kR = typeof document < "u"
  , ER = function() {}
  , Hl = kR ? y.useLayoutEffect : ER;
function Sc(t, e) {
    if (t === e)
        return !0;
    if (typeof t != typeof e)
        return !1;
    if (typeof t == "function" && t.toString() === e.toString())
        return !0;
    let r, n, s;
    if (t && e && typeof t == "object") {
        if (Array.isArray(t)) {
            if (r = t.length,
            r !== e.length)
                return !1;
            for (n = r; n-- !== 0; )
                if (!Sc(t[n], e[n]))
                    return !1;
            return !0
        }
        if (s = Object.keys(t),
        r = s.length,
        r !== Object.keys(e).length)
            return !1;
        for (n = r; n-- !== 0; )
            if (!{}.hasOwnProperty.call(e, s[n]))
                return !1;
        for (n = r; n-- !== 0; ) {
            const i = s[n];
            if (!(i === "_owner" && t.$$typeof) && !Sc(t[i], e[i]))
                return !1
        }
        return !0
    }
    return t !== t && e !== e
}
function wx(t) {
    return typeof window > "u" ? 1 : (t.ownerDocument.defaultView || window).devicePixelRatio || 1
}
function Lg(t, e) {
    const r = wx(t);
    return Math.round(e * r) / r
}
function ad(t) {
    const e = y.useRef(t);
    return Hl( () => {
        e.current = t
    }
    ),
    e
}
function CR(t) {
    t === void 0 && (t = {});
    const {placement: e="bottom", strategy: r="absolute", middleware: n=[], platform: s, elements: {reference: i, floating: o}={}, transform: a=!0, whileElementsMounted: l, open: c} = t
      , [u,h] = y.useState({
        x: 0,
        y: 0,
        strategy: r,
        placement: e,
        middlewareData: {},
        isPositioned: !1
    })
      , [p,f] = y.useState(n);
    Sc(p, n) || f(n);
    const [b,m] = y.useState(null)
      , [x,w] = y.useState(null)
      , g = y.useCallback(R => {
        R !== k.current && (k.current = R,
        m(R))
    }
    , [])
      , v = y.useCallback(R => {
        R !== C.current && (C.current = R,
        w(R))
    }
    , [])
      , _ = i || b
      , S = o || x
      , k = y.useRef(null)
      , C = y.useRef(null)
      , T = y.useRef(u)
      , A = l != null
      , P = ad(l)
      , B = ad(s)
      , L = ad(c)
      , G = y.useCallback( () => {
        if (!k.current || !C.current)
            return;
        const R = {
            placement: e,
            strategy: r,
            middleware: p
        };
        B.current && (R.platform = B.current),
        SR(k.current, C.current, R).then(N => {
            const D = {
                ...N,
                isPositioned: L.current !== !1
            };
            $.current && !Sc(T.current, D) && (T.current = D,
            Bs.flushSync( () => {
                h(D)
            }
            ))
        }
        )
    }
    , [p, e, r, B, L]);
    Hl( () => {
        c === !1 && T.current.isPositioned && (T.current.isPositioned = !1,
        h(R => ({
            ...R,
            isPositioned: !1
        })))
    }
    , [c]);
    const $ = y.useRef(!1);
    Hl( () => ($.current = !0,
    () => {
        $.current = !1
    }
    ), []),
    Hl( () => {
        if (_ && (k.current = _),
        S && (C.current = S),
        _ && S) {
            if (P.current)
                return P.current(_, S, G);
            G()
        }
    }
    , [_, S, G, P, A]);
    const Y = y.useMemo( () => ({
        reference: k,
        floating: C,
        setReference: g,
        setFloating: v
    }), [g, v])
      , U = y.useMemo( () => ({
        reference: _,
        floating: S
    }), [_, S])
      , Q = y.useMemo( () => {
        const R = {
            position: r,
            left: 0,
            top: 0
        };
        if (!U.floating)
            return R;
        const N = Lg(U.floating, u.x)
          , D = Lg(U.floating, u.y);
        return a ? {
            ...R,
            transform: "translate(" + N + "px, " + D + "px)",
            ...wx(U.floating) >= 1.5 && {
                willChange: "transform"
            }
        } : {
            position: r,
            left: N,
            top: D
        }
    }
    , [r, a, U.floating, u.x, u.y]);
    return y.useMemo( () => ({
        ...u,
        update: G,
        refs: Y,
        elements: U,
        floatingStyles: Q
    }), [u, G, Y, U, Q])
}
const TR = t => {
    function e(r) {
        return {}.hasOwnProperty.call(r, "current")
    }
    return {
        name: "arrow",
        options: t,
        fn(r) {
            const {element: n, padding: s} = typeof t == "function" ? t(r) : t;
            return n && e(n) ? n.current != null ? Ig({
                element: n.current,
                padding: s
            }).fn(r) : {} : n ? Ig({
                element: n,
                padding: s
            }).fn(r) : {}
        }
    }
}
  , RR = (t, e) => ({
    ...vR(t),
    options: [t, e]
})
  , NR = (t, e) => ({
    ...yR(t),
    options: [t, e]
})
  , PR = (t, e) => ({
    ..._R(t),
    options: [t, e]
})
  , AR = (t, e) => ({
    ...wR(t),
    options: [t, e]
})
  , jR = (t, e) => ({
    ...xR(t),
    options: [t, e]
})
  , OR = (t, e) => ({
    ...bR(t),
    options: [t, e]
})
  , IR = (t, e) => ({
    ...TR(t),
    options: [t, e]
});
var LR = "Arrow"
  , xx = y.forwardRef( (t, e) => {
    const {children: r, width: n=10, height: s=5, ...i} = t;
    return d.jsx(le.svg, {
        ...i,
        ref: e,
        width: n,
        height: s,
        viewBox: "0 0 30 10",
        preserveAspectRatio: "none",
        children: t.asChild ? r : d.jsx("polygon", {
            points: "0,0 30,0 15,10"
        })
    })
}
);
xx.displayName = LR;
var $R = xx;
function DR(t) {
    const [e,r] = y.useState(void 0);
    return et( () => {
        if (t) {
            r({
                width: t.offsetWidth,
                height: t.offsetHeight
            });
            const n = new ResizeObserver(s => {
                if (!Array.isArray(s) || !s.length)
                    return;
                const i = s[0];
                let o, a;
                if ("borderBoxSize"in i) {
                    const l = i.borderBoxSize
                      , c = Array.isArray(l) ? l[0] : l;
                    o = c.inlineSize,
                    a = c.blockSize
                } else
                    o = t.offsetWidth,
                    a = t.offsetHeight;
                r({
                    width: o,
                    height: a
                })
            }
            );
            return n.observe(t, {
                box: "border-box"
            }),
            () => n.unobserve(t)
        } else
            r(void 0)
    }
    , [t]),
    e
}
var Np = "Popper"
  , [bx,cu] = tn(Np)
  , [MR,_x] = bx(Np)
  , Sx = t => {
    const {__scopePopper: e, children: r} = t
      , [n,s] = y.useState(null);
    return d.jsx(MR, {
        scope: e,
        anchor: n,
        onAnchorChange: s,
        children: r
    })
}
;
Sx.displayName = Np;
var kx = "PopperAnchor"
  , Ex = y.forwardRef( (t, e) => {
    const {__scopePopper: r, virtualRef: n, ...s} = t
      , i = _x(kx, r)
      , o = y.useRef(null)
      , a = Ae(e, o);
    return y.useEffect( () => {
        i.onAnchorChange((n == null ? void 0 : n.current) || o.current)
    }
    ),
    n ? null : d.jsx(le.div, {
        ...s,
        ref: a
    })
}
);
Ex.displayName = kx;
var Pp = "PopperContent"
  , [FR,UR] = bx(Pp)
  , Cx = y.forwardRef( (t, e) => {
    var M, be, Fe, we, fe, ve;
    const {__scopePopper: r, side: n="bottom", sideOffset: s=0, align: i="center", alignOffset: o=0, arrowPadding: a=0, avoidCollisions: l=!0, collisionBoundary: c=[], collisionPadding: u=0, sticky: h="partial", hideWhenDetached: p=!1, updatePositionStrategy: f="optimized", onPlaced: b, ...m} = t
      , x = _x(Pp, r)
      , [w,g] = y.useState(null)
      , v = Ae(e, at => g(at))
      , [_,S] = y.useState(null)
      , k = DR(_)
      , C = (k == null ? void 0 : k.width) ?? 0
      , T = (k == null ? void 0 : k.height) ?? 0
      , A = n + (i !== "center" ? "-" + i : "")
      , P = typeof u == "number" ? u : {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0,
        ...u
    }
      , B = Array.isArray(c) ? c : [c]
      , L = B.length > 0
      , G = {
        padding: P,
        boundary: B.filter(zR),
        altBoundary: L
    }
      , {refs: $, floatingStyles: Y, placement: U, isPositioned: Q, middlewareData: R} = CR({
        strategy: "fixed",
        placement: A,
        whileElementsMounted: (...at) => gR(...at, {
            animationFrame: f === "always"
        }),
        elements: {
            reference: x.anchor
        },
        middleware: [RR({
            mainAxis: s + T,
            alignmentAxis: o
        }), l && NR({
            mainAxis: !0,
            crossAxis: !1,
            limiter: h === "partial" ? PR() : void 0,
            ...G
        }), l && AR({
            ...G
        }), jR({
            ...G,
            apply: ({elements: at, rects: Vt, availableWidth: ns, availableHeight: nn}) => {
                const {width: ss, height: bo} = Vt.reference
                  , Hs = at.floating.style;
                Hs.setProperty("--radix-popper-available-width", `${ns}px`),
                Hs.setProperty("--radix-popper-available-height", `${nn}px`),
                Hs.setProperty("--radix-popper-anchor-width", `${ss}px`),
                Hs.setProperty("--radix-popper-anchor-height", `${bo}px`)
            }
        }), _ && IR({
            element: _,
            padding: a
        }), VR({
            arrowWidth: C,
            arrowHeight: T
        }), p && OR({
            strategy: "referenceHidden",
            ...G
        })]
    })
      , [N,D] = Nx(U)
      , ee = tr(b);
    et( () => {
        Q && (ee == null || ee())
    }
    , [Q, ee]);
    const q = (M = R.arrow) == null ? void 0 : M.x
      , oe = (be = R.arrow) == null ? void 0 : be.y
      , se = ((Fe = R.arrow) == null ? void 0 : Fe.centerOffset) !== 0
      , [Te,Me] = y.useState();
    return et( () => {
        w && Me(window.getComputedStyle(w).zIndex)
    }
    , [w]),
    d.jsx("div", {
        ref: $.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
            ...Y,
            transform: Q ? Y.transform : "translate(0, -200%)",
            minWidth: "max-content",
            zIndex: Te,
            "--radix-popper-transform-origin": [(we = R.transformOrigin) == null ? void 0 : we.x, (fe = R.transformOrigin) == null ? void 0 : fe.y].join(" "),
            ...((ve = R.hide) == null ? void 0 : ve.referenceHidden) && {
                visibility: "hidden",
                pointerEvents: "none"
            }
        },
        dir: t.dir,
        children: d.jsx(FR, {
            scope: r,
            placedSide: N,
            onArrowChange: S,
            arrowX: q,
            arrowY: oe,
            shouldHideArrow: se,
            children: d.jsx(le.div, {
                "data-side": N,
                "data-align": D,
                ...m,
                ref: v,
                style: {
                    ...m.style,
                    animation: Q ? void 0 : "none"
                }
            })
        })
    })
}
);
Cx.displayName = Pp;
var Tx = "PopperArrow"
  , BR = {
    top: "bottom",
    right: "left",
    bottom: "top",
    left: "right"
}
  , Rx = y.forwardRef(function(e, r) {
    const {__scopePopper: n, ...s} = e
      , i = UR(Tx, n)
      , o = BR[i.placedSide];
    return d.jsx("span", {
        ref: i.onArrowChange,
        style: {
            position: "absolute",
            left: i.arrowX,
            top: i.arrowY,
            [o]: 0,
            transformOrigin: {
                top: "",
                right: "0 0",
                bottom: "center 0",
                left: "100% 0"
            }[i.placedSide],
            transform: {
                top: "translateY(100%)",
                right: "translateY(50%) rotate(90deg) translateX(-50%)",
                bottom: "rotate(180deg)",
                left: "translateY(50%) rotate(-90deg) translateX(50%)"
            }[i.placedSide],
            visibility: i.shouldHideArrow ? "hidden" : void 0
        },
        children: d.jsx($R, {
            ...s,
            ref: r,
            style: {
                ...s.style,
                display: "block"
            }
        })
    })
});
Rx.displayName = Tx;
function zR(t) {
    return t !== null
}
var VR = t => ({
    name: "transformOrigin",
    options: t,
    fn(e) {
        var x, w, g;
        const {placement: r, rects: n, middlewareData: s} = e
          , o = ((x = s.arrow) == null ? void 0 : x.centerOffset) !== 0
          , a = o ? 0 : t.arrowWidth
          , l = o ? 0 : t.arrowHeight
          , [c,u] = Nx(r)
          , h = {
            start: "0%",
            center: "50%",
            end: "100%"
        }[u]
          , p = (((w = s.arrow) == null ? void 0 : w.x) ?? 0) + a / 2
          , f = (((g = s.arrow) == null ? void 0 : g.y) ?? 0) + l / 2;
        let b = ""
          , m = "";
        return c === "bottom" ? (b = o ? h : `${p}px`,
        m = `${-l}px`) : c === "top" ? (b = o ? h : `${p}px`,
        m = `${n.floating.height + l}px`) : c === "right" ? (b = `${-l}px`,
        m = o ? h : `${f}px`) : c === "left" && (b = `${n.floating.width + l}px`,
        m = o ? h : `${f}px`),
        {
            data: {
                x: b,
                y: m
            }
        }
    }
});
function Nx(t) {
    const [e,r="center"] = t.split("-");
    return [e, r]
}
var WR = Sx
  , Px = Ex
  , Ax = Cx
  , jx = Rx
  , [uu,jL] = tn("Tooltip", [cu])
  , Ap = cu()
  , Ox = "TooltipProvider"
  , HR = 700
  , $g = "tooltip.open"
  , [KR,Ix] = uu(Ox)
  , Lx = t => {
    const {__scopeTooltip: e, delayDuration: r=HR, skipDelayDuration: n=300, disableHoverableContent: s=!1, children: i} = t
      , o = y.useRef(!0)
      , a = y.useRef(!1)
      , l = y.useRef(0);
    return y.useEffect( () => {
        const c = l.current;
        return () => window.clearTimeout(c)
    }
    , []),
    d.jsx(KR, {
        scope: e,
        isOpenDelayedRef: o,
        delayDuration: r,
        onOpen: y.useCallback( () => {
            window.clearTimeout(l.current),
            o.current = !1
        }
        , []),
        onClose: y.useCallback( () => {
            window.clearTimeout(l.current),
            l.current = window.setTimeout( () => o.current = !0, n)
        }
        , [n]),
        isPointerInTransitRef: a,
        onPointerInTransitChange: y.useCallback(c => {
            a.current = c
        }
        , []),
        disableHoverableContent: s,
        children: i
    })
}
;
Lx.displayName = Ox;
var $x = "Tooltip"
  , [OL,du] = uu($x)
  , Ph = "TooltipTrigger"
  , qR = y.forwardRef( (t, e) => {
    const {__scopeTooltip: r, ...n} = t
      , s = du(Ph, r)
      , i = Ix(Ph, r)
      , o = Ap(r)
      , a = y.useRef(null)
      , l = Ae(e, a, s.onTriggerChange)
      , c = y.useRef(!1)
      , u = y.useRef(!1)
      , h = y.useCallback( () => c.current = !1, []);
    return y.useEffect( () => () => document.removeEventListener("pointerup", h), [h]),
    d.jsx(Px, {
        asChild: !0,
        ...o,
        children: d.jsx(le.button, {
            "aria-describedby": s.open ? s.contentId : void 0,
            "data-state": s.stateAttribute,
            ...n,
            ref: l,
            onPointerMove: te(t.onPointerMove, p => {
                p.pointerType !== "touch" && !u.current && !i.isPointerInTransitRef.current && (s.onTriggerEnter(),
                u.current = !0)
            }
            ),
            onPointerLeave: te(t.onPointerLeave, () => {
                s.onTriggerLeave(),
                u.current = !1
            }
            ),
            onPointerDown: te(t.onPointerDown, () => {
                s.open && s.onClose(),
                c.current = !0,
                document.addEventListener("pointerup", h, {
                    once: !0
                })
            }
            ),
            onFocus: te(t.onFocus, () => {
                c.current || s.onOpen()
            }
            ),
            onBlur: te(t.onBlur, s.onClose),
            onClick: te(t.onClick, s.onClose)
        })
    })
}
);
qR.displayName = Ph;
var GR = "TooltipPortal"
  , [IL,QR] = uu(GR, {
    forceMount: void 0
})
  , so = "TooltipContent"
  , Dx = y.forwardRef( (t, e) => {
    const r = QR(so, t.__scopeTooltip)
      , {forceMount: n=r.forceMount, side: s="top", ...i} = t
      , o = du(so, t.__scopeTooltip);
    return d.jsx(za, {
        present: n || o.open,
        children: o.disableHoverableContent ? d.jsx(Mx, {
            side: s,
            ...i,
            ref: e
        }) : d.jsx(JR, {
            side: s,
            ...i,
            ref: e
        })
    })
}
)
  , JR = y.forwardRef( (t, e) => {
    const r = du(so, t.__scopeTooltip)
      , n = Ix(so, t.__scopeTooltip)
      , s = y.useRef(null)
      , i = Ae(e, s)
      , [o,a] = y.useState(null)
      , {trigger: l, onClose: c} = r
      , u = s.current
      , {onPointerInTransitChange: h} = n
      , p = y.useCallback( () => {
        a(null),
        h(!1)
    }
    , [h])
      , f = y.useCallback( (b, m) => {
        const x = b.currentTarget
          , w = {
            x: b.clientX,
            y: b.clientY
        }
          , g = tN(w, x.getBoundingClientRect())
          , v = rN(w, g)
          , _ = nN(m.getBoundingClientRect())
          , S = iN([...v, ..._]);
        a(S),
        h(!0)
    }
    , [h]);
    return y.useEffect( () => () => p(), [p]),
    y.useEffect( () => {
        if (l && u) {
            const b = x => f(x, u)
              , m = x => f(x, l);
            return l.addEventListener("pointerleave", b),
            u.addEventListener("pointerleave", m),
            () => {
                l.removeEventListener("pointerleave", b),
                u.removeEventListener("pointerleave", m)
            }
        }
    }
    , [l, u, f, p]),
    y.useEffect( () => {
        if (o) {
            const b = m => {
                const x = m.target
                  , w = {
                    x: m.clientX,
                    y: m.clientY
                }
                  , g = (l == null ? void 0 : l.contains(x)) || (u == null ? void 0 : u.contains(x))
                  , v = !sN(w, o);
                g ? p() : v && (p(),
                c())
            }
            ;
            return document.addEventListener("pointermove", b),
            () => document.removeEventListener("pointermove", b)
        }
    }
    , [l, u, o, c, p]),
    d.jsx(Mx, {
        ...t,
        ref: i
    })
}
)
  , [ZR,YR] = uu($x, {
    isInside: !1
})
  , XR = iE("TooltipContent")
  , Mx = y.forwardRef( (t, e) => {
    const {__scopeTooltip: r, children: n, "aria-label": s, onEscapeKeyDown: i, onPointerDownOutside: o, ...a} = t
      , l = du(so, r)
      , c = Ap(r)
      , {onClose: u} = l;
    return y.useEffect( () => (document.addEventListener($g, u),
    () => document.removeEventListener($g, u)), [u]),
    y.useEffect( () => {
        if (l.trigger) {
            const h = p => {
                const f = p.target;
                f != null && f.contains(l.trigger) && u()
            }
            ;
            return window.addEventListener("scroll", h, {
                capture: !0
            }),
            () => window.removeEventListener("scroll", h, {
                capture: !0
            })
        }
    }
    , [l.trigger, u]),
    d.jsx(ru, {
        asChild: !0,
        disableOutsidePointerEvents: !1,
        onEscapeKeyDown: i,
        onPointerDownOutside: o,
        onFocusOutside: h => h.preventDefault(),
        onDismiss: u,
        children: d.jsxs(Ax, {
            "data-state": l.stateAttribute,
            ...c,
            ...a,
            ref: e,
            style: {
                ...a.style,
                "--radix-tooltip-content-transform-origin": "var(--radix-popper-transform-origin)",
                "--radix-tooltip-content-available-width": "var(--radix-popper-available-width)",
                "--radix-tooltip-content-available-height": "var(--radix-popper-available-height)",
                "--radix-tooltip-trigger-width": "var(--radix-popper-anchor-width)",
                "--radix-tooltip-trigger-height": "var(--radix-popper-anchor-height)"
            },
            children: [d.jsx(XR, {
                children: n
            }), d.jsx(ZR, {
                scope: r,
                isInside: !0,
                children: d.jsx(TE, {
                    id: l.contentId,
                    role: "tooltip",
                    children: s || n
                })
            })]
        })
    })
}
);
Dx.displayName = so;
var Fx = "TooltipArrow"
  , eN = y.forwardRef( (t, e) => {
    const {__scopeTooltip: r, ...n} = t
      , s = Ap(r);
    return YR(Fx, r).isInside ? null : d.jsx(jx, {
        ...s,
        ...n,
        ref: e
    })
}
);
eN.displayName = Fx;
function tN(t, e) {
    const r = Math.abs(e.top - t.y)
      , n = Math.abs(e.bottom - t.y)
      , s = Math.abs(e.right - t.x)
      , i = Math.abs(e.left - t.x);
    switch (Math.min(r, n, s, i)) {
    case i:
        return "left";
    case s:
        return "right";
    case r:
        return "top";
    case n:
        return "bottom";
    default:
        throw new Error("unreachable")
    }
}
function rN(t, e, r=5) {
    const n = [];
    switch (e) {
    case "top":
        n.push({
            x: t.x - r,
            y: t.y + r
        }, {
            x: t.x + r,
            y: t.y + r
        });
        break;
    case "bottom":
        n.push({
            x: t.x - r,
            y: t.y - r
        }, {
            x: t.x + r,
            y: t.y - r
        });
        break;
    case "left":
        n.push({
            x: t.x + r,
            y: t.y - r
        }, {
            x: t.x + r,
            y: t.y + r
        });
        break;
    case "right":
        n.push({
            x: t.x - r,
            y: t.y - r
        }, {
            x: t.x - r,
            y: t.y + r
        });
        break
    }
    return n
}
function nN(t) {
    const {top: e, right: r, bottom: n, left: s} = t;
    return [{
        x: s,
        y: e
    }, {
        x: r,
        y: e
    }, {
        x: r,
        y: n
    }, {
        x: s,
        y: n
    }]
}
function sN(t, e) {
    const {x: r, y: n} = t;
    let s = !1;
    for (let i = 0, o = e.length - 1; i < e.length; o = i++) {
        const a = e[i]
          , l = e[o]
          , c = a.x
          , u = a.y
          , h = l.x
          , p = l.y;
        u > n != p > n && r < (h - c) * (n - u) / (p - u) + c && (s = !s)
    }
    return s
}
function iN(t) {
    const e = t.slice();
    return e.sort( (r, n) => r.x < n.x ? -1 : r.x > n.x ? 1 : r.y < n.y ? -1 : r.y > n.y ? 1 : 0),
    oN(e)
}
function oN(t) {
    if (t.length <= 1)
        return t.slice();
    const e = [];
    for (let n = 0; n < t.length; n++) {
        const s = t[n];
        for (; e.length >= 2; ) {
            const i = e[e.length - 1]
              , o = e[e.length - 2];
            if ((i.x - o.x) * (s.y - o.y) >= (i.y - o.y) * (s.x - o.x))
                e.pop();
            else
                break
        }
        e.push(s)
    }
    e.pop();
    const r = [];
    for (let n = t.length - 1; n >= 0; n--) {
        const s = t[n];
        for (; r.length >= 2; ) {
            const i = r[r.length - 1]
              , o = r[r.length - 2];
            if ((i.x - o.x) * (s.y - o.y) >= (i.y - o.y) * (s.x - o.x))
                r.pop();
            else
                break
        }
        r.push(s)
    }
    return r.pop(),
    e.length === 1 && r.length === 1 && e[0].x === r[0].x && e[0].y === r[0].y ? e : e.concat(r)
}
var aN = Lx
  , Ux = Dx;
const lN = aN
  , cN = y.forwardRef( ({className: t, sideOffset: e=4, ...r}, n) => d.jsx(Ux, {
    ref: n,
    sideOffset: e,
    className: me("z-50 overflow-hidden rounded-md border bg-popover px-3 py-1.5 text-sm text-popover-foreground shadow-md animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", t),
    ...r
}));
cN.displayName = Ux.displayName;
var Ka = class {
    constructor() {
        this.listeners = new Set,
        this.subscribe = this.subscribe.bind(this)
    }
    subscribe(t) {
        return this.listeners.add(t),
        this.onSubscribe(),
        () => {
            this.listeners.delete(t),
            this.onUnsubscribe()
        }
    }
    hasListeners() {
        return this.listeners.size > 0
    }
    onSubscribe() {}
    onUnsubscribe() {}
}
  , Ls = typeof window > "u" || "Deno"in globalThis;
function _t() {}
function uN(t, e) {
    return typeof t == "function" ? t(e) : t
}
function Ah(t) {
    return typeof t == "number" && t >= 0 && t !== 1 / 0
}
function Bx(t, e) {
    return Math.max(t + (e || 0) - Date.now(), 0)
}
function Bn(t, e) {
    return typeof t == "function" ? t(e) : t
}
function Kt(t, e) {
    return typeof t == "function" ? t(e) : t
}
function Dg(t, e) {
    const {type: r="all", exact: n, fetchStatus: s, predicate: i, queryKey: o, stale: a} = t;
    if (o) {
        if (n) {
            if (e.queryHash !== jp(o, e.options))
                return !1
        } else if (!ba(e.queryKey, o))
            return !1
    }
    if (r !== "all") {
        const l = e.isActive();
        if (r === "active" && !l || r === "inactive" && l)
            return !1
    }
    return !(typeof a == "boolean" && e.isStale() !== a || s && s !== e.state.fetchStatus || i && !i(e))
}
function Mg(t, e) {
    const {exact: r, status: n, predicate: s, mutationKey: i} = t;
    if (i) {
        if (!e.options.mutationKey)
            return !1;
        if (r) {
            if (xa(e.options.mutationKey) !== xa(i))
                return !1
        } else if (!ba(e.options.mutationKey, i))
            return !1
    }
    return !(n && e.state.status !== n || s && !s(e))
}
function jp(t, e) {
    return ((e == null ? void 0 : e.queryKeyHashFn) || xa)(t)
}
function xa(t) {
    return JSON.stringify(t, (e, r) => Oh(r) ? Object.keys(r).sort().reduce( (n, s) => (n[s] = r[s],
    n), {}) : r)
}
function ba(t, e) {
    return t === e ? !0 : typeof t != typeof e ? !1 : t && e && typeof t == "object" && typeof e == "object" ? Object.keys(e).every(r => ba(t[r], e[r])) : !1
}
function zx(t, e) {
    if (t === e)
        return t;
    const r = Fg(t) && Fg(e);
    if (r || Oh(t) && Oh(e)) {
        const n = r ? t : Object.keys(t)
          , s = n.length
          , i = r ? e : Object.keys(e)
          , o = i.length
          , a = r ? [] : {}
          , l = new Set(n);
        let c = 0;
        for (let u = 0; u < o; u++) {
            const h = r ? u : i[u];
            (!r && l.has(h) || r) && t[h] === void 0 && e[h] === void 0 ? (a[h] = void 0,
            c++) : (a[h] = zx(t[h], e[h]),
            a[h] === t[h] && t[h] !== void 0 && c++)
        }
        return s === o && c === s ? t : a
    }
    return e
}
function jh(t, e) {
    if (!e || Object.keys(t).length !== Object.keys(e).length)
        return !1;
    for (const r in t)
        if (t[r] !== e[r])
            return !1;
    return !0
}
function Fg(t) {
    return Array.isArray(t) && t.length === Object.keys(t).length
}
function Oh(t) {
    if (!Ug(t))
        return !1;
    const e = t.constructor;
    if (e === void 0)
        return !0;
    const r = e.prototype;
    return !(!Ug(r) || !r.hasOwnProperty("isPrototypeOf") || Object.getPrototypeOf(t) !== Object.prototype)
}
function Ug(t) {
    return Object.prototype.toString.call(t) === "[object Object]"
}
function dN(t) {
    return new Promise(e => {
        setTimeout(e, t)
    }
    )
}
function Ih(t, e, r) {
    return typeof r.structuralSharing == "function" ? r.structuralSharing(t, e) : r.structuralSharing !== !1 ? zx(t, e) : e
}
function hN(t, e, r=0) {
    const n = [...t, e];
    return r && n.length > r ? n.slice(1) : n
}
function fN(t, e, r=0) {
    const n = [e, ...t];
    return r && n.length > r ? n.slice(0, -1) : n
}
var Op = Symbol();
function Vx(t, e) {
    return !t.queryFn && (e != null && e.initialPromise) ? () => e.initialPromise : !t.queryFn || t.queryFn === Op ? () => Promise.reject(new Error(`Missing queryFn: '${t.queryHash}'`)) : t.queryFn
}
function pN(t, e) {
    return typeof t == "function" ? t(...e) : !!t
}
var ys, xn, Mi, Yv, mN = (Yv = class extends Ka {
    constructor() {
        super();
        X(this, ys);
        X(this, xn);
        X(this, Mi);
        V(this, Mi, e => {
            if (!Ls && window.addEventListener) {
                const r = () => e();
                return window.addEventListener("visibilitychange", r, !1),
                () => {
                    window.removeEventListener("visibilitychange", r)
                }
            }
        }
        )
    }
    onSubscribe() {
        E(this, xn) || this.setEventListener(E(this, Mi))
    }
    onUnsubscribe() {
        var e;
        this.hasListeners() || ((e = E(this, xn)) == null || e.call(this),
        V(this, xn, void 0))
    }
    setEventListener(e) {
        var r;
        V(this, Mi, e),
        (r = E(this, xn)) == null || r.call(this),
        V(this, xn, e(n => {
            typeof n == "boolean" ? this.setFocused(n) : this.onFocus()
        }
        ))
    }
    setFocused(e) {
        E(this, ys) !== e && (V(this, ys, e),
        this.onFocus())
    }
    onFocus() {
        const e = this.isFocused();
        this.listeners.forEach(r => {
            r(e)
        }
        )
    }
    isFocused() {
        var e;
        return typeof E(this, ys) == "boolean" ? E(this, ys) : ((e = globalThis.document) == null ? void 0 : e.visibilityState) !== "hidden"
    }
}
,
ys = new WeakMap,
xn = new WeakMap,
Mi = new WeakMap,
Yv), Ip = new mN, Fi, bn, Ui, Xv, gN = (Xv = class extends Ka {
    constructor() {
        super();
        X(this, Fi, !0);
        X(this, bn);
        X(this, Ui);
        V(this, Ui, e => {
            if (!Ls && window.addEventListener) {
                const r = () => e(!0)
                  , n = () => e(!1);
                return window.addEventListener("online", r, !1),
                window.addEventListener("offline", n, !1),
                () => {
                    window.removeEventListener("online", r),
                    window.removeEventListener("offline", n)
                }
            }
        }
        )
    }
    onSubscribe() {
        E(this, bn) || this.setEventListener(E(this, Ui))
    }
    onUnsubscribe() {
        var e;
        this.hasListeners() || ((e = E(this, bn)) == null || e.call(this),
        V(this, bn, void 0))
    }
    setEventListener(e) {
        var r;
        V(this, Ui, e),
        (r = E(this, bn)) == null || r.call(this),
        V(this, bn, e(this.setOnline.bind(this)))
    }
    setOnline(e) {
        E(this, Fi) !== e && (V(this, Fi, e),
        this.listeners.forEach(n => {
            n(e)
        }
        ))
    }
    isOnline() {
        return E(this, Fi)
    }
}
,
Fi = new WeakMap,
bn = new WeakMap,
Ui = new WeakMap,
Xv), kc = new gN;
function Lh() {
    let t, e;
    const r = new Promise( (s, i) => {
        t = s,
        e = i
    }
    );
    r.status = "pending",
    r.catch( () => {}
    );
    function n(s) {
        Object.assign(r, s),
        delete r.resolve,
        delete r.reject
    }
    return r.resolve = s => {
        n({
            status: "fulfilled",
            value: s
        }),
        t(s)
    }
    ,
    r.reject = s => {
        n({
            status: "rejected",
            reason: s
        }),
        e(s)
    }
    ,
    r
}
function vN(t) {
    return Math.min(1e3 * 2 ** t, 3e4)
}
function Wx(t) {
    return (t ?? "online") === "online" ? kc.isOnline() : !0
}
var Hx = class extends Error {
    constructor(t) {
        super("CancelledError"),
        this.revert = t == null ? void 0 : t.revert,
        this.silent = t == null ? void 0 : t.silent
    }
}
;
function ld(t) {
    return t instanceof Hx
}
function Kx(t) {
    let e = !1, r = 0, n = !1, s;
    const i = Lh()
      , o = m => {
        var x;
        n || (p(new Hx(m)),
        (x = t.abort) == null || x.call(t))
    }
      , a = () => {
        e = !0
    }
      , l = () => {
        e = !1
    }
      , c = () => Ip.isFocused() && (t.networkMode === "always" || kc.isOnline()) && t.canRun()
      , u = () => Wx(t.networkMode) && t.canRun()
      , h = m => {
        var x;
        n || (n = !0,
        (x = t.onSuccess) == null || x.call(t, m),
        s == null || s(),
        i.resolve(m))
    }
      , p = m => {
        var x;
        n || (n = !0,
        (x = t.onError) == null || x.call(t, m),
        s == null || s(),
        i.reject(m))
    }
      , f = () => new Promise(m => {
        var x;
        s = w => {
            (n || c()) && m(w)
        }
        ,
        (x = t.onPause) == null || x.call(t)
    }
    ).then( () => {
        var m;
        s = void 0,
        n || (m = t.onContinue) == null || m.call(t)
    }
    )
      , b = () => {
        if (n)
            return;
        let m;
        const x = r === 0 ? t.initialPromise : void 0;
        try {
            m = x ?? t.fn()
        } catch (w) {
            m = Promise.reject(w)
        }
        Promise.resolve(m).then(h).catch(w => {
            var k;
            if (n)
                return;
            const g = t.retry ?? (Ls ? 0 : 3)
              , v = t.retryDelay ?? vN
              , _ = typeof v == "function" ? v(r, w) : v
              , S = g === !0 || typeof g == "number" && r < g || typeof g == "function" && g(r, w);
            if (e || !S) {
                p(w);
                return
            }
            r++,
            (k = t.onFail) == null || k.call(t, r, w),
            dN(_).then( () => c() ? void 0 : f()).then( () => {
                e ? p(w) : b()
            }
            )
        }
        )
    }
    ;
    return {
        promise: i,
        cancel: o,
        continue: () => (s == null || s(),
        i),
        cancelRetry: a,
        continueRetry: l,
        canStart: u,
        start: () => (u() ? b() : f().then(b),
        i)
    }
}
var yN = t => setTimeout(t, 0);
function wN() {
    let t = []
      , e = 0
      , r = a => {
        a()
    }
      , n = a => {
        a()
    }
      , s = yN;
    const i = a => {
        e ? t.push(a) : s( () => {
            r(a)
        }
        )
    }
      , o = () => {
        const a = t;
        t = [],
        a.length && s( () => {
            n( () => {
                a.forEach(l => {
                    r(l)
                }
                )
            }
            )
        }
        )
    }
    ;
    return {
        batch: a => {
            let l;
            e++;
            try {
                l = a()
            } finally {
                e--,
                e || o()
            }
            return l
        }
        ,
        batchCalls: a => (...l) => {
            i( () => {
                a(...l)
            }
            )
        }
        ,
        schedule: i,
        setNotifyFunction: a => {
            r = a
        }
        ,
        setBatchNotifyFunction: a => {
            n = a
        }
        ,
        setScheduler: a => {
            s = a
        }
    }
}
var st = wN(), ws, ey, qx = (ey = class {
    constructor() {
        X(this, ws)
    }
    destroy() {
        this.clearGcTimeout()
    }
    scheduleGc() {
        this.clearGcTimeout(),
        Ah(this.gcTime) && V(this, ws, setTimeout( () => {
            this.optionalRemove()
        }
        , this.gcTime))
    }
    updateGcTime(t) {
        this.gcTime = Math.max(this.gcTime || 0, t ?? (Ls ? 1 / 0 : 5 * 60 * 1e3))
    }
    clearGcTimeout() {
        E(this, ws) && (clearTimeout(E(this, ws)),
        V(this, ws, void 0))
    }
}
,
ws = new WeakMap,
ey), Bi, xs, Ht, bs, ut, Oa, _s, hr, Mr, ty, xN = (ty = class extends qx {
    constructor(e) {
        super();
        X(this, hr);
        X(this, Bi);
        X(this, xs);
        X(this, Ht);
        X(this, bs);
        X(this, ut);
        X(this, Oa);
        X(this, _s);
        V(this, _s, !1),
        V(this, Oa, e.defaultOptions),
        this.setOptions(e.options),
        this.observers = [],
        V(this, bs, e.client),
        V(this, Ht, E(this, bs).getQueryCache()),
        this.queryKey = e.queryKey,
        this.queryHash = e.queryHash,
        V(this, Bi, bN(this.options)),
        this.state = e.state ?? E(this, Bi),
        this.scheduleGc()
    }
    get meta() {
        return this.options.meta
    }
    get promise() {
        var e;
        return (e = E(this, ut)) == null ? void 0 : e.promise
    }
    setOptions(e) {
        this.options = {
            ...E(this, Oa),
            ...e
        },
        this.updateGcTime(this.options.gcTime)
    }
    optionalRemove() {
        !this.observers.length && this.state.fetchStatus === "idle" && E(this, Ht).remove(this)
    }
    setData(e, r) {
        const n = Ih(this.state.data, e, this.options);
        return de(this, hr, Mr).call(this, {
            data: n,
            type: "success",
            dataUpdatedAt: r == null ? void 0 : r.updatedAt,
            manual: r == null ? void 0 : r.manual
        }),
        n
    }
    setState(e, r) {
        de(this, hr, Mr).call(this, {
            type: "setState",
            state: e,
            setStateOptions: r
        })
    }
    cancel(e) {
        var n, s;
        const r = (n = E(this, ut)) == null ? void 0 : n.promise;
        return (s = E(this, ut)) == null || s.cancel(e),
        r ? r.then(_t).catch(_t) : Promise.resolve()
    }
    destroy() {
        super.destroy(),
        this.cancel({
            silent: !0
        })
    }
    reset() {
        this.destroy(),
        this.setState(E(this, Bi))
    }
    isActive() {
        return this.observers.some(e => Kt(e.options.enabled, this) !== !1)
    }
    isDisabled() {
        return this.getObserversCount() > 0 ? !this.isActive() : this.options.queryFn === Op || this.state.dataUpdateCount + this.state.errorUpdateCount === 0
    }
    isStatic() {
        return this.getObserversCount() > 0 ? this.observers.some(e => Bn(e.options.staleTime, this) === "static") : !1
    }
    isStale() {
        return this.getObserversCount() > 0 ? this.observers.some(e => e.getCurrentResult().isStale) : this.state.data === void 0 || this.state.isInvalidated
    }
    isStaleByTime(e=0) {
        return this.state.data === void 0 ? !0 : e === "static" ? !1 : this.state.isInvalidated ? !0 : !Bx(this.state.dataUpdatedAt, e)
    }
    onFocus() {
        var r;
        const e = this.observers.find(n => n.shouldFetchOnWindowFocus());
        e == null || e.refetch({
            cancelRefetch: !1
        }),
        (r = E(this, ut)) == null || r.continue()
    }
    onOnline() {
        var r;
        const e = this.observers.find(n => n.shouldFetchOnReconnect());
        e == null || e.refetch({
            cancelRefetch: !1
        }),
        (r = E(this, ut)) == null || r.continue()
    }
    addObserver(e) {
        this.observers.includes(e) || (this.observers.push(e),
        this.clearGcTimeout(),
        E(this, Ht).notify({
            type: "observerAdded",
            query: this,
            observer: e
        }))
    }
    removeObserver(e) {
        this.observers.includes(e) && (this.observers = this.observers.filter(r => r !== e),
        this.observers.length || (E(this, ut) && (E(this, _s) ? E(this, ut).cancel({
            revert: !0
        }) : E(this, ut).cancelRetry()),
        this.scheduleGc()),
        E(this, Ht).notify({
            type: "observerRemoved",
            query: this,
            observer: e
        }))
    }
    getObserversCount() {
        return this.observers.length
    }
    invalidate() {
        this.state.isInvalidated || de(this, hr, Mr).call(this, {
            type: "invalidate"
        })
    }
    fetch(e, r) {
        var c, u, h;
        if (this.state.fetchStatus !== "idle") {
            if (this.state.data !== void 0 && (r != null && r.cancelRefetch))
                this.cancel({
                    silent: !0
                });
            else if (E(this, ut))
                return E(this, ut).continueRetry(),
                E(this, ut).promise
        }
        if (e && this.setOptions(e),
        !this.options.queryFn) {
            const p = this.observers.find(f => f.options.queryFn);
            p && this.setOptions(p.options)
        }
        const n = new AbortController
          , s = p => {
            Object.defineProperty(p, "signal", {
                enumerable: !0,
                get: () => (V(this, _s, !0),
                n.signal)
            })
        }
          , i = () => {
            const p = Vx(this.options, r)
              , b = ( () => {
                const m = {
                    client: E(this, bs),
                    queryKey: this.queryKey,
                    meta: this.meta
                };
                return s(m),
                m
            }
            )();
            return V(this, _s, !1),
            this.options.persister ? this.options.persister(p, b, this) : p(b)
        }
          , a = ( () => {
            const p = {
                fetchOptions: r,
                options: this.options,
                queryKey: this.queryKey,
                client: E(this, bs),
                state: this.state,
                fetchFn: i
            };
            return s(p),
            p
        }
        )();
        (c = this.options.behavior) == null || c.onFetch(a, this),
        V(this, xs, this.state),
        (this.state.fetchStatus === "idle" || this.state.fetchMeta !== ((u = a.fetchOptions) == null ? void 0 : u.meta)) && de(this, hr, Mr).call(this, {
            type: "fetch",
            meta: (h = a.fetchOptions) == null ? void 0 : h.meta
        });
        const l = p => {
            var f, b, m, x;
            ld(p) && p.silent || de(this, hr, Mr).call(this, {
                type: "error",
                error: p
            }),
            ld(p) || ((b = (f = E(this, Ht).config).onError) == null || b.call(f, p, this),
            (x = (m = E(this, Ht).config).onSettled) == null || x.call(m, this.state.data, p, this)),
            this.scheduleGc()
        }
        ;
        return V(this, ut, Kx({
            initialPromise: r == null ? void 0 : r.initialPromise,
            fn: a.fetchFn,
            abort: n.abort.bind(n),
            onSuccess: p => {
                var f, b, m, x;
                if (p === void 0) {
                    l(new Error(`${this.queryHash} data is undefined`));
                    return
                }
                try {
                    this.setData(p)
                } catch (w) {
                    l(w);
                    return
                }
                (b = (f = E(this, Ht).config).onSuccess) == null || b.call(f, p, this),
                (x = (m = E(this, Ht).config).onSettled) == null || x.call(m, p, this.state.error, this),
                this.scheduleGc()
            }
            ,
            onError: l,
            onFail: (p, f) => {
                de(this, hr, Mr).call(this, {
                    type: "failed",
                    failureCount: p,
                    error: f
                })
            }
            ,
            onPause: () => {
                de(this, hr, Mr).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: () => {
                de(this, hr, Mr).call(this, {
                    type: "continue"
                })
            }
            ,
            retry: a.options.retry,
            retryDelay: a.options.retryDelay,
            networkMode: a.options.networkMode,
            canRun: () => !0
        })),
        E(this, ut).start()
    }
}
,
Bi = new WeakMap,
xs = new WeakMap,
Ht = new WeakMap,
bs = new WeakMap,
ut = new WeakMap,
Oa = new WeakMap,
_s = new WeakMap,
hr = new WeakSet,
Mr = function(e) {
    const r = n => {
        switch (e.type) {
        case "failed":
            return {
                ...n,
                fetchFailureCount: e.failureCount,
                fetchFailureReason: e.error
            };
        case "pause":
            return {
                ...n,
                fetchStatus: "paused"
            };
        case "continue":
            return {
                ...n,
                fetchStatus: "fetching"
            };
        case "fetch":
            return {
                ...n,
                ...Gx(n.data, this.options),
                fetchMeta: e.meta ?? null
            };
        case "success":
            return V(this, xs, void 0),
            {
                ...n,
                data: e.data,
                dataUpdateCount: n.dataUpdateCount + 1,
                dataUpdatedAt: e.dataUpdatedAt ?? Date.now(),
                error: null,
                isInvalidated: !1,
                status: "success",
                ...!e.manual && {
                    fetchStatus: "idle",
                    fetchFailureCount: 0,
                    fetchFailureReason: null
                }
            };
        case "error":
            const s = e.error;
            return ld(s) && s.revert && E(this, xs) ? {
                ...E(this, xs),
                fetchStatus: "idle"
            } : {
                ...n,
                error: s,
                errorUpdateCount: n.errorUpdateCount + 1,
                errorUpdatedAt: Date.now(),
                fetchFailureCount: n.fetchFailureCount + 1,
                fetchFailureReason: s,
                fetchStatus: "idle",
                status: "error"
            };
        case "invalidate":
            return {
                ...n,
                isInvalidated: !0
            };
        case "setState":
            return {
                ...n,
                ...e.state
            }
        }
    }
    ;
    this.state = r(this.state),
    st.batch( () => {
        this.observers.forEach(n => {
            n.onQueryUpdate()
        }
        ),
        E(this, Ht).notify({
            query: this,
            type: "updated",
            action: e
        })
    }
    )
}
,
ty);
function Gx(t, e) {
    return {
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchStatus: Wx(e.networkMode) ? "fetching" : "paused",
        ...t === void 0 && {
            error: null,
            status: "pending"
        }
    }
}
function bN(t) {
    const e = typeof t.initialData == "function" ? t.initialData() : t.initialData
      , r = e !== void 0
      , n = r ? typeof t.initialDataUpdatedAt == "function" ? t.initialDataUpdatedAt() : t.initialDataUpdatedAt : 0;
    return {
        data: e,
        dataUpdateCount: 0,
        dataUpdatedAt: r ? n ?? Date.now() : 0,
        error: null,
        errorUpdateCount: 0,
        errorUpdatedAt: 0,
        fetchFailureCount: 0,
        fetchFailureReason: null,
        fetchMeta: null,
        isInvalidated: !1,
        status: r ? "success" : "pending",
        fetchStatus: "idle"
    }
}
var Er, ry, _N = (ry = class extends Ka {
    constructor(e={}) {
        super();
        X(this, Er);
        this.config = e,
        V(this, Er, new Map)
    }
    build(e, r, n) {
        const s = r.queryKey
          , i = r.queryHash ?? jp(s, r);
        let o = this.get(i);
        return o || (o = new xN({
            client: e,
            queryKey: s,
            queryHash: i,
            options: e.defaultQueryOptions(r),
            state: n,
            defaultOptions: e.getQueryDefaults(s)
        }),
        this.add(o)),
        o
    }
    add(e) {
        E(this, Er).has(e.queryHash) || (E(this, Er).set(e.queryHash, e),
        this.notify({
            type: "added",
            query: e
        }))
    }
    remove(e) {
        const r = E(this, Er).get(e.queryHash);
        r && (e.destroy(),
        r === e && E(this, Er).delete(e.queryHash),
        this.notify({
            type: "removed",
            query: e
        }))
    }
    clear() {
        st.batch( () => {
            this.getAll().forEach(e => {
                this.remove(e)
            }
            )
        }
        )
    }
    get(e) {
        return E(this, Er).get(e)
    }
    getAll() {
        return [...E(this, Er).values()]
    }
    find(e) {
        const r = {
            exact: !0,
            ...e
        };
        return this.getAll().find(n => Dg(r, n))
    }
    findAll(e={}) {
        const r = this.getAll();
        return Object.keys(e).length > 0 ? r.filter(n => Dg(e, n)) : r
    }
    notify(e) {
        st.batch( () => {
            this.listeners.forEach(r => {
                r(e)
            }
            )
        }
        )
    }
    onFocus() {
        st.batch( () => {
            this.getAll().forEach(e => {
                e.onFocus()
            }
            )
        }
        )
    }
    onOnline() {
        st.batch( () => {
            this.getAll().forEach(e => {
                e.onOnline()
            }
            )
        }
        )
    }
}
,
Er = new WeakMap,
ry), Cr, ft, Ss, Tr, dn, ny, SN = (ny = class extends qx {
    constructor(e) {
        super();
        X(this, Tr);
        X(this, Cr);
        X(this, ft);
        X(this, Ss);
        this.mutationId = e.mutationId,
        V(this, ft, e.mutationCache),
        V(this, Cr, []),
        this.state = e.state || kN(),
        this.setOptions(e.options),
        this.scheduleGc()
    }
    setOptions(e) {
        this.options = e,
        this.updateGcTime(this.options.gcTime)
    }
    get meta() {
        return this.options.meta
    }
    addObserver(e) {
        E(this, Cr).includes(e) || (E(this, Cr).push(e),
        this.clearGcTimeout(),
        E(this, ft).notify({
            type: "observerAdded",
            mutation: this,
            observer: e
        }))
    }
    removeObserver(e) {
        V(this, Cr, E(this, Cr).filter(r => r !== e)),
        this.scheduleGc(),
        E(this, ft).notify({
            type: "observerRemoved",
            mutation: this,
            observer: e
        })
    }
    optionalRemove() {
        E(this, Cr).length || (this.state.status === "pending" ? this.scheduleGc() : E(this, ft).remove(this))
    }
    continue() {
        var e;
        return ((e = E(this, Ss)) == null ? void 0 : e.continue()) ?? this.execute(this.state.variables)
    }
    async execute(e) {
        var i, o, a, l, c, u, h, p, f, b, m, x, w, g, v, _, S, k, C, T;
        const r = () => {
            de(this, Tr, dn).call(this, {
                type: "continue"
            })
        }
        ;
        V(this, Ss, Kx({
            fn: () => this.options.mutationFn ? this.options.mutationFn(e) : Promise.reject(new Error("No mutationFn found")),
            onFail: (A, P) => {
                de(this, Tr, dn).call(this, {
                    type: "failed",
                    failureCount: A,
                    error: P
                })
            }
            ,
            onPause: () => {
                de(this, Tr, dn).call(this, {
                    type: "pause"
                })
            }
            ,
            onContinue: r,
            retry: this.options.retry ?? 0,
            retryDelay: this.options.retryDelay,
            networkMode: this.options.networkMode,
            canRun: () => E(this, ft).canRun(this)
        }));
        const n = this.state.status === "pending"
          , s = !E(this, Ss).canStart();
        try {
            if (n)
                r();
            else {
                de(this, Tr, dn).call(this, {
                    type: "pending",
                    variables: e,
                    isPaused: s
                }),
                await ((o = (i = E(this, ft).config).onMutate) == null ? void 0 : o.call(i, e, this));
                const P = await ((l = (a = this.options).onMutate) == null ? void 0 : l.call(a, e));
                P !== this.state.context && de(this, Tr, dn).call(this, {
                    type: "pending",
                    context: P,
                    variables: e,
                    isPaused: s
                })
            }
            const A = await E(this, Ss).start();
            return await ((u = (c = E(this, ft).config).onSuccess) == null ? void 0 : u.call(c, A, e, this.state.context, this)),
            await ((p = (h = this.options).onSuccess) == null ? void 0 : p.call(h, A, e, this.state.context)),
            await ((b = (f = E(this, ft).config).onSettled) == null ? void 0 : b.call(f, A, null, this.state.variables, this.state.context, this)),
            await ((x = (m = this.options).onSettled) == null ? void 0 : x.call(m, A, null, e, this.state.context)),
            de(this, Tr, dn).call(this, {
                type: "success",
                data: A
            }),
            A
        } catch (A) {
            try {
                throw await ((g = (w = E(this, ft).config).onError) == null ? void 0 : g.call(w, A, e, this.state.context, this)),
                await ((_ = (v = this.options).onError) == null ? void 0 : _.call(v, A, e, this.state.context)),
                await ((k = (S = E(this, ft).config).onSettled) == null ? void 0 : k.call(S, void 0, A, this.state.variables, this.state.context, this)),
                await ((T = (C = this.options).onSettled) == null ? void 0 : T.call(C, void 0, A, e, this.state.context)),
                A
            } finally {
                de(this, Tr, dn).call(this, {
                    type: "error",
                    error: A
                })
            }
        } finally {
            E(this, ft).runNext(this)
        }
    }
}
,
Cr = new WeakMap,
ft = new WeakMap,
Ss = new WeakMap,
Tr = new WeakSet,
dn = function(e) {
    const r = n => {
        switch (e.type) {
        case "failed":
            return {
                ...n,
                failureCount: e.failureCount,
                failureReason: e.error
            };
        case "pause":
            return {
                ...n,
                isPaused: !0
            };
        case "continue":
            return {
                ...n,
                isPaused: !1
            };
        case "pending":
            return {
                ...n,
                context: e.context,
                data: void 0,
                failureCount: 0,
                failureReason: null,
                error: null,
                isPaused: e.isPaused,
                status: "pending",
                variables: e.variables,
                submittedAt: Date.now()
            };
        case "success":
            return {
                ...n,
                data: e.data,
                failureCount: 0,
                failureReason: null,
                error: null,
                status: "success",
                isPaused: !1
            };
        case "error":
            return {
                ...n,
                data: void 0,
                error: e.error,
                failureCount: n.failureCount + 1,
                failureReason: e.error,
                isPaused: !1,
                status: "error"
            }
        }
    }
    ;
    this.state = r(this.state),
    st.batch( () => {
        E(this, Cr).forEach(n => {
            n.onMutationUpdate(e)
        }
        ),
        E(this, ft).notify({
            mutation: this,
            type: "updated",
            action: e
        })
    }
    )
}
,
ny);
function kN() {
    return {
        context: void 0,
        data: void 0,
        error: null,
        failureCount: 0,
        failureReason: null,
        isPaused: !1,
        status: "idle",
        variables: void 0,
        submittedAt: 0
    }
}
var zr, fr, Ia, sy, EN = (sy = class extends Ka {
    constructor(e={}) {
        super();
        X(this, zr);
        X(this, fr);
        X(this, Ia);
        this.config = e,
        V(this, zr, new Set),
        V(this, fr, new Map),
        V(this, Ia, 0)
    }
    build(e, r, n) {
        const s = new SN({
            mutationCache: this,
            mutationId: ++Ya(this, Ia)._,
            options: e.defaultMutationOptions(r),
            state: n
        });
        return this.add(s),
        s
    }
    add(e) {
        E(this, zr).add(e);
        const r = xl(e);
        if (typeof r == "string") {
            const n = E(this, fr).get(r);
            n ? n.push(e) : E(this, fr).set(r, [e])
        }
        this.notify({
            type: "added",
            mutation: e
        })
    }
    remove(e) {
        if (E(this, zr).delete(e)) {
            const r = xl(e);
            if (typeof r == "string") {
                const n = E(this, fr).get(r);
                if (n)
                    if (n.length > 1) {
                        const s = n.indexOf(e);
                        s !== -1 && n.splice(s, 1)
                    } else
                        n[0] === e && E(this, fr).delete(r)
            }
        }
        this.notify({
            type: "removed",
            mutation: e
        })
    }
    canRun(e) {
        const r = xl(e);
        if (typeof r == "string") {
            const n = E(this, fr).get(r)
              , s = n == null ? void 0 : n.find(i => i.state.status === "pending");
            return !s || s === e
        } else
            return !0
    }
    runNext(e) {
        var n;
        const r = xl(e);
        if (typeof r == "string") {
            const s = (n = E(this, fr).get(r)) == null ? void 0 : n.find(i => i !== e && i.state.isPaused);
            return (s == null ? void 0 : s.continue()) ?? Promise.resolve()
        } else
            return Promise.resolve()
    }
    clear() {
        st.batch( () => {
            E(this, zr).forEach(e => {
                this.notify({
                    type: "removed",
                    mutation: e
                })
            }
            ),
            E(this, zr).clear(),
            E(this, fr).clear()
        }
        )
    }
    getAll() {
        return Array.from(E(this, zr))
    }
    find(e) {
        const r = {
            exact: !0,
            ...e
        };
        return this.getAll().find(n => Mg(r, n))
    }
    findAll(e={}) {
        return this.getAll().filter(r => Mg(e, r))
    }
    notify(e) {
        st.batch( () => {
            this.listeners.forEach(r => {
                r(e)
            }
            )
        }
        )
    }
    resumePausedMutations() {
        const e = this.getAll().filter(r => r.state.isPaused);
        return st.batch( () => Promise.all(e.map(r => r.continue().catch(_t))))
    }
}
,
zr = new WeakMap,
fr = new WeakMap,
Ia = new WeakMap,
sy);
function xl(t) {
    var e;
    return (e = t.options.scope) == null ? void 0 : e.id
}
function Bg(t) {
    return {
        onFetch: (e, r) => {
            var u, h, p, f, b;
            const n = e.options
              , s = (p = (h = (u = e.fetchOptions) == null ? void 0 : u.meta) == null ? void 0 : h.fetchMore) == null ? void 0 : p.direction
              , i = ((f = e.state.data) == null ? void 0 : f.pages) || []
              , o = ((b = e.state.data) == null ? void 0 : b.pageParams) || [];
            let a = {
                pages: [],
                pageParams: []
            }
              , l = 0;
            const c = async () => {
                let m = !1;
                const x = v => {
                    Object.defineProperty(v, "signal", {
                        enumerable: !0,
                        get: () => (e.signal.aborted ? m = !0 : e.signal.addEventListener("abort", () => {
                            m = !0
                        }
                        ),
                        e.signal)
                    })
                }
                  , w = Vx(e.options, e.fetchOptions)
                  , g = async (v, _, S) => {
                    if (m)
                        return Promise.reject();
                    if (_ == null && v.pages.length)
                        return Promise.resolve(v);
                    const C = ( () => {
                        const B = {
                            client: e.client,
                            queryKey: e.queryKey,
                            pageParam: _,
                            direction: S ? "backward" : "forward",
                            meta: e.options.meta
                        };
                        return x(B),
                        B
                    }
                    )()
                      , T = await w(C)
                      , {maxPages: A} = e.options
                      , P = S ? fN : hN;
                    return {
                        pages: P(v.pages, T, A),
                        pageParams: P(v.pageParams, _, A)
                    }
                }
                ;
                if (s && i.length) {
                    const v = s === "backward"
                      , _ = v ? CN : zg
                      , S = {
                        pages: i,
                        pageParams: o
                    }
                      , k = _(n, S);
                    a = await g(S, k, v)
                } else {
                    const v = t ?? i.length;
                    do {
                        const _ = l === 0 ? o[0] ?? n.initialPageParam : zg(n, a);
                        if (l > 0 && _ == null)
                            break;
                        a = await g(a, _),
                        l++
                    } while (l < v)
                }
                return a
            }
            ;
            e.options.persister ? e.fetchFn = () => {
                var m, x;
                return (x = (m = e.options).persister) == null ? void 0 : x.call(m, c, {
                    client: e.client,
                    queryKey: e.queryKey,
                    meta: e.options.meta,
                    signal: e.signal
                }, r)
            }
            : e.fetchFn = c
        }
    }
}
function zg(t, {pages: e, pageParams: r}) {
    const n = e.length - 1;
    return e.length > 0 ? t.getNextPageParam(e[n], e, r[n], r) : void 0
}
function CN(t, {pages: e, pageParams: r}) {
    var n;
    return e.length > 0 ? (n = t.getPreviousPageParam) == null ? void 0 : n.call(t, e[0], e, r[0], r) : void 0
}
var Ue, _n, Sn, zi, Vi, kn, Wi, Hi, iy, TN = (iy = class {
    constructor(t={}) {
        X(this, Ue);
        X(this, _n);
        X(this, Sn);
        X(this, zi);
        X(this, Vi);
        X(this, kn);
        X(this, Wi);
        X(this, Hi);
        V(this, Ue, t.queryCache || new _N),
        V(this, _n, t.mutationCache || new EN),
        V(this, Sn, t.defaultOptions || {}),
        V(this, zi, new Map),
        V(this, Vi, new Map),
        V(this, kn, 0)
    }
    mount() {
        Ya(this, kn)._++,
        E(this, kn) === 1 && (V(this, Wi, Ip.subscribe(async t => {
            t && (await this.resumePausedMutations(),
            E(this, Ue).onFocus())
        }
        )),
        V(this, Hi, kc.subscribe(async t => {
            t && (await this.resumePausedMutations(),
            E(this, Ue).onOnline())
        }
        )))
    }
    unmount() {
        var t, e;
        Ya(this, kn)._--,
        E(this, kn) === 0 && ((t = E(this, Wi)) == null || t.call(this),
        V(this, Wi, void 0),
        (e = E(this, Hi)) == null || e.call(this),
        V(this, Hi, void 0))
    }
    isFetching(t) {
        return E(this, Ue).findAll({
            ...t,
            fetchStatus: "fetching"
        }).length
    }
    isMutating(t) {
        return E(this, _n).findAll({
            ...t,
            status: "pending"
        }).length
    }
    getQueryData(t) {
        var r;
        const e = this.defaultQueryOptions({
            queryKey: t
        });
        return (r = E(this, Ue).get(e.queryHash)) == null ? void 0 : r.state.data
    }
    ensureQueryData(t) {
        const e = this.defaultQueryOptions(t)
          , r = E(this, Ue).build(this, e)
          , n = r.state.data;
        return n === void 0 ? this.fetchQuery(t) : (t.revalidateIfStale && r.isStaleByTime(Bn(e.staleTime, r)) && this.prefetchQuery(e),
        Promise.resolve(n))
    }
    getQueriesData(t) {
        return E(this, Ue).findAll(t).map( ({queryKey: e, state: r}) => {
            const n = r.data;
            return [e, n]
        }
        )
    }
    setQueryData(t, e, r) {
        const n = this.defaultQueryOptions({
            queryKey: t
        })
          , s = E(this, Ue).get(n.queryHash)
          , i = s == null ? void 0 : s.state.data
          , o = uN(e, i);
        if (o !== void 0)
            return E(this, Ue).build(this, n).setData(o, {
                ...r,
                manual: !0
            })
    }
    setQueriesData(t, e, r) {
        return st.batch( () => E(this, Ue).findAll(t).map( ({queryKey: n}) => [n, this.setQueryData(n, e, r)]))
    }
    getQueryState(t) {
        var r;
        const e = this.defaultQueryOptions({
            queryKey: t
        });
        return (r = E(this, Ue).get(e.queryHash)) == null ? void 0 : r.state
    }
    removeQueries(t) {
        const e = E(this, Ue);
        st.batch( () => {
            e.findAll(t).forEach(r => {
                e.remove(r)
            }
            )
        }
        )
    }
    resetQueries(t, e) {
        const r = E(this, Ue);
        return st.batch( () => (r.findAll(t).forEach(n => {
            n.reset()
        }
        ),
        this.refetchQueries({
            type: "active",
            ...t
        }, e)))
    }
    cancelQueries(t, e={}) {
        const r = {
            revert: !0,
            ...e
        }
          , n = st.batch( () => E(this, Ue).findAll(t).map(s => s.cancel(r)));
        return Promise.all(n).then(_t).catch(_t)
    }
    invalidateQueries(t, e={}) {
        return st.batch( () => (E(this, Ue).findAll(t).forEach(r => {
            r.invalidate()
        }
        ),
        (t == null ? void 0 : t.refetchType) === "none" ? Promise.resolve() : this.refetchQueries({
            ...t,
            type: (t == null ? void 0 : t.refetchType) ?? (t == null ? void 0 : t.type) ?? "active"
        }, e)))
    }
    refetchQueries(t, e={}) {
        const r = {
            ...e,
            cancelRefetch: e.cancelRefetch ?? !0
        }
          , n = st.batch( () => E(this, Ue).findAll(t).filter(s => !s.isDisabled() && !s.isStatic()).map(s => {
            let i = s.fetch(void 0, r);
            return r.throwOnError || (i = i.catch(_t)),
            s.state.fetchStatus === "paused" ? Promise.resolve() : i
        }
        ));
        return Promise.all(n).then(_t)
    }
    fetchQuery(t) {
        const e = this.defaultQueryOptions(t);
        e.retry === void 0 && (e.retry = !1);
        const r = E(this, Ue).build(this, e);
        return r.isStaleByTime(Bn(e.staleTime, r)) ? r.fetch(e) : Promise.resolve(r.state.data)
    }
    prefetchQuery(t) {
        return this.fetchQuery(t).then(_t).catch(_t)
    }
    fetchInfiniteQuery(t) {
        return t.behavior = Bg(t.pages),
        this.fetchQuery(t)
    }
    prefetchInfiniteQuery(t) {
        return this.fetchInfiniteQuery(t).then(_t).catch(_t)
    }
    ensureInfiniteQueryData(t) {
        return t.behavior = Bg(t.pages),
        this.ensureQueryData(t)
    }
    resumePausedMutations() {
        return kc.isOnline() ? E(this, _n).resumePausedMutations() : Promise.resolve()
    }
    getQueryCache() {
        return E(this, Ue)
    }
    getMutationCache() {
        return E(this, _n)
    }
    getDefaultOptions() {
        return E(this, Sn)
    }
    setDefaultOptions(t) {
        V(this, Sn, t)
    }
    setQueryDefaults(t, e) {
        E(this, zi).set(xa(t), {
            queryKey: t,
            defaultOptions: e
        })
    }
    getQueryDefaults(t) {
        const e = [...E(this, zi).values()]
          , r = {};
        return e.forEach(n => {
            ba(t, n.queryKey) && Object.assign(r, n.defaultOptions)
        }
        ),
        r
    }
    setMutationDefaults(t, e) {
        E(this, Vi).set(xa(t), {
            mutationKey: t,
            defaultOptions: e
        })
    }
    getMutationDefaults(t) {
        const e = [...E(this, Vi).values()]
          , r = {};
        return e.forEach(n => {
            ba(t, n.mutationKey) && Object.assign(r, n.defaultOptions)
        }
        ),
        r
    }
    defaultQueryOptions(t) {
        if (t._defaulted)
            return t;
        const e = {
            ...E(this, Sn).queries,
            ...this.getQueryDefaults(t.queryKey),
            ...t,
            _defaulted: !0
        };
        return e.queryHash || (e.queryHash = jp(e.queryKey, e)),
        e.refetchOnReconnect === void 0 && (e.refetchOnReconnect = e.networkMode !== "always"),
        e.throwOnError === void 0 && (e.throwOnError = !!e.suspense),
        !e.networkMode && e.persister && (e.networkMode = "offlineFirst"),
        e.queryFn === Op && (e.enabled = !1),
        e
    }
    defaultMutationOptions(t) {
        return t != null && t._defaulted ? t : {
            ...E(this, Sn).mutations,
            ...(t == null ? void 0 : t.mutationKey) && this.getMutationDefaults(t.mutationKey),
            ...t,
            _defaulted: !0
        }
    }
    clear() {
        E(this, Ue).clear(),
        E(this, _n).clear()
    }
}
,
Ue = new WeakMap,
_n = new WeakMap,
Sn = new WeakMap,
zi = new WeakMap,
Vi = new WeakMap,
kn = new WeakMap,
Wi = new WeakMap,
Hi = new WeakMap,
iy), xt, he, La, pt, ks, Ki, En, Cn, $a, qi, Gi, Es, Cs, Tn, Qi, xe, Mo, $h, Dh, Mh, Fh, Uh, Bh, zh, Qx, oy, RN = (oy = class extends Ka {
    constructor(e, r) {
        super();
        X(this, xe);
        X(this, xt);
        X(this, he);
        X(this, La);
        X(this, pt);
        X(this, ks);
        X(this, Ki);
        X(this, En);
        X(this, Cn);
        X(this, $a);
        X(this, qi);
        X(this, Gi);
        X(this, Es);
        X(this, Cs);
        X(this, Tn);
        X(this, Qi, new Set);
        this.options = r,
        V(this, xt, e),
        V(this, Cn, null),
        V(this, En, Lh()),
        this.options.experimental_prefetchInRender || E(this, En).reject(new Error("experimental_prefetchInRender feature flag is not enabled")),
        this.bindMethods(),
        this.setOptions(r)
    }
    bindMethods() {
        this.refetch = this.refetch.bind(this)
    }
    onSubscribe() {
        this.listeners.size === 1 && (E(this, he).addObserver(this),
        Vg(E(this, he), this.options) ? de(this, xe, Mo).call(this) : this.updateResult(),
        de(this, xe, Fh).call(this))
    }
    onUnsubscribe() {
        this.hasListeners() || this.destroy()
    }
    shouldFetchOnReconnect() {
        return Vh(E(this, he), this.options, this.options.refetchOnReconnect)
    }
    shouldFetchOnWindowFocus() {
        return Vh(E(this, he), this.options, this.options.refetchOnWindowFocus)
    }
    destroy() {
        this.listeners = new Set,
        de(this, xe, Uh).call(this),
        de(this, xe, Bh).call(this),
        E(this, he).removeObserver(this)
    }
    setOptions(e) {
        const r = this.options
          , n = E(this, he);
        if (this.options = E(this, xt).defaultQueryOptions(e),
        this.options.enabled !== void 0 && typeof this.options.enabled != "boolean" && typeof this.options.enabled != "function" && typeof Kt(this.options.enabled, E(this, he)) != "boolean")
            throw new Error("Expected enabled to be a boolean or a callback that returns a boolean");
        de(this, xe, zh).call(this),
        E(this, he).setOptions(this.options),
        r._defaulted && !jh(this.options, r) && E(this, xt).getQueryCache().notify({
            type: "observerOptionsUpdated",
            query: E(this, he),
            observer: this
        });
        const s = this.hasListeners();
        s && Wg(E(this, he), n, this.options, r) && de(this, xe, Mo).call(this),
        this.updateResult(),
        s && (E(this, he) !== n || Kt(this.options.enabled, E(this, he)) !== Kt(r.enabled, E(this, he)) || Bn(this.options.staleTime, E(this, he)) !== Bn(r.staleTime, E(this, he))) && de(this, xe, $h).call(this);
        const i = de(this, xe, Dh).call(this);
        s && (E(this, he) !== n || Kt(this.options.enabled, E(this, he)) !== Kt(r.enabled, E(this, he)) || i !== E(this, Tn)) && de(this, xe, Mh).call(this, i)
    }
    getOptimisticResult(e) {
        const r = E(this, xt).getQueryCache().build(E(this, xt), e)
          , n = this.createResult(r, e);
        return PN(this, n) && (V(this, pt, n),
        V(this, Ki, this.options),
        V(this, ks, E(this, he).state)),
        n
    }
    getCurrentResult() {
        return E(this, pt)
    }
    trackResult(e, r) {
        return new Proxy(e,{
            get: (n, s) => (this.trackProp(s),
            r == null || r(s),
            Reflect.get(n, s))
        })
    }
    trackProp(e) {
        E(this, Qi).add(e)
    }
    getCurrentQuery() {
        return E(this, he)
    }
    refetch({...e}={}) {
        return this.fetch({
            ...e
        })
    }
    fetchOptimistic(e) {
        const r = E(this, xt).defaultQueryOptions(e)
          , n = E(this, xt).getQueryCache().build(E(this, xt), r);
        return n.fetch().then( () => this.createResult(n, r))
    }
    fetch(e) {
        return de(this, xe, Mo).call(this, {
            ...e,
            cancelRefetch: e.cancelRefetch ?? !0
        }).then( () => (this.updateResult(),
        E(this, pt)))
    }
    createResult(e, r) {
        var A;
        const n = E(this, he)
          , s = this.options
          , i = E(this, pt)
          , o = E(this, ks)
          , a = E(this, Ki)
          , c = e !== n ? e.state : E(this, La)
          , {state: u} = e;
        let h = {
            ...u
        }, p = !1, f;
        if (r._optimisticResults) {
            const P = this.hasListeners()
              , B = !P && Vg(e, r)
              , L = P && Wg(e, n, r, s);
            (B || L) && (h = {
                ...h,
                ...Gx(u.data, e.options)
            }),
            r._optimisticResults === "isRestoring" && (h.fetchStatus = "idle")
        }
        let {error: b, errorUpdatedAt: m, status: x} = h;
        f = h.data;
        let w = !1;
        if (r.placeholderData !== void 0 && f === void 0 && x === "pending") {
            let P;
            i != null && i.isPlaceholderData && r.placeholderData === (a == null ? void 0 : a.placeholderData) ? (P = i.data,
            w = !0) : P = typeof r.placeholderData == "function" ? r.placeholderData((A = E(this, Gi)) == null ? void 0 : A.state.data, E(this, Gi)) : r.placeholderData,
            P !== void 0 && (x = "success",
            f = Ih(i == null ? void 0 : i.data, P, r),
            p = !0)
        }
        if (r.select && f !== void 0 && !w)
            if (i && f === (o == null ? void 0 : o.data) && r.select === E(this, $a))
                f = E(this, qi);
            else
                try {
                    V(this, $a, r.select),
                    f = r.select(f),
                    f = Ih(i == null ? void 0 : i.data, f, r),
                    V(this, qi, f),
                    V(this, Cn, null)
                } catch (P) {
                    V(this, Cn, P)
                }
        E(this, Cn) && (b = E(this, Cn),
        f = E(this, qi),
        m = Date.now(),
        x = "error");
        const g = h.fetchStatus === "fetching"
          , v = x === "pending"
          , _ = x === "error"
          , S = v && g
          , k = f !== void 0
          , T = {
            status: x,
            fetchStatus: h.fetchStatus,
            isPending: v,
            isSuccess: x === "success",
            isError: _,
            isInitialLoading: S,
            isLoading: S,
            data: f,
            dataUpdatedAt: h.dataUpdatedAt,
            error: b,
            errorUpdatedAt: m,
            failureCount: h.fetchFailureCount,
            failureReason: h.fetchFailureReason,
            errorUpdateCount: h.errorUpdateCount,
            isFetched: h.dataUpdateCount > 0 || h.errorUpdateCount > 0,
            isFetchedAfterMount: h.dataUpdateCount > c.dataUpdateCount || h.errorUpdateCount > c.errorUpdateCount,
            isFetching: g,
            isRefetching: g && !v,
            isLoadingError: _ && !k,
            isPaused: h.fetchStatus === "paused",
            isPlaceholderData: p,
            isRefetchError: _ && k,
            isStale: Lp(e, r),
            refetch: this.refetch,
            promise: E(this, En),
            isEnabled: Kt(r.enabled, e) !== !1
        };
        if (this.options.experimental_prefetchInRender) {
            const P = G => {
                T.status === "error" ? G.reject(T.error) : T.data !== void 0 && G.resolve(T.data)
            }
              , B = () => {
                const G = V(this, En, T.promise = Lh());
                P(G)
            }
              , L = E(this, En);
            switch (L.status) {
            case "pending":
                e.queryHash === n.queryHash && P(L);
                break;
            case "fulfilled":
                (T.status === "error" || T.data !== L.value) && B();
                break;
            case "rejected":
                (T.status !== "error" || T.error !== L.reason) && B();
                break
            }
        }
        return T
    }
    updateResult() {
        const e = E(this, pt)
          , r = this.createResult(E(this, he), this.options);
        if (V(this, ks, E(this, he).state),
        V(this, Ki, this.options),
        E(this, ks).data !== void 0 && V(this, Gi, E(this, he)),
        jh(r, e))
            return;
        V(this, pt, r);
        const n = () => {
            if (!e)
                return !0;
            const {notifyOnChangeProps: s} = this.options
              , i = typeof s == "function" ? s() : s;
            if (i === "all" || !i && !E(this, Qi).size)
                return !0;
            const o = new Set(i ?? E(this, Qi));
            return this.options.throwOnError && o.add("error"),
            Object.keys(E(this, pt)).some(a => {
                const l = a;
                return E(this, pt)[l] !== e[l] && o.has(l)
            }
            )
        }
        ;
        de(this, xe, Qx).call(this, {
            listeners: n()
        })
    }
    onQueryUpdate() {
        this.updateResult(),
        this.hasListeners() && de(this, xe, Fh).call(this)
    }
}
,
xt = new WeakMap,
he = new WeakMap,
La = new WeakMap,
pt = new WeakMap,
ks = new WeakMap,
Ki = new WeakMap,
En = new WeakMap,
Cn = new WeakMap,
$a = new WeakMap,
qi = new WeakMap,
Gi = new WeakMap,
Es = new WeakMap,
Cs = new WeakMap,
Tn = new WeakMap,
Qi = new WeakMap,
xe = new WeakSet,
Mo = function(e) {
    de(this, xe, zh).call(this);
    let r = E(this, he).fetch(this.options, e);
    return e != null && e.throwOnError || (r = r.catch(_t)),
    r
}
,
$h = function() {
    de(this, xe, Uh).call(this);
    const e = Bn(this.options.staleTime, E(this, he));
    if (Ls || E(this, pt).isStale || !Ah(e))
        return;
    const n = Bx(E(this, pt).dataUpdatedAt, e) + 1;
    V(this, Es, setTimeout( () => {
        E(this, pt).isStale || this.updateResult()
    }
    , n))
}
,
Dh = function() {
    return (typeof this.options.refetchInterval == "function" ? this.options.refetchInterval(E(this, he)) : this.options.refetchInterval) ?? !1
}
,
Mh = function(e) {
    de(this, xe, Bh).call(this),
    V(this, Tn, e),
    !(Ls || Kt(this.options.enabled, E(this, he)) === !1 || !Ah(E(this, Tn)) || E(this, Tn) === 0) && V(this, Cs, setInterval( () => {
        (this.options.refetchIntervalInBackground || Ip.isFocused()) && de(this, xe, Mo).call(this)
    }
    , E(this, Tn)))
}
,
Fh = function() {
    de(this, xe, $h).call(this),
    de(this, xe, Mh).call(this, de(this, xe, Dh).call(this))
}
,
Uh = function() {
    E(this, Es) && (clearTimeout(E(this, Es)),
    V(this, Es, void 0))
}
,
Bh = function() {
    E(this, Cs) && (clearInterval(E(this, Cs)),
    V(this, Cs, void 0))
}
,
zh = function() {
    const e = E(this, xt).getQueryCache().build(E(this, xt), this.options);
    if (e === E(this, he))
        return;
    const r = E(this, he);
    V(this, he, e),
    V(this, La, e.state),
    this.hasListeners() && (r == null || r.removeObserver(this),
    e.addObserver(this))
}
,
Qx = function(e) {
    st.batch( () => {
        e.listeners && this.listeners.forEach(r => {
            r(E(this, pt))
        }
        ),
        E(this, xt).getQueryCache().notify({
            query: E(this, he),
            type: "observerResultsUpdated"
        })
    }
    )
}
,
oy);
function NN(t, e) {
    return Kt(e.enabled, t) !== !1 && t.state.data === void 0 && !(t.state.status === "error" && e.retryOnMount === !1)
}
function Vg(t, e) {
    return NN(t, e) || t.state.data !== void 0 && Vh(t, e, e.refetchOnMount)
}
function Vh(t, e, r) {
    if (Kt(e.enabled, t) !== !1 && Bn(e.staleTime, t) !== "static") {
        const n = typeof r == "function" ? r(t) : r;
        return n === "always" || n !== !1 && Lp(t, e)
    }
    return !1
}
function Wg(t, e, r, n) {
    return (t !== e || Kt(n.enabled, t) === !1) && (!r.suspense || t.state.status !== "error") && Lp(t, r)
}
function Lp(t, e) {
    return Kt(e.enabled, t) !== !1 && t.isStaleByTime(Bn(e.staleTime, t))
}
function PN(t, e) {
    return !jh(t.getCurrentResult(), e)
}
var Jx = y.createContext(void 0)
  , AN = t => {
    const e = y.useContext(Jx);
    if (!e)
        throw new Error("No QueryClient set, use QueryClientProvider to set one");
    return e
}
  , jN = ({client: t, children: e}) => (y.useEffect( () => (t.mount(),
() => {
    t.unmount()
}
), [t]),
d.jsx(Jx.Provider, {
    value: t,
    children: e
}))
  , Zx = y.createContext(!1)
  , ON = () => y.useContext(Zx);
Zx.Provider;
function IN() {
    let t = !1;
    return {
        clearReset: () => {
            t = !1
        }
        ,
        reset: () => {
            t = !0
        }
        ,
        isReset: () => t
    }
}
var LN = y.createContext(IN())
  , $N = () => y.useContext(LN)
  , DN = (t, e) => {
    (t.suspense || t.throwOnError || t.experimental_prefetchInRender) && (e.isReset() || (t.retryOnMount = !1))
}
  , MN = t => {
    y.useEffect( () => {
        t.clearReset()
    }
    , [t])
}
  , FN = ({result: t, errorResetBoundary: e, throwOnError: r, query: n, suspense: s}) => t.isError && !e.isReset() && !t.isFetching && n && (s && t.data === void 0 || pN(r, [t.error, n]))
  , UN = t => {
    if (t.suspense) {
        const e = n => n === "static" ? n : Math.max(n ?? 1e3, 1e3)
          , r = t.staleTime;
        t.staleTime = typeof r == "function" ? (...n) => e(r(...n)) : e(r),
        typeof t.gcTime == "number" && (t.gcTime = Math.max(t.gcTime, 1e3))
    }
}
  , BN = (t, e) => t.isLoading && t.isFetching && !e
  , zN = (t, e) => (t == null ? void 0 : t.suspense) && e.isPending
  , Hg = (t, e, r) => e.fetchOptimistic(t).catch( () => {
    r.clearReset()
}
);
function VN(t, e, r) {
    var h, p, f, b, m;
    const n = ON()
      , s = $N()
      , i = AN()
      , o = i.defaultQueryOptions(t);
    (p = (h = i.getDefaultOptions().queries) == null ? void 0 : h._experimental_beforeQuery) == null || p.call(h, o),
    o._optimisticResults = n ? "isRestoring" : "optimistic",
    UN(o),
    DN(o, s),
    MN(s);
    const a = !i.getQueryCache().get(o.queryHash)
      , [l] = y.useState( () => new e(i,o))
      , c = l.getOptimisticResult(o)
      , u = !n && t.subscribed !== !1;
    if (y.useSyncExternalStore(y.useCallback(x => {
        const w = u ? l.subscribe(st.batchCalls(x)) : _t;
        return l.updateResult(),
        w
    }
    , [l, u]), () => l.getCurrentResult(), () => l.getCurrentResult()),
    y.useEffect( () => {
        l.setOptions(o)
    }
    , [o, l]),
    zN(o, c))
        throw Hg(o, l, s);
    if (FN({
        result: c,
        errorResetBoundary: s,
        throwOnError: o.throwOnError,
        query: i.getQueryCache().get(o.queryHash),
        suspense: o.suspense
    }))
        throw c.error;
    if ((b = (f = i.getDefaultOptions().queries) == null ? void 0 : f._experimental_afterQuery) == null || b.call(f, o, c),
    o.experimental_prefetchInRender && !Ls && BN(c, n)) {
        const x = a ? Hg(o, l, s) : (m = i.getQueryCache().get(o.queryHash)) == null ? void 0 : m.promise;
        x == null || x.catch(_t).finally( () => {
            l.updateResult()
        }
        )
    }
    return o.notifyOnChangeProps ? c : l.trackResult(c)
}
function Yx(t, e) {
    return VN(t, RN)
}
/**
 * @remix-run/router v1.23.0
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function _a() {
    return _a = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e];
            for (var n in r)
                Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n])
        }
        return t
    }
    ,
    _a.apply(this, arguments)
}
var Pn;
(function(t) {
    t.Pop = "POP",
    t.Push = "PUSH",
    t.Replace = "REPLACE"
}
)(Pn || (Pn = {}));
const Kg = "popstate";
function WN(t) {
    t === void 0 && (t = {});
    function e(n, s) {
        let {pathname: i, search: o, hash: a} = n.location;
        return Wh("", {
            pathname: i,
            search: o,
            hash: a
        }, s.state && s.state.usr || null, s.state && s.state.key || "default")
    }
    function r(n, s) {
        return typeof s == "string" ? s : Ec(s)
    }
    return KN(e, r, null, t)
}
function We(t, e) {
    if (t === !1 || t === null || typeof t > "u")
        throw new Error(e)
}
function Xx(t, e) {
    if (!t) {
        typeof console < "u" && console.warn(e);
        try {
            throw new Error(e)
        } catch {}
    }
}
function HN() {
    return Math.random().toString(36).substr(2, 8)
}
function qg(t, e) {
    return {
        usr: t.state,
        key: t.key,
        idx: e
    }
}
function Wh(t, e, r, n) {
    return r === void 0 && (r = null),
    _a({
        pathname: typeof t == "string" ? t : t.pathname,
        search: "",
        hash: ""
    }, typeof e == "string" ? yo(e) : e, {
        state: r,
        key: e && e.key || n || HN()
    })
}
function Ec(t) {
    let {pathname: e="/", search: r="", hash: n=""} = t;
    return r && r !== "?" && (e += r.charAt(0) === "?" ? r : "?" + r),
    n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n),
    e
}
function yo(t) {
    let e = {};
    if (t) {
        let r = t.indexOf("#");
        r >= 0 && (e.hash = t.substr(r),
        t = t.substr(0, r));
        let n = t.indexOf("?");
        n >= 0 && (e.search = t.substr(n),
        t = t.substr(0, n)),
        t && (e.pathname = t)
    }
    return e
}
function KN(t, e, r, n) {
    n === void 0 && (n = {});
    let {window: s=document.defaultView, v5Compat: i=!1} = n
      , o = s.history
      , a = Pn.Pop
      , l = null
      , c = u();
    c == null && (c = 0,
    o.replaceState(_a({}, o.state, {
        idx: c
    }), ""));
    function u() {
        return (o.state || {
            idx: null
        }).idx
    }
    function h() {
        a = Pn.Pop;
        let x = u()
          , w = x == null ? null : x - c;
        c = x,
        l && l({
            action: a,
            location: m.location,
            delta: w
        })
    }
    function p(x, w) {
        a = Pn.Push;
        let g = Wh(m.location, x, w);
        c = u() + 1;
        let v = qg(g, c)
          , _ = m.createHref(g);
        try {
            o.pushState(v, "", _)
        } catch (S) {
            if (S instanceof DOMException && S.name === "DataCloneError")
                throw S;
            s.location.assign(_)
        }
        i && l && l({
            action: a,
            location: m.location,
            delta: 1
        })
    }
    function f(x, w) {
        a = Pn.Replace;
        let g = Wh(m.location, x, w);
        c = u();
        let v = qg(g, c)
          , _ = m.createHref(g);
        o.replaceState(v, "", _),
        i && l && l({
            action: a,
            location: m.location,
            delta: 0
        })
    }
    function b(x) {
        let w = s.location.origin !== "null" ? s.location.origin : s.location.href
          , g = typeof x == "string" ? x : Ec(x);
        return g = g.replace(/ $/, "%20"),
        We(w, "No window.location.(origin|href) available to create URL for href: " + g),
        new URL(g,w)
    }
    let m = {
        get action() {
            return a
        },
        get location() {
            return t(s, o)
        },
        listen(x) {
            if (l)
                throw new Error("A history only accepts one active listener");
            return s.addEventListener(Kg, h),
            l = x,
            () => {
                s.removeEventListener(Kg, h),
                l = null
            }
        },
        createHref(x) {
            return e(s, x)
        },
        createURL: b,
        encodeLocation(x) {
            let w = b(x);
            return {
                pathname: w.pathname,
                search: w.search,
                hash: w.hash
            }
        },
        push: p,
        replace: f,
        go(x) {
            return o.go(x)
        }
    };
    return m
}
var Gg;
(function(t) {
    t.data = "data",
    t.deferred = "deferred",
    t.redirect = "redirect",
    t.error = "error"
}
)(Gg || (Gg = {}));
function qN(t, e, r) {
    return r === void 0 && (r = "/"),
    GN(t, e, r, !1)
}
function GN(t, e, r, n) {
    let s = typeof e == "string" ? yo(e) : e
      , i = io(s.pathname || "/", r);
    if (i == null)
        return null;
    let o = eb(t);
    QN(o);
    let a = null;
    for (let l = 0; a == null && l < o.length; ++l) {
        let c = oP(i);
        a = sP(o[l], c, n)
    }
    return a
}
function eb(t, e, r, n) {
    e === void 0 && (e = []),
    r === void 0 && (r = []),
    n === void 0 && (n = "");
    let s = (i, o, a) => {
        let l = {
            relativePath: a === void 0 ? i.path || "" : a,
            caseSensitive: i.caseSensitive === !0,
            childrenIndex: o,
            route: i
        };
        l.relativePath.startsWith("/") && (We(l.relativePath.startsWith(n), 'Absolute route path "' + l.relativePath + '" nested under path ' + ('"' + n + '" is not valid. An absolute child route path ') + "must start with the combined path of all its parent routes."),
        l.relativePath = l.relativePath.slice(n.length));
        let c = zn([n, l.relativePath])
          , u = r.concat(l);
        i.children && i.children.length > 0 && (We(i.index !== !0, "Index routes must not have child routes. Please remove " + ('all child routes from route path "' + c + '".')),
        eb(i.children, e, u, c)),
        !(i.path == null && !i.index) && e.push({
            path: c,
            score: rP(c, i.index),
            routesMeta: u
        })
    }
    ;
    return t.forEach( (i, o) => {
        var a;
        if (i.path === "" || !((a = i.path) != null && a.includes("?")))
            s(i, o);
        else
            for (let l of tb(i.path))
                s(i, o, l)
    }
    ),
    e
}
function tb(t) {
    let e = t.split("/");
    if (e.length === 0)
        return [];
    let[r,...n] = e
      , s = r.endsWith("?")
      , i = r.replace(/\?$/, "");
    if (n.length === 0)
        return s ? [i, ""] : [i];
    let o = tb(n.join("/"))
      , a = [];
    return a.push(...o.map(l => l === "" ? i : [i, l].join("/"))),
    s && a.push(...o),
    a.map(l => t.startsWith("/") && l === "" ? "/" : l)
}
function QN(t) {
    t.sort( (e, r) => e.score !== r.score ? r.score - e.score : nP(e.routesMeta.map(n => n.childrenIndex), r.routesMeta.map(n => n.childrenIndex)))
}
const JN = /^:[\w-]+$/
  , ZN = 3
  , YN = 2
  , XN = 1
  , eP = 10
  , tP = -2
  , Qg = t => t === "*";
function rP(t, e) {
    let r = t.split("/")
      , n = r.length;
    return r.some(Qg) && (n += tP),
    e && (n += YN),
    r.filter(s => !Qg(s)).reduce( (s, i) => s + (JN.test(i) ? ZN : i === "" ? XN : eP), n)
}
function nP(t, e) {
    return t.length === e.length && t.slice(0, -1).every( (n, s) => n === e[s]) ? t[t.length - 1] - e[e.length - 1] : 0
}
function sP(t, e, r) {
    let {routesMeta: n} = t
      , s = {}
      , i = "/"
      , o = [];
    for (let a = 0; a < n.length; ++a) {
        let l = n[a]
          , c = a === n.length - 1
          , u = i === "/" ? e : e.slice(i.length) || "/"
          , h = Cc({
            path: l.relativePath,
            caseSensitive: l.caseSensitive,
            end: c
        }, u)
          , p = l.route;
        if (!h && c && r && !n[n.length - 1].route.index && (h = Cc({
            path: l.relativePath,
            caseSensitive: l.caseSensitive,
            end: !1
        }, u)),
        !h)
            return null;
        Object.assign(s, h.params),
        o.push({
            params: s,
            pathname: zn([i, h.pathname]),
            pathnameBase: uP(zn([i, h.pathnameBase])),
            route: p
        }),
        h.pathnameBase !== "/" && (i = zn([i, h.pathnameBase]))
    }
    return o
}
function Cc(t, e) {
    typeof t == "string" && (t = {
        path: t,
        caseSensitive: !1,
        end: !0
    });
    let[r,n] = iP(t.path, t.caseSensitive, t.end)
      , s = e.match(r);
    if (!s)
        return null;
    let i = s[0]
      , o = i.replace(/(.)\/+$/, "$1")
      , a = s.slice(1);
    return {
        params: n.reduce( (c, u, h) => {
            let {paramName: p, isOptional: f} = u;
            if (p === "*") {
                let m = a[h] || "";
                o = i.slice(0, i.length - m.length).replace(/(.)\/+$/, "$1")
            }
            const b = a[h];
            return f && !b ? c[p] = void 0 : c[p] = (b || "").replace(/%2F/g, "/"),
            c
        }
        , {}),
        pathname: i,
        pathnameBase: o,
        pattern: t
    }
}
function iP(t, e, r) {
    e === void 0 && (e = !1),
    r === void 0 && (r = !0),
    Xx(t === "*" || !t.endsWith("*") || t.endsWith("/*"), 'Route path "' + t + '" will be treated as if it were ' + ('"' + t.replace(/\*$/, "/*") + '" because the `*` character must ') + "always follow a `/` in the pattern. To get rid of this warning, " + ('please change the route path to "' + t.replace(/\*$/, "/*") + '".'));
    let n = []
      , s = "^" + t.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (o, a, l) => (n.push({
        paramName: a,
        isOptional: l != null
    }),
    l ? "/?([^\\/]+)?" : "/([^\\/]+)"));
    return t.endsWith("*") ? (n.push({
        paramName: "*"
    }),
    s += t === "*" || t === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : r ? s += "\\/*$" : t !== "" && t !== "/" && (s += "(?:(?=\\/|$))"),
    [new RegExp(s,e ? void 0 : "i"), n]
}
function oP(t) {
    try {
        return t.split("/").map(e => decodeURIComponent(e).replace(/\//g, "%2F")).join("/")
    } catch (e) {
        return Xx(!1, 'The URL path "' + t + '" could not be decoded because it is is a malformed URL segment. This is probably due to a bad percent ' + ("encoding (" + e + ").")),
        t
    }
}
function io(t, e) {
    if (e === "/")
        return t;
    if (!t.toLowerCase().startsWith(e.toLowerCase()))
        return null;
    let r = e.endsWith("/") ? e.length - 1 : e.length
      , n = t.charAt(r);
    return n && n !== "/" ? null : t.slice(r) || "/"
}
function aP(t, e) {
    e === void 0 && (e = "/");
    let {pathname: r, search: n="", hash: s=""} = typeof t == "string" ? yo(t) : t;
    return {
        pathname: r ? r.startsWith("/") ? r : lP(r, e) : e,
        search: dP(n),
        hash: hP(s)
    }
}
function lP(t, e) {
    let r = e.replace(/\/+$/, "").split("/");
    return t.split("/").forEach(s => {
        s === ".." ? r.length > 1 && r.pop() : s !== "." && r.push(s)
    }
    ),
    r.length > 1 ? r.join("/") : "/"
}
function cd(t, e, r, n) {
    return "Cannot include a '" + t + "' character in a manually specified " + ("`to." + e + "` field [" + JSON.stringify(n) + "].  Please separate it out to the ") + ("`to." + r + "` field. Alternatively you may provide the full path as ") + 'a string in <Link to="..."> and the router will parse it for you.'
}
function cP(t) {
    return t.filter( (e, r) => r === 0 || e.route.path && e.route.path.length > 0)
}
function rb(t, e) {
    let r = cP(t);
    return e ? r.map( (n, s) => s === r.length - 1 ? n.pathname : n.pathnameBase) : r.map(n => n.pathnameBase)
}
function nb(t, e, r, n) {
    n === void 0 && (n = !1);
    let s;
    typeof t == "string" ? s = yo(t) : (s = _a({}, t),
    We(!s.pathname || !s.pathname.includes("?"), cd("?", "pathname", "search", s)),
    We(!s.pathname || !s.pathname.includes("#"), cd("#", "pathname", "hash", s)),
    We(!s.search || !s.search.includes("#"), cd("#", "search", "hash", s)));
    let i = t === "" || s.pathname === "", o = i ? "/" : s.pathname, a;
    if (o == null)
        a = r;
    else {
        let h = e.length - 1;
        if (!n && o.startsWith("..")) {
            let p = o.split("/");
            for (; p[0] === ".."; )
                p.shift(),
                h -= 1;
            s.pathname = p.join("/")
        }
        a = h >= 0 ? e[h] : "/"
    }
    let l = aP(s, a)
      , c = o && o !== "/" && o.endsWith("/")
      , u = (i || o === ".") && r.endsWith("/");
    return !l.pathname.endsWith("/") && (c || u) && (l.pathname += "/"),
    l
}
const zn = t => t.join("/").replace(/\/\/+/g, "/")
  , uP = t => t.replace(/\/+$/, "").replace(/^\/*/, "/")
  , dP = t => !t || t === "?" ? "" : t.startsWith("?") ? t : "?" + t
  , hP = t => !t || t === "#" ? "" : t.startsWith("#") ? t : "#" + t;
function fP(t) {
    return t != null && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.internal == "boolean" && "data"in t
}
const sb = ["post", "put", "patch", "delete"];
new Set(sb);
const pP = ["get", ...sb];
new Set(pP);
/**
 * React Router v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Sa() {
    return Sa = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e];
            for (var n in r)
                Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n])
        }
        return t
    }
    ,
    Sa.apply(this, arguments)
}
const hu = y.createContext(null)
  , ib = y.createContext(null)
  , es = y.createContext(null)
  , fu = y.createContext(null)
  , Vs = y.createContext({
    outlet: null,
    matches: [],
    isDataRoute: !1
})
  , ob = y.createContext(null);
function mP(t, e) {
    let {relative: r} = e === void 0 ? {} : e;
    qa() || We(!1);
    let {basename: n, navigator: s} = y.useContext(es)
      , {hash: i, pathname: o, search: a} = pu(t, {
        relative: r
    })
      , l = o;
    return n !== "/" && (l = o === "/" ? n : zn([n, o])),
    s.createHref({
        pathname: l,
        search: a,
        hash: i
    })
}
function qa() {
    return y.useContext(fu) != null
}
function Ws() {
    return qa() || We(!1),
    y.useContext(fu).location
}
function ab(t) {
    y.useContext(es).static || y.useLayoutEffect(t)
}
function Ga() {
    let {isDataRoute: t} = y.useContext(Vs);
    return t ? RP() : gP()
}
function gP() {
    qa() || We(!1);
    let t = y.useContext(hu)
      , {basename: e, future: r, navigator: n} = y.useContext(es)
      , {matches: s} = y.useContext(Vs)
      , {pathname: i} = Ws()
      , o = JSON.stringify(rb(s, r.v7_relativeSplatPath))
      , a = y.useRef(!1);
    return ab( () => {
        a.current = !0
    }
    ),
    y.useCallback(function(c, u) {
        if (u === void 0 && (u = {}),
        !a.current)
            return;
        if (typeof c == "number") {
            n.go(c);
            return
        }
        let h = nb(c, JSON.parse(o), i, u.relative === "path");
        t == null && e !== "/" && (h.pathname = h.pathname === "/" ? e : zn([e, h.pathname])),
        (u.replace ? n.replace : n.push)(h, u.state, u)
    }, [e, n, o, i, t])
}
function pu(t, e) {
    let {relative: r} = e === void 0 ? {} : e
      , {future: n} = y.useContext(es)
      , {matches: s} = y.useContext(Vs)
      , {pathname: i} = Ws()
      , o = JSON.stringify(rb(s, n.v7_relativeSplatPath));
    return y.useMemo( () => nb(t, JSON.parse(o), i, r === "path"), [t, o, i, r])
}
function vP(t, e) {
    return yP(t, e)
}
function yP(t, e, r, n) {
    qa() || We(!1);
    let {navigator: s} = y.useContext(es)
      , {matches: i} = y.useContext(Vs)
      , o = i[i.length - 1]
      , a = o ? o.params : {};
    o && o.pathname;
    let l = o ? o.pathnameBase : "/";
    o && o.route;
    let c = Ws(), u;
    if (e) {
        var h;
        let x = typeof e == "string" ? yo(e) : e;
        l === "/" || (h = x.pathname) != null && h.startsWith(l) || We(!1),
        u = x
    } else
        u = c;
    let p = u.pathname || "/"
      , f = p;
    if (l !== "/") {
        let x = l.replace(/^\//, "").split("/");
        f = "/" + p.replace(/^\//, "").split("/").slice(x.length).join("/")
    }
    let b = qN(t, {
        pathname: f
    })
      , m = SP(b && b.map(x => Object.assign({}, x, {
        params: Object.assign({}, a, x.params),
        pathname: zn([l, s.encodeLocation ? s.encodeLocation(x.pathname).pathname : x.pathname]),
        pathnameBase: x.pathnameBase === "/" ? l : zn([l, s.encodeLocation ? s.encodeLocation(x.pathnameBase).pathname : x.pathnameBase])
    })), i, r, n);
    return e && m ? y.createElement(fu.Provider, {
        value: {
            location: Sa({
                pathname: "/",
                search: "",
                hash: "",
                state: null,
                key: "default"
            }, u),
            navigationType: Pn.Pop
        }
    }, m) : m
}
function wP() {
    let t = TP()
      , e = fP(t) ? t.status + " " + t.statusText : t instanceof Error ? t.message : JSON.stringify(t)
      , r = t instanceof Error ? t.stack : null
      , s = {
        padding: "0.5rem",
        backgroundColor: "rgba(200,200,200, 0.5)"
    };
    return y.createElement(y.Fragment, null, y.createElement("h2", null, "Unexpected Application Error!"), y.createElement("h3", {
        style: {
            fontStyle: "italic"
        }
    }, e), r ? y.createElement("pre", {
        style: s
    }, r) : null, null)
}
const xP = y.createElement(wP, null);
class bP extends y.Component {
    constructor(e) {
        super(e),
        this.state = {
            location: e.location,
            revalidation: e.revalidation,
            error: e.error
        }
    }
    static getDerivedStateFromError(e) {
        return {
            error: e
        }
    }
    static getDerivedStateFromProps(e, r) {
        return r.location !== e.location || r.revalidation !== "idle" && e.revalidation === "idle" ? {
            error: e.error,
            location: e.location,
            revalidation: e.revalidation
        } : {
            error: e.error !== void 0 ? e.error : r.error,
            location: r.location,
            revalidation: e.revalidation || r.revalidation
        }
    }
    componentDidCatch(e, r) {
        console.error("React Router caught the following error during render", e, r)
    }
    render() {
        return this.state.error !== void 0 ? y.createElement(Vs.Provider, {
            value: this.props.routeContext
        }, y.createElement(ob.Provider, {
            value: this.state.error,
            children: this.props.component
        })) : this.props.children
    }
}
function _P(t) {
    let {routeContext: e, match: r, children: n} = t
      , s = y.useContext(hu);
    return s && s.static && s.staticContext && (r.route.errorElement || r.route.ErrorBoundary) && (s.staticContext._deepestRenderedBoundaryId = r.route.id),
    y.createElement(Vs.Provider, {
        value: e
    }, n)
}
function SP(t, e, r, n) {
    var s;
    if (e === void 0 && (e = []),
    r === void 0 && (r = null),
    n === void 0 && (n = null),
    t == null) {
        var i;
        if (!r)
            return null;
        if (r.errors)
            t = r.matches;
        else if ((i = n) != null && i.v7_partialHydration && e.length === 0 && !r.initialized && r.matches.length > 0)
            t = r.matches;
        else
            return null
    }
    let o = t
      , a = (s = r) == null ? void 0 : s.errors;
    if (a != null) {
        let u = o.findIndex(h => h.route.id && (a == null ? void 0 : a[h.route.id]) !== void 0);
        u >= 0 || We(!1),
        o = o.slice(0, Math.min(o.length, u + 1))
    }
    let l = !1
      , c = -1;
    if (r && n && n.v7_partialHydration)
        for (let u = 0; u < o.length; u++) {
            let h = o[u];
            if ((h.route.HydrateFallback || h.route.hydrateFallbackElement) && (c = u),
            h.route.id) {
                let {loaderData: p, errors: f} = r
                  , b = h.route.loader && p[h.route.id] === void 0 && (!f || f[h.route.id] === void 0);
                if (h.route.lazy || b) {
                    l = !0,
                    c >= 0 ? o = o.slice(0, c + 1) : o = [o[0]];
                    break
                }
            }
        }
    return o.reduceRight( (u, h, p) => {
        let f, b = !1, m = null, x = null;
        r && (f = a && h.route.id ? a[h.route.id] : void 0,
        m = h.route.errorElement || xP,
        l && (c < 0 && p === 0 ? (b = !0,
        x = null) : c === p && (b = !0,
        x = h.route.hydrateFallbackElement || null)));
        let w = e.concat(o.slice(0, p + 1))
          , g = () => {
            let v;
            return f ? v = m : b ? v = x : h.route.Component ? v = y.createElement(h.route.Component, null) : h.route.element ? v = h.route.element : v = u,
            y.createElement(_P, {
                match: h,
                routeContext: {
                    outlet: u,
                    matches: w,
                    isDataRoute: r != null
                },
                children: v
            })
        }
        ;
        return r && (h.route.ErrorBoundary || h.route.errorElement || p === 0) ? y.createElement(bP, {
            location: r.location,
            revalidation: r.revalidation,
            component: m,
            error: f,
            children: g(),
            routeContext: {
                outlet: null,
                matches: w,
                isDataRoute: !0
            }
        }) : g()
    }
    , null)
}
var lb = function(t) {
    return t.UseBlocker = "useBlocker",
    t.UseRevalidator = "useRevalidator",
    t.UseNavigateStable = "useNavigate",
    t
}(lb || {})
  , Tc = function(t) {
    return t.UseBlocker = "useBlocker",
    t.UseLoaderData = "useLoaderData",
    t.UseActionData = "useActionData",
    t.UseRouteError = "useRouteError",
    t.UseNavigation = "useNavigation",
    t.UseRouteLoaderData = "useRouteLoaderData",
    t.UseMatches = "useMatches",
    t.UseRevalidator = "useRevalidator",
    t.UseNavigateStable = "useNavigate",
    t.UseRouteId = "useRouteId",
    t
}(Tc || {});
function kP(t) {
    let e = y.useContext(hu);
    return e || We(!1),
    e
}
function EP(t) {
    let e = y.useContext(ib);
    return e || We(!1),
    e
}
function CP(t) {
    let e = y.useContext(Vs);
    return e || We(!1),
    e
}
function cb(t) {
    let e = CP()
      , r = e.matches[e.matches.length - 1];
    return r.route.id || We(!1),
    r.route.id
}
function TP() {
    var t;
    let e = y.useContext(ob)
      , r = EP(Tc.UseRouteError)
      , n = cb(Tc.UseRouteError);
    return e !== void 0 ? e : (t = r.errors) == null ? void 0 : t[n]
}
function RP() {
    let {router: t} = kP(lb.UseNavigateStable)
      , e = cb(Tc.UseNavigateStable)
      , r = y.useRef(!1);
    return ab( () => {
        r.current = !0
    }
    ),
    y.useCallback(function(s, i) {
        i === void 0 && (i = {}),
        r.current && (typeof s == "number" ? t.navigate(s) : t.navigate(s, Sa({
            fromRouteId: e
        }, i)))
    }, [t, e])
}
function NP(t, e) {
    t == null || t.v7_startTransition,
    t == null || t.v7_relativeSplatPath
}
function ii(t) {
    We(!1)
}
function PP(t) {
    let {basename: e="/", children: r=null, location: n, navigationType: s=Pn.Pop, navigator: i, static: o=!1, future: a} = t;
    qa() && We(!1);
    let l = e.replace(/^\/*/, "/")
      , c = y.useMemo( () => ({
        basename: l,
        navigator: i,
        static: o,
        future: Sa({
            v7_relativeSplatPath: !1
        }, a)
    }), [l, a, i, o]);
    typeof n == "string" && (n = yo(n));
    let {pathname: u="/", search: h="", hash: p="", state: f=null, key: b="default"} = n
      , m = y.useMemo( () => {
        let x = io(u, l);
        return x == null ? null : {
            location: {
                pathname: x,
                search: h,
                hash: p,
                state: f,
                key: b
            },
            navigationType: s
        }
    }
    , [l, u, h, p, f, b, s]);
    return m == null ? null : y.createElement(es.Provider, {
        value: c
    }, y.createElement(fu.Provider, {
        children: r,
        value: m
    }))
}
function AP(t) {
    let {children: e, location: r} = t;
    return vP(Hh(e), r)
}
new Promise( () => {}
);
function Hh(t, e) {
    e === void 0 && (e = []);
    let r = [];
    return y.Children.forEach(t, (n, s) => {
        if (!y.isValidElement(n))
            return;
        let i = [...e, s];
        if (n.type === y.Fragment) {
            r.push.apply(r, Hh(n.props.children, i));
            return
        }
        n.type !== ii && We(!1),
        !n.props.index || !n.props.children || We(!1);
        let o = {
            id: n.props.id || i.join("-"),
            caseSensitive: n.props.caseSensitive,
            element: n.props.element,
            Component: n.props.Component,
            index: n.props.index,
            path: n.props.path,
            loader: n.props.loader,
            action: n.props.action,
            errorElement: n.props.errorElement,
            ErrorBoundary: n.props.ErrorBoundary,
            hasErrorBoundary: n.props.ErrorBoundary != null || n.props.errorElement != null,
            shouldRevalidate: n.props.shouldRevalidate,
            handle: n.props.handle,
            lazy: n.props.lazy
        };
        n.props.children && (o.children = Hh(n.props.children, i)),
        r.push(o)
    }
    ),
    r
}
/**
 * React Router DOM v6.30.1
 *
 * Copyright (c) Remix Software Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE.md file in the root directory of this source tree.
 *
 * @license MIT
 */
function Rc() {
    return Rc = Object.assign ? Object.assign.bind() : function(t) {
        for (var e = 1; e < arguments.length; e++) {
            var r = arguments[e];
            for (var n in r)
                Object.prototype.hasOwnProperty.call(r, n) && (t[n] = r[n])
        }
        return t
    }
    ,
    Rc.apply(this, arguments)
}
function ub(t, e) {
    if (t == null)
        return {};
    var r = {}, n = Object.keys(t), s, i;
    for (i = 0; i < n.length; i++)
        s = n[i],
        !(e.indexOf(s) >= 0) && (r[s] = t[s]);
    return r
}
function jP(t) {
    return !!(t.metaKey || t.altKey || t.ctrlKey || t.shiftKey)
}
function OP(t, e) {
    return t.button === 0 && (!e || e === "_self") && !jP(t)
}
function Kh(t) {
    return t === void 0 && (t = ""),
    new URLSearchParams(typeof t == "string" || Array.isArray(t) || t instanceof URLSearchParams ? t : Object.keys(t).reduce( (e, r) => {
        let n = t[r];
        return e.concat(Array.isArray(n) ? n.map(s => [r, s]) : [[r, n]])
    }
    , []))
}
function IP(t, e) {
    let r = Kh(t);
    return e && e.forEach( (n, s) => {
        r.has(s) || e.getAll(s).forEach(i => {
            r.append(s, i)
        }
        )
    }
    ),
    r
}
const LP = ["onClick", "relative", "reloadDocument", "replace", "state", "target", "to", "preventScrollReset", "viewTransition"]
  , $P = ["aria-current", "caseSensitive", "className", "end", "style", "to", "viewTransition", "children"]
  , DP = "6";
try {
    window.__reactRouterVersion = DP
} catch {}
const MP = y.createContext({
    isTransitioning: !1
})
  , FP = "startTransition"
  , Jg = Ef[FP];
function UP(t) {
    let {basename: e, children: r, future: n, window: s} = t
      , i = y.useRef();
    i.current == null && (i.current = WN({
        window: s,
        v5Compat: !0
    }));
    let o = i.current
      , [a,l] = y.useState({
        action: o.action,
        location: o.location
    })
      , {v7_startTransition: c} = n || {}
      , u = y.useCallback(h => {
        c && Jg ? Jg( () => l(h)) : l(h)
    }
    , [l, c]);
    return y.useLayoutEffect( () => o.listen(u), [o, u]),
    y.useEffect( () => NP(n), [n]),
    y.createElement(PP, {
        basename: e,
        children: r,
        location: a.location,
        navigationType: a.action,
        navigator: o,
        future: n
    })
}
const BP = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"
  , zP = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i
  , VP = y.forwardRef(function(e, r) {
    let {onClick: n, relative: s, reloadDocument: i, replace: o, state: a, target: l, to: c, preventScrollReset: u, viewTransition: h} = e, p = ub(e, LP), {basename: f} = y.useContext(es), b, m = !1;
    if (typeof c == "string" && zP.test(c) && (b = c,
    BP))
        try {
            let v = new URL(window.location.href)
              , _ = c.startsWith("//") ? new URL(v.protocol + c) : new URL(c)
              , S = io(_.pathname, f);
            _.origin === v.origin && S != null ? c = S + _.search + _.hash : m = !0
        } catch {}
    let x = mP(c, {
        relative: s
    })
      , w = KP(c, {
        replace: o,
        state: a,
        target: l,
        preventScrollReset: u,
        relative: s,
        viewTransition: h
    });
    function g(v) {
        n && n(v),
        v.defaultPrevented || w(v)
    }
    return y.createElement("a", Rc({}, p, {
        href: b || x,
        onClick: m || i ? n : g,
        ref: r,
        target: l
    }))
})
  , WP = y.forwardRef(function(e, r) {
    let {"aria-current": n="page", caseSensitive: s=!1, className: i="", end: o=!1, style: a, to: l, viewTransition: c, children: u} = e
      , h = ub(e, $P)
      , p = pu(l, {
        relative: h.relative
    })
      , f = Ws()
      , b = y.useContext(ib)
      , {navigator: m, basename: x} = y.useContext(es)
      , w = b != null && GP(p) && c === !0
      , g = m.encodeLocation ? m.encodeLocation(p).pathname : p.pathname
      , v = f.pathname
      , _ = b && b.navigation && b.navigation.location ? b.navigation.location.pathname : null;
    s || (v = v.toLowerCase(),
    _ = _ ? _.toLowerCase() : null,
    g = g.toLowerCase()),
    _ && x && (_ = io(_, x) || _);
    const S = g !== "/" && g.endsWith("/") ? g.length - 1 : g.length;
    let k = v === g || !o && v.startsWith(g) && v.charAt(S) === "/", C = _ != null && (_ === g || !o && _.startsWith(g) && _.charAt(g.length) === "/"), T = {
        isActive: k,
        isPending: C,
        isTransitioning: w
    }, A = k ? n : void 0, P;
    typeof i == "function" ? P = i(T) : P = [i, k ? "active" : null, C ? "pending" : null, w ? "transitioning" : null].filter(Boolean).join(" ");
    let B = typeof a == "function" ? a(T) : a;
    return y.createElement(VP, Rc({}, h, {
        "aria-current": A,
        className: P,
        ref: r,
        style: B,
        to: l,
        viewTransition: c
    }), typeof u == "function" ? u(T) : u)
});
var qh;
(function(t) {
    t.UseScrollRestoration = "useScrollRestoration",
    t.UseSubmit = "useSubmit",
    t.UseSubmitFetcher = "useSubmitFetcher",
    t.UseFetcher = "useFetcher",
    t.useViewTransitionState = "useViewTransitionState"
}
)(qh || (qh = {}));
var Zg;
(function(t) {
    t.UseFetcher = "useFetcher",
    t.UseFetchers = "useFetchers",
    t.UseScrollRestoration = "useScrollRestoration"
}
)(Zg || (Zg = {}));
function HP(t) {
    let e = y.useContext(hu);
    return e || We(!1),
    e
}
function KP(t, e) {
    let {target: r, replace: n, state: s, preventScrollReset: i, relative: o, viewTransition: a} = e === void 0 ? {} : e
      , l = Ga()
      , c = Ws()
      , u = pu(t, {
        relative: o
    });
    return y.useCallback(h => {
        if (OP(h, r)) {
            h.preventDefault();
            let p = n !== void 0 ? n : Ec(c) === Ec(u);
            l(t, {
                replace: p,
                state: s,
                preventScrollReset: i,
                relative: o,
                viewTransition: a
            })
        }
    }
    , [c, l, u, n, s, r, t, i, o, a])
}
function qP(t) {
    let e = y.useRef(Kh(t))
      , r = y.useRef(!1)
      , n = Ws()
      , s = y.useMemo( () => IP(n.search, r.current ? null : e.current), [n.search])
      , i = Ga()
      , o = y.useCallback( (a, l) => {
        const c = Kh(typeof a == "function" ? a(s) : a);
        r.current = !0,
        i("?" + c, l)
    }
    , [i, s]);
    return [s, o]
}
function GP(t, e) {
    e === void 0 && (e = {});
    let r = y.useContext(MP);
    r == null && We(!1);
    let {basename: n} = HP(qh.useViewTransitionState)
      , s = pu(t, {
        relative: e.relative
    });
    if (!r.isTransitioning)
        return !1;
    let i = io(r.currentLocation.pathname, n) || r.currentLocation.pathname
      , o = io(r.nextLocation.pathname, n) || r.nextLocation.pathname;
    return Cc(s.pathname, o) != null || Cc(s.pathname, i) != null
}
const QP = iu("inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium font-heading ring-offset-background transition-all duration-300 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0", {
    variants: {
        variant: {
            default: "bg-primary text-primary-foreground hover:bg-primary/90",
            destructive: "bg-destructive text-destructive-foreground hover:bg-destructive/90",
            outline: "border border-input bg-background hover:bg-accent hover:text-accent-foreground",
            secondary: "bg-secondary text-secondary-foreground hover:bg-secondary/80",
            ghost: "hover:bg-accent hover:text-accent-foreground",
            link: "text-primary underline-offset-4 hover:underline",
            glow: "bg-primary text-primary-foreground hover:bg-primary/90 shadow-[0_0_20px_hsl(var(--glow-primary)/0.4)] hover:shadow-[0_0_30px_hsl(var(--glow-primary)/0.6)]",
            glass: "bg-card/60 backdrop-blur-xl border border-border/50 text-foreground hover:bg-card/80 hover:border-primary/50"
        },
        size: {
            default: "h-10 px-4 py-2",
            sm: "h-9 rounded-md px-3",
            lg: "h-12 rounded-lg px-8 text-base",
            xl: "h-14 rounded-lg px-10 text-lg",
            icon: "h-10 w-10"
        }
    },
    defaultVariants: {
        variant: "default",
        size: "default"
    }
})
  , Ye = y.forwardRef( ({className: t, variant: e, size: r, asChild: n=!1, ...s}, i) => {
    const o = n ? nE : "button";
    return d.jsx(o, {
        className: me(QP({
            variant: e,
            size: r,
            className: t
        })),
        ref: i,
        ...s
    })
}
);
Ye.displayName = "Button";
const jt = y.forwardRef( ({className: t, ...e}, r) => d.jsx("div", {
    ref: r,
    className: me("rounded-lg border bg-card text-card-foreground shadow-sm", t),
    ...e
}));
jt.displayName = "Card";
const Jt = y.forwardRef( ({className: t, ...e}, r) => d.jsx("div", {
    ref: r,
    className: me("flex flex-col space-y-1.5 p-6", t),
    ...e
}));
Jt.displayName = "CardHeader";
const Zt = y.forwardRef( ({className: t, ...e}, r) => d.jsx("h3", {
    ref: r,
    className: me("text-2xl font-semibold leading-none tracking-tight", t),
    ...e
}));
Zt.displayName = "CardTitle";
const oo = y.forwardRef( ({className: t, ...e}, r) => d.jsx("p", {
    ref: r,
    className: me("text-sm text-muted-foreground", t),
    ...e
}));
oo.displayName = "CardDescription";
const Ot = y.forwardRef( ({className: t, ...e}, r) => d.jsx("div", {
    ref: r,
    className: me("p-6 pt-0", t),
    ...e
}));
Ot.displayName = "CardContent";
const JP = y.forwardRef( ({className: t, ...e}, r) => d.jsx("div", {
    ref: r,
    className: me("flex items-center p-6 pt-0", t),
    ...e
}));
JP.displayName = "CardFooter";
var mu = "Collapsible"
  , [ZP,db] = tn(mu)
  , [YP,$p] = ZP(mu)
  , hb = y.forwardRef( (t, e) => {
    const {__scopeCollapsible: r, open: n, defaultOpen: s, disabled: i, onOpenChange: o, ...a} = t
      , [l,c] = Kn({
        prop: n,
        defaultProp: s ?? !1,
        onChange: o,
        caller: mu
    });
    return d.jsx(YP, {
        scope: r,
        disabled: i,
        contentId: zs(),
        open: l,
        onOpenToggle: y.useCallback( () => c(u => !u), [c]),
        children: d.jsx(le.div, {
            "data-state": Mp(l),
            "data-disabled": i ? "" : void 0,
            ...a,
            ref: e
        })
    })
}
);
hb.displayName = mu;
var fb = "CollapsibleTrigger"
  , pb = y.forwardRef( (t, e) => {
    const {__scopeCollapsible: r, ...n} = t
      , s = $p(fb, r);
    return d.jsx(le.button, {
        type: "button",
        "aria-controls": s.contentId,
        "aria-expanded": s.open || !1,
        "data-state": Mp(s.open),
        "data-disabled": s.disabled ? "" : void 0,
        disabled: s.disabled,
        ...n,
        ref: e,
        onClick: te(t.onClick, s.onOpenToggle)
    })
}
);
pb.displayName = fb;
var Dp = "CollapsibleContent"
  , mb = y.forwardRef( (t, e) => {
    const {forceMount: r, ...n} = t
      , s = $p(Dp, t.__scopeCollapsible);
    return d.jsx(za, {
        present: r || s.open,
        children: ({present: i}) => d.jsx(XP, {
            ...n,
            ref: e,
            present: i
        })
    })
}
);
mb.displayName = Dp;
var XP = y.forwardRef( (t, e) => {
    const {__scopeCollapsible: r, present: n, children: s, ...i} = t
      , o = $p(Dp, r)
      , [a,l] = y.useState(n)
      , c = y.useRef(null)
      , u = Ae(e, c)
      , h = y.useRef(0)
      , p = h.current
      , f = y.useRef(0)
      , b = f.current
      , m = o.open || a
      , x = y.useRef(m)
      , w = y.useRef(void 0);
    return y.useEffect( () => {
        const g = requestAnimationFrame( () => x.current = !1);
        return () => cancelAnimationFrame(g)
    }
    , []),
    et( () => {
        const g = c.current;
        if (g) {
            w.current = w.current || {
                transitionDuration: g.style.transitionDuration,
                animationName: g.style.animationName
            },
            g.style.transitionDuration = "0s",
            g.style.animationName = "none";
            const v = g.getBoundingClientRect();
            h.current = v.height,
            f.current = v.width,
            x.current || (g.style.transitionDuration = w.current.transitionDuration,
            g.style.animationName = w.current.animationName),
            l(n)
        }
    }
    , [o.open, n]),
    d.jsx(le.div, {
        "data-state": Mp(o.open),
        "data-disabled": o.disabled ? "" : void 0,
        id: o.contentId,
        hidden: !m,
        ...i,
        ref: u,
        style: {
            "--radix-collapsible-content-height": p ? `${p}px` : void 0,
            "--radix-collapsible-content-width": b ? `${b}px` : void 0,
            ...t.style
        },
        children: m && s
    })
}
);
function Mp(t) {
    return t ? "open" : "closed"
}
var eA = hb
  , tA = pb
  , rA = mb
  , nA = y.createContext(void 0);
function gu(t) {
    const e = y.useContext(nA);
    return t || e || "ltr"
}
var _r = "Accordion"
  , sA = ["Home", "End", "ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"]
  , [Fp,iA,oA] = tu(_r)
  , [vu,LL] = tn(_r, [oA, db])
  , Up = db()
  , gb = j.forwardRef( (t, e) => {
    const {type: r, ...n} = t
      , s = n
      , i = n;
    return d.jsx(Fp.Provider, {
        scope: t.__scopeAccordion,
        children: r === "multiple" ? d.jsx(uA, {
            ...i,
            ref: e
        }) : d.jsx(cA, {
            ...s,
            ref: e
        })
    })
}
);
gb.displayName = _r;
var [vb,aA] = vu(_r)
  , [yb,lA] = vu(_r, {
    collapsible: !1
})
  , cA = j.forwardRef( (t, e) => {
    const {value: r, defaultValue: n, onValueChange: s= () => {}
    , collapsible: i=!1, ...o} = t
      , [a,l] = Kn({
        prop: r,
        defaultProp: n ?? "",
        onChange: s,
        caller: _r
    });
    return d.jsx(vb, {
        scope: t.__scopeAccordion,
        value: j.useMemo( () => a ? [a] : [], [a]),
        onItemOpen: l,
        onItemClose: j.useCallback( () => i && l(""), [i, l]),
        children: d.jsx(yb, {
            scope: t.__scopeAccordion,
            collapsible: i,
            children: d.jsx(wb, {
                ...o,
                ref: e
            })
        })
    })
}
)
  , uA = j.forwardRef( (t, e) => {
    const {value: r, defaultValue: n, onValueChange: s= () => {}
    , ...i} = t
      , [o,a] = Kn({
        prop: r,
        defaultProp: n ?? [],
        onChange: s,
        caller: _r
    })
      , l = j.useCallback(u => a( (h=[]) => [...h, u]), [a])
      , c = j.useCallback(u => a( (h=[]) => h.filter(p => p !== u)), [a]);
    return d.jsx(vb, {
        scope: t.__scopeAccordion,
        value: o,
        onItemOpen: l,
        onItemClose: c,
        children: d.jsx(yb, {
            scope: t.__scopeAccordion,
            collapsible: !0,
            children: d.jsx(wb, {
                ...i,
                ref: e
            })
        })
    })
}
)
  , [dA,yu] = vu(_r)
  , wb = j.forwardRef( (t, e) => {
    const {__scopeAccordion: r, disabled: n, dir: s, orientation: i="vertical", ...o} = t
      , a = j.useRef(null)
      , l = Ae(a, e)
      , c = iA(r)
      , h = gu(s) === "ltr"
      , p = te(t.onKeyDown, f => {
        var T;
        if (!sA.includes(f.key))
            return;
        const b = f.target
          , m = c().filter(A => {
            var P;
            return !((P = A.ref.current) != null && P.disabled)
        }
        )
          , x = m.findIndex(A => A.ref.current === b)
          , w = m.length;
        if (x === -1)
            return;
        f.preventDefault();
        let g = x;
        const v = 0
          , _ = w - 1
          , S = () => {
            g = x + 1,
            g > _ && (g = v)
        }
          , k = () => {
            g = x - 1,
            g < v && (g = _)
        }
        ;
        switch (f.key) {
        case "Home":
            g = v;
            break;
        case "End":
            g = _;
            break;
        case "ArrowRight":
            i === "horizontal" && (h ? S() : k());
            break;
        case "ArrowDown":
            i === "vertical" && S();
            break;
        case "ArrowLeft":
            i === "horizontal" && (h ? k() : S());
            break;
        case "ArrowUp":
            i === "vertical" && k();
            break
        }
        const C = g % w;
        (T = m[C].ref.current) == null || T.focus()
    }
    );
    return d.jsx(dA, {
        scope: r,
        disabled: n,
        direction: s,
        orientation: i,
        children: d.jsx(Fp.Slot, {
            scope: r,
            children: d.jsx(le.div, {
                ...o,
                "data-orientation": i,
                ref: l,
                onKeyDown: n ? void 0 : p
            })
        })
    })
}
)
  , Nc = "AccordionItem"
  , [hA,Bp] = vu(Nc)
  , xb = j.forwardRef( (t, e) => {
    const {__scopeAccordion: r, value: n, ...s} = t
      , i = yu(Nc, r)
      , o = aA(Nc, r)
      , a = Up(r)
      , l = zs()
      , c = n && o.value.includes(n) || !1
      , u = i.disabled || t.disabled;
    return d.jsx(hA, {
        scope: r,
        open: c,
        disabled: u,
        triggerId: l,
        children: d.jsx(eA, {
            "data-orientation": i.orientation,
            "data-state": Cb(c),
            ...a,
            ...s,
            ref: e,
            disabled: u,
            open: c,
            onOpenChange: h => {
                h ? o.onItemOpen(n) : o.onItemClose(n)
            }
        })
    })
}
);
xb.displayName = Nc;
var bb = "AccordionHeader"
  , _b = j.forwardRef( (t, e) => {
    const {__scopeAccordion: r, ...n} = t
      , s = yu(_r, r)
      , i = Bp(bb, r);
    return d.jsx(le.h3, {
        "data-orientation": s.orientation,
        "data-state": Cb(i.open),
        "data-disabled": i.disabled ? "" : void 0,
        ...n,
        ref: e
    })
}
);
_b.displayName = bb;
var Gh = "AccordionTrigger"
  , Sb = j.forwardRef( (t, e) => {
    const {__scopeAccordion: r, ...n} = t
      , s = yu(_r, r)
      , i = Bp(Gh, r)
      , o = lA(Gh, r)
      , a = Up(r);
    return d.jsx(Fp.ItemSlot, {
        scope: r,
        children: d.jsx(tA, {
            "aria-disabled": i.open && !o.collapsible || void 0,
            "data-orientation": s.orientation,
            id: i.triggerId,
            ...a,
            ...n,
            ref: e
        })
    })
}
);
Sb.displayName = Gh;
var kb = "AccordionContent"
  , Eb = j.forwardRef( (t, e) => {
    const {__scopeAccordion: r, ...n} = t
      , s = yu(_r, r)
      , i = Bp(kb, r)
      , o = Up(r);
    return d.jsx(rA, {
        role: "region",
        "aria-labelledby": i.triggerId,
        "data-orientation": s.orientation,
        ...o,
        ...n,
        ref: e,
        style: {
            "--radix-accordion-content-height": "var(--radix-collapsible-content-height)",
            "--radix-accordion-content-width": "var(--radix-collapsible-content-width)",
            ...t.style
        }
    })
}
);
Eb.displayName = kb;
function Cb(t) {
    return t ? "open" : "closed"
}
var fA = gb
  , pA = xb
  , mA = _b
  , Tb = Sb
  , Rb = Eb;
const gA = fA
  , Nb = y.forwardRef( ({className: t, ...e}, r) => d.jsx(pA, {
    ref: r,
    className: me("border-b", t),
    ...e
}));
Nb.displayName = "AccordionItem";
const Pb = y.forwardRef( ({className: t, children: e, ...r}, n) => d.jsx(mA, {
    className: "flex",
    children: d.jsxs(Tb, {
        ref: n,
        className: me("flex flex-1 items-center justify-between py-4 font-medium transition-all hover:underline [&[data-state=open]>svg]:rotate-180", t),
        ...r,
        children: [e, d.jsx(xp, {
            className: "h-4 w-4 shrink-0 transition-transform duration-200"
        })]
    })
}));
Pb.displayName = Tb.displayName;
const Ab = y.forwardRef( ({className: t, children: e, ...r}, n) => d.jsx(Rb, {
    ref: n,
    className: "overflow-hidden text-sm transition-all data-[state=closed]:animate-accordion-up data-[state=open]:animate-accordion-down",
    ...r,
    children: d.jsx("div", {
        className: me("pb-4 pt-0", t),
        children: e
    })
}));
Ab.displayName = Rb.displayName;
var Nr = function() {
    return Nr = Object.assign || function(e) {
        for (var r, n = 1, s = arguments.length; n < s; n++) {
            r = arguments[n];
            for (var i in r)
                Object.prototype.hasOwnProperty.call(r, i) && (e[i] = r[i])
        }
        return e
    }
    ,
    Nr.apply(this, arguments)
};
function wo(t, e) {
    var r = {};
    for (var n in t)
        Object.prototype.hasOwnProperty.call(t, n) && e.indexOf(n) < 0 && (r[n] = t[n]);
    if (t != null && typeof Object.getOwnPropertySymbols == "function")
        for (var s = 0, n = Object.getOwnPropertySymbols(t); s < n.length; s++)
            e.indexOf(n[s]) < 0 && Object.prototype.propertyIsEnumerable.call(t, n[s]) && (r[n[s]] = t[n[s]]);
    return r
}
function vA(t, e, r, n) {
    function s(i) {
        return i instanceof r ? i : new r(function(o) {
            o(i)
        }
        )
    }
    return new (r || (r = Promise))(function(i, o) {
        function a(u) {
            try {
                c(n.next(u))
            } catch (h) {
                o(h)
            }
        }
        function l(u) {
            try {
                c(n.throw(u))
            } catch (h) {
                o(h)
            }
        }
        function c(u) {
            u.done ? i(u.value) : s(u.value).then(a, l)
        }
        c((n = n.apply(t, e || [])).next())
    }
    )
}
function yA(t, e, r) {
    if (r || arguments.length === 2)
        for (var n = 0, s = e.length, i; n < s; n++)
            (i || !(n in e)) && (i || (i = Array.prototype.slice.call(e, 0, n)),
            i[n] = e[n]);
    return t.concat(i || Array.prototype.slice.call(e))
}
const wA = t => t ? (...e) => t(...e) : (...e) => fetch(...e);
class zp extends Error {
    constructor(e, r="FunctionsError", n) {
        super(e),
        this.name = r,
        this.context = n
    }
}
class xA extends zp {
    constructor(e) {
        super("Failed to send a request to the Edge Function", "FunctionsFetchError", e)
    }
}
class Yg extends zp {
    constructor(e) {
        super("Relay Error invoking the Edge Function", "FunctionsRelayError", e)
    }
}
class Xg extends zp {
    constructor(e) {
        super("Edge Function returned a non-2xx status code", "FunctionsHttpError", e)
    }
}
var Qh;
(function(t) {
    t.Any = "any",
    t.ApNortheast1 = "ap-northeast-1",
    t.ApNortheast2 = "ap-northeast-2",
    t.ApSouth1 = "ap-south-1",
    t.ApSoutheast1 = "ap-southeast-1",
    t.ApSoutheast2 = "ap-southeast-2",
    t.CaCentral1 = "ca-central-1",
    t.EuCentral1 = "eu-central-1",
    t.EuWest1 = "eu-west-1",
    t.EuWest2 = "eu-west-2",
    t.EuWest3 = "eu-west-3",
    t.SaEast1 = "sa-east-1",
    t.UsEast1 = "us-east-1",
    t.UsWest1 = "us-west-1",
    t.UsWest2 = "us-west-2"
}
)(Qh || (Qh = {}));
class bA {
    constructor(e, {headers: r={}, customFetch: n, region: s=Qh.Any}={}) {
        this.url = e,
        this.headers = r,
        this.region = s,
        this.fetch = wA(n)
    }
    setAuth(e) {
        this.headers.Authorization = `Bearer ${e}`
    }
    invoke(e) {
        return vA(this, arguments, void 0, function*(r, n={}) {
            var s;
            let i, o;
            try {
                const {headers: a, method: l, body: c, signal: u, timeout: h} = n;
                let p = {}
                  , {region: f} = n;
                f || (f = this.region);
                const b = new URL(`${this.url}/${r}`);
                f && f !== "any" && (p["x-region"] = f,
                b.searchParams.set("forceFunctionRegion", f));
                let m;
                c && (a && !Object.prototype.hasOwnProperty.call(a, "Content-Type") || !a) ? typeof Blob < "u" && c instanceof Blob || c instanceof ArrayBuffer ? (p["Content-Type"] = "application/octet-stream",
                m = c) : typeof c == "string" ? (p["Content-Type"] = "text/plain",
                m = c) : typeof FormData < "u" && c instanceof FormData ? m = c : (p["Content-Type"] = "application/json",
                m = JSON.stringify(c)) : c && typeof c != "string" && !(typeof Blob < "u" && c instanceof Blob) && !(c instanceof ArrayBuffer) && !(typeof FormData < "u" && c instanceof FormData) ? m = JSON.stringify(c) : m = c;
                let x = u;
                h && (o = new AbortController,
                i = setTimeout( () => o.abort(), h),
                u ? (x = o.signal,
                u.addEventListener("abort", () => o.abort())) : x = o.signal);
                const w = yield this.fetch(b.toString(), {
                    method: l || "POST",
                    headers: Object.assign(Object.assign(Object.assign({}, p), this.headers), a),
                    body: m,
                    signal: x
                }).catch(S => {
                    throw new xA(S)
                }
                )
                  , g = w.headers.get("x-relay-error");
                if (g && g === "true")
                    throw new Yg(w);
                if (!w.ok)
                    throw new Xg(w);
                let v = ((s = w.headers.get("Content-Type")) !== null && s !== void 0 ? s : "text/plain").split(";")[0].trim(), _;
                return v === "application/json" ? _ = yield w.json() : v === "application/octet-stream" || v === "application/pdf" ? _ = yield w.blob() : v === "text/event-stream" ? _ = w : v === "multipart/form-data" ? _ = yield w.formData() : _ = yield w.text(),
                {
                    data: _,
                    error: null,
                    response: w
                }
            } catch (a) {
                return {
                    data: null,
                    error: a,
                    response: a instanceof Xg || a instanceof Yg ? a.context : void 0
                }
            } finally {
                i && clearTimeout(i)
            }
        })
    }
}
var _A = class extends Error {
    constructor(t) {
        super(t.message),
        this.name = "PostgrestError",
        this.details = t.details,
        this.hint = t.hint,
        this.code = t.code
    }
}
  , SA = class {
    constructor(t) {
        var e, r;
        this.shouldThrowOnError = !1,
        this.method = t.method,
        this.url = t.url,
        this.headers = new Headers(t.headers),
        this.schema = t.schema,
        this.body = t.body,
        this.shouldThrowOnError = (e = t.shouldThrowOnError) !== null && e !== void 0 ? e : !1,
        this.signal = t.signal,
        this.isMaybeSingle = (r = t.isMaybeSingle) !== null && r !== void 0 ? r : !1,
        t.fetch ? this.fetch = t.fetch : this.fetch = fetch
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    setHeader(t, e) {
        return this.headers = new Headers(this.headers),
        this.headers.set(t, e),
        this
    }
    then(t, e) {
        var r = this;
        this.schema === void 0 || (["GET", "HEAD"].includes(this.method) ? this.headers.set("Accept-Profile", this.schema) : this.headers.set("Content-Profile", this.schema)),
        this.method !== "GET" && this.method !== "HEAD" && this.headers.set("Content-Type", "application/json");
        const n = this.fetch;
        let s = n(this.url.toString(), {
            method: this.method,
            headers: this.headers,
            body: JSON.stringify(this.body),
            signal: this.signal
        }).then(async i => {
            let o = null
              , a = null
              , l = null
              , c = i.status
              , u = i.statusText;
            if (i.ok) {
                var h, p;
                if (r.method !== "HEAD") {
                    var f;
                    const w = await i.text();
                    w === "" || (r.headers.get("Accept") === "text/csv" || r.headers.get("Accept") && (!((f = r.headers.get("Accept")) === null || f === void 0) && f.includes("application/vnd.pgrst.plan+text")) ? a = w : a = JSON.parse(w))
                }
                const m = (h = r.headers.get("Prefer")) === null || h === void 0 ? void 0 : h.match(/count=(exact|planned|estimated)/)
                  , x = (p = i.headers.get("content-range")) === null || p === void 0 ? void 0 : p.split("/");
                m && x && x.length > 1 && (l = parseInt(x[1])),
                r.isMaybeSingle && r.method === "GET" && Array.isArray(a) && (a.length > 1 ? (o = {
                    code: "PGRST116",
                    details: `Results contain ${a.length} rows, application/vnd.pgrst.object+json requires 1 row`,
                    hint: null,
                    message: "JSON object requested, multiple (or no) rows returned"
                },
                a = null,
                l = null,
                c = 406,
                u = "Not Acceptable") : a.length === 1 ? a = a[0] : a = null)
            } else {
                var b;
                const m = await i.text();
                try {
                    o = JSON.parse(m),
                    Array.isArray(o) && i.status === 404 && (a = [],
                    o = null,
                    c = 200,
                    u = "OK")
                } catch {
                    i.status === 404 && m === "" ? (c = 204,
                    u = "No Content") : o = {
                        message: m
                    }
                }
                if (o && r.isMaybeSingle && (!(o == null || (b = o.details) === null || b === void 0) && b.includes("0 rows")) && (o = null,
                c = 200,
                u = "OK"),
                o && r.shouldThrowOnError)
                    throw new _A(o)
            }
            return {
                error: o,
                data: a,
                count: l,
                status: c,
                statusText: u
            }
        }
        );
        return this.shouldThrowOnError || (s = s.catch(i => {
            var o;
            let a = "";
            const l = i == null ? void 0 : i.cause;
            if (l) {
                var c, u, h, p;
                const b = (c = l == null ? void 0 : l.message) !== null && c !== void 0 ? c : ""
                  , m = (u = l == null ? void 0 : l.code) !== null && u !== void 0 ? u : "";
                a = `${(h = i == null ? void 0 : i.name) !== null && h !== void 0 ? h : "FetchError"}: ${i == null ? void 0 : i.message}`,
                a += `

Caused by: ${(p = l == null ? void 0 : l.name) !== null && p !== void 0 ? p : "Error"}: ${b}`,
                m && (a += ` (${m})`),
                l != null && l.stack && (a += `
${l.stack}`)
            } else {
                var f;
                a = (f = i == null ? void 0 : i.stack) !== null && f !== void 0 ? f : ""
            }
            return {
                error: {
                    message: `${(o = i == null ? void 0 : i.name) !== null && o !== void 0 ? o : "FetchError"}: ${i == null ? void 0 : i.message}`,
                    details: a,
                    hint: "",
                    code: ""
                },
                data: null,
                count: null,
                status: 0,
                statusText: ""
            }
        }
        )),
        s.then(t, e)
    }
    returns() {
        return this
    }
    overrideTypes() {
        return this
    }
}
  , kA = class extends SA {
    select(t) {
        let e = !1;
        const r = (t ?? "*").split("").map(n => /\s/.test(n) && !e ? "" : (n === '"' && (e = !e),
        n)).join("");
        return this.url.searchParams.set("select", r),
        this.headers.append("Prefer", "return=representation"),
        this
    }
    order(t, {ascending: e=!0, nullsFirst: r, foreignTable: n, referencedTable: s=n}={}) {
        const i = s ? `${s}.order` : "order"
          , o = this.url.searchParams.get(i);
        return this.url.searchParams.set(i, `${o ? `${o},` : ""}${t}.${e ? "asc" : "desc"}${r === void 0 ? "" : r ? ".nullsfirst" : ".nullslast"}`),
        this
    }
    limit(t, {foreignTable: e, referencedTable: r=e}={}) {
        const n = typeof r > "u" ? "limit" : `${r}.limit`;
        return this.url.searchParams.set(n, `${t}`),
        this
    }
    range(t, e, {foreignTable: r, referencedTable: n=r}={}) {
        const s = typeof n > "u" ? "offset" : `${n}.offset`
          , i = typeof n > "u" ? "limit" : `${n}.limit`;
        return this.url.searchParams.set(s, `${t}`),
        this.url.searchParams.set(i, `${e - t + 1}`),
        this
    }
    abortSignal(t) {
        return this.signal = t,
        this
    }
    single() {
        return this.headers.set("Accept", "application/vnd.pgrst.object+json"),
        this
    }
    maybeSingle() {
        return this.method === "GET" ? this.headers.set("Accept", "application/json") : this.headers.set("Accept", "application/vnd.pgrst.object+json"),
        this.isMaybeSingle = !0,
        this
    }
    csv() {
        return this.headers.set("Accept", "text/csv"),
        this
    }
    geojson() {
        return this.headers.set("Accept", "application/geo+json"),
        this
    }
    explain({analyze: t=!1, verbose: e=!1, settings: r=!1, buffers: n=!1, wal: s=!1, format: i="text"}={}) {
        var o;
        const a = [t ? "analyze" : null, e ? "verbose" : null, r ? "settings" : null, n ? "buffers" : null, s ? "wal" : null].filter(Boolean).join("|")
          , l = (o = this.headers.get("Accept")) !== null && o !== void 0 ? o : "application/json";
        return this.headers.set("Accept", `application/vnd.pgrst.plan+${i}; for="${l}"; options=${a};`),
        i === "json" ? this : this
    }
    rollback() {
        return this.headers.append("Prefer", "tx=rollback"),
        this
    }
    returns() {
        return this
    }
    maxAffected(t) {
        return this.headers.append("Prefer", "handling=strict"),
        this.headers.append("Prefer", `max-affected=${t}`),
        this
    }
}
;
const ev = new RegExp("[,()]");
var oi = class extends kA {
    eq(t, e) {
        return this.url.searchParams.append(t, `eq.${e}`),
        this
    }
    neq(t, e) {
        return this.url.searchParams.append(t, `neq.${e}`),
        this
    }
    gt(t, e) {
        return this.url.searchParams.append(t, `gt.${e}`),
        this
    }
    gte(t, e) {
        return this.url.searchParams.append(t, `gte.${e}`),
        this
    }
    lt(t, e) {
        return this.url.searchParams.append(t, `lt.${e}`),
        this
    }
    lte(t, e) {
        return this.url.searchParams.append(t, `lte.${e}`),
        this
    }
    like(t, e) {
        return this.url.searchParams.append(t, `like.${e}`),
        this
    }
    likeAllOf(t, e) {
        return this.url.searchParams.append(t, `like(all).{${e.join(",")}}`),
        this
    }
    likeAnyOf(t, e) {
        return this.url.searchParams.append(t, `like(any).{${e.join(",")}}`),
        this
    }
    ilike(t, e) {
        return this.url.searchParams.append(t, `ilike.${e}`),
        this
    }
    ilikeAllOf(t, e) {
        return this.url.searchParams.append(t, `ilike(all).{${e.join(",")}}`),
        this
    }
    ilikeAnyOf(t, e) {
        return this.url.searchParams.append(t, `ilike(any).{${e.join(",")}}`),
        this
    }
    regexMatch(t, e) {
        return this.url.searchParams.append(t, `match.${e}`),
        this
    }
    regexIMatch(t, e) {
        return this.url.searchParams.append(t, `imatch.${e}`),
        this
    }
    is(t, e) {
        return this.url.searchParams.append(t, `is.${e}`),
        this
    }
    isDistinct(t, e) {
        return this.url.searchParams.append(t, `isdistinct.${e}`),
        this
    }
    in(t, e) {
        const r = Array.from(new Set(e)).map(n => typeof n == "string" && ev.test(n) ? `"${n}"` : `${n}`).join(",");
        return this.url.searchParams.append(t, `in.(${r})`),
        this
    }
    notIn(t, e) {
        const r = Array.from(new Set(e)).map(n => typeof n == "string" && ev.test(n) ? `"${n}"` : `${n}`).join(",");
        return this.url.searchParams.append(t, `not.in.(${r})`),
        this
    }
    contains(t, e) {
        return typeof e == "string" ? this.url.searchParams.append(t, `cs.${e}`) : Array.isArray(e) ? this.url.searchParams.append(t, `cs.{${e.join(",")}}`) : this.url.searchParams.append(t, `cs.${JSON.stringify(e)}`),
        this
    }
    containedBy(t, e) {
        return typeof e == "string" ? this.url.searchParams.append(t, `cd.${e}`) : Array.isArray(e) ? this.url.searchParams.append(t, `cd.{${e.join(",")}}`) : this.url.searchParams.append(t, `cd.${JSON.stringify(e)}`),
        this
    }
    rangeGt(t, e) {
        return this.url.searchParams.append(t, `sr.${e}`),
        this
    }
    rangeGte(t, e) {
        return this.url.searchParams.append(t, `nxl.${e}`),
        this
    }
    rangeLt(t, e) {
        return this.url.searchParams.append(t, `sl.${e}`),
        this
    }
    rangeLte(t, e) {
        return this.url.searchParams.append(t, `nxr.${e}`),
        this
    }
    rangeAdjacent(t, e) {
        return this.url.searchParams.append(t, `adj.${e}`),
        this
    }
    overlaps(t, e) {
        return typeof e == "string" ? this.url.searchParams.append(t, `ov.${e}`) : this.url.searchParams.append(t, `ov.{${e.join(",")}}`),
        this
    }
    textSearch(t, e, {config: r, type: n}={}) {
        let s = "";
        n === "plain" ? s = "pl" : n === "phrase" ? s = "ph" : n === "websearch" && (s = "w");
        const i = r === void 0 ? "" : `(${r})`;
        return this.url.searchParams.append(t, `${s}fts${i}.${e}`),
        this
    }
    match(t) {
        return Object.entries(t).forEach( ([e,r]) => {
            this.url.searchParams.append(e, `eq.${r}`)
        }
        ),
        this
    }
    not(t, e, r) {
        return this.url.searchParams.append(t, `not.${e}.${r}`),
        this
    }
    or(t, {foreignTable: e, referencedTable: r=e}={}) {
        const n = r ? `${r}.or` : "or";
        return this.url.searchParams.append(n, `(${t})`),
        this
    }
    filter(t, e, r) {
        return this.url.searchParams.append(t, `${e}.${r}`),
        this
    }
}
  , EA = class {
    constructor(t, {headers: e={}, schema: r, fetch: n}) {
        this.url = t,
        this.headers = new Headers(e),
        this.schema = r,
        this.fetch = n
    }
    cloneRequestState() {
        return {
            url: new URL(this.url.toString()),
            headers: new Headers(this.headers)
        }
    }
    select(t, e) {
        const {head: r=!1, count: n} = e ?? {}
          , s = r ? "HEAD" : "GET";
        let i = !1;
        const o = (t ?? "*").split("").map(c => /\s/.test(c) && !i ? "" : (c === '"' && (i = !i),
        c)).join("")
          , {url: a, headers: l} = this.cloneRequestState();
        return a.searchParams.set("select", o),
        n && l.append("Prefer", `count=${n}`),
        new oi({
            method: s,
            url: a,
            headers: l,
            schema: this.schema,
            fetch: this.fetch
        })
    }
    insert(t, {count: e, defaultToNull: r=!0}={}) {
        var n;
        const s = "POST"
          , {url: i, headers: o} = this.cloneRequestState();
        if (e && o.append("Prefer", `count=${e}`),
        r || o.append("Prefer", "missing=default"),
        Array.isArray(t)) {
            const a = t.reduce( (l, c) => l.concat(Object.keys(c)), []);
            if (a.length > 0) {
                const l = [...new Set(a)].map(c => `"${c}"`);
                i.searchParams.set("columns", l.join(","))
            }
        }
        return new oi({
            method: s,
            url: i,
            headers: o,
            schema: this.schema,
            body: t,
            fetch: (n = this.fetch) !== null && n !== void 0 ? n : fetch
        })
    }
    upsert(t, {onConflict: e, ignoreDuplicates: r=!1, count: n, defaultToNull: s=!0}={}) {
        var i;
        const o = "POST"
          , {url: a, headers: l} = this.cloneRequestState();
        if (l.append("Prefer", `resolution=${r ? "ignore" : "merge"}-duplicates`),
        e !== void 0 && a.searchParams.set("on_conflict", e),
        n && l.append("Prefer", `count=${n}`),
        s || l.append("Prefer", "missing=default"),
        Array.isArray(t)) {
            const c = t.reduce( (u, h) => u.concat(Object.keys(h)), []);
            if (c.length > 0) {
                const u = [...new Set(c)].map(h => `"${h}"`);
                a.searchParams.set("columns", u.join(","))
            }
        }
        return new oi({
            method: o,
            url: a,
            headers: l,
            schema: this.schema,
            body: t,
            fetch: (i = this.fetch) !== null && i !== void 0 ? i : fetch
        })
    }
    update(t, {count: e}={}) {
        var r;
        const n = "PATCH"
          , {url: s, headers: i} = this.cloneRequestState();
        return e && i.append("Prefer", `count=${e}`),
        new oi({
            method: n,
            url: s,
            headers: i,
            schema: this.schema,
            body: t,
            fetch: (r = this.fetch) !== null && r !== void 0 ? r : fetch
        })
    }
    delete({count: t}={}) {
        var e;
        const r = "DELETE"
          , {url: n, headers: s} = this.cloneRequestState();
        return t && s.append("Prefer", `count=${t}`),
        new oi({
            method: r,
            url: n,
            headers: s,
            schema: this.schema,
            fetch: (e = this.fetch) !== null && e !== void 0 ? e : fetch
        })
    }
}
  , CA = class jb {
    constructor(e, {headers: r={}, schema: n, fetch: s}={}) {
        this.url = e,
        this.headers = new Headers(r),
        this.schemaName = n,
        this.fetch = s
    }
    from(e) {
        if (!e || typeof e != "string" || e.trim() === "")
            throw new Error("Invalid relation name: relation must be a non-empty string.");
        return new EA(new URL(`${this.url}/${e}`),{
            headers: new Headers(this.headers),
            schema: this.schemaName,
            fetch: this.fetch
        })
    }
    schema(e) {
        return new jb(this.url,{
            headers: this.headers,
            schema: e,
            fetch: this.fetch
        })
    }
    rpc(e, r={}, {head: n=!1, get: s=!1, count: i}={}) {
        var o;
        let a;
        const l = new URL(`${this.url}/rpc/${e}`);
        let c;
        const u = f => f !== null && typeof f == "object" && (!Array.isArray(f) || f.some(u))
          , h = n && Object.values(r).some(u);
        h ? (a = "POST",
        c = r) : n || s ? (a = n ? "HEAD" : "GET",
        Object.entries(r).filter( ([f,b]) => b !== void 0).map( ([f,b]) => [f, Array.isArray(b) ? `{${b.join(",")}}` : `${b}`]).forEach( ([f,b]) => {
            l.searchParams.append(f, b)
        }
        )) : (a = "POST",
        c = r);
        const p = new Headers(this.headers);
        return h ? p.set("Prefer", i ? `count=${i},return=minimal` : "return=minimal") : i && p.set("Prefer", `count=${i}`),
        new oi({
            method: a,
            url: l,
            headers: p,
            schema: this.schemaName,
            body: c,
            fetch: (o = this.fetch) !== null && o !== void 0 ? o : fetch
        })
    }
}
;
class TA {
    constructor() {}
    static detectEnvironment() {
        var e;
        if (typeof WebSocket < "u")
            return {
                type: "native",
                constructor: WebSocket
            };
        if (typeof globalThis < "u" && typeof globalThis.WebSocket < "u")
            return {
                type: "native",
                constructor: globalThis.WebSocket
            };
        if (typeof global < "u" && typeof global.WebSocket < "u")
            return {
                type: "native",
                constructor: global.WebSocket
            };
        if (typeof globalThis < "u" && typeof globalThis.WebSocketPair < "u" && typeof globalThis.WebSocket > "u")
            return {
                type: "cloudflare",
                error: "Cloudflare Workers detected. WebSocket clients are not supported in Cloudflare Workers.",
                workaround: "Use Cloudflare Workers WebSocket API for server-side WebSocket handling, or deploy to a different runtime."
            };
        if (typeof globalThis < "u" && globalThis.EdgeRuntime || typeof navigator < "u" && (!((e = navigator.userAgent) === null || e === void 0) && e.includes("Vercel-Edge")))
            return {
                type: "unsupported",
                error: "Edge runtime detected (Vercel Edge/Netlify Edge). WebSockets are not supported in edge functions.",
                workaround: "Use serverless functions or a different deployment target for WebSocket functionality."
            };
        const r = globalThis.process;
        if (r) {
            const n = r.versions;
            if (n && n.node) {
                const s = n.node
                  , i = parseInt(s.replace(/^v/, "").split(".")[0]);
                return i >= 22 ? typeof globalThis.WebSocket < "u" ? {
                    type: "native",
                    constructor: globalThis.WebSocket
                } : {
                    type: "unsupported",
                    error: `Node.js ${i} detected but native WebSocket not found.`,
                    workaround: "Provide a WebSocket implementation via the transport option."
                } : {
                    type: "unsupported",
                    error: `Node.js ${i} detected without native WebSocket support.`,
                    workaround: `For Node.js < 22, install "ws" package and provide it via the transport option:
import ws from "ws"
new RealtimeClient(url, { transport: ws })`
                }
            }
        }
        return {
            type: "unsupported",
            error: "Unknown JavaScript runtime without WebSocket support.",
            workaround: "Ensure you're running in a supported environment (browser, Node.js, Deno) or provide a custom WebSocket implementation."
        }
    }
    static getWebSocketConstructor() {
        const e = this.detectEnvironment();
        if (e.constructor)
            return e.constructor;
        let r = e.error || "WebSocket not supported in this environment.";
        throw e.workaround && (r += `

Suggested solution: ${e.workaround}`),
        new Error(r)
    }
    static createWebSocket(e, r) {
        const n = this.getWebSocketConstructor();
        return new n(e,r)
    }
    static isWebSocketSupported() {
        try {
            const e = this.detectEnvironment();
            return e.type === "native" || e.type === "ws"
        } catch {
            return !1
        }
    }
}
const RA = "2.90.1"
  , NA = `realtime-js/${RA}`
  , Ob = "1.0.0"
  , PA = "2.0.0"
  , tv = Ob
  , Jh = 1e4
  , AA = 1e3
  , jA = 100;
var mn;
(function(t) {
    t[t.connecting = 0] = "connecting",
    t[t.open = 1] = "open",
    t[t.closing = 2] = "closing",
    t[t.closed = 3] = "closed"
}
)(mn || (mn = {}));
var Ge;
(function(t) {
    t.closed = "closed",
    t.errored = "errored",
    t.joined = "joined",
    t.joining = "joining",
    t.leaving = "leaving"
}
)(Ge || (Ge = {}));
var mr;
(function(t) {
    t.close = "phx_close",
    t.error = "phx_error",
    t.join = "phx_join",
    t.reply = "phx_reply",
    t.leave = "phx_leave",
    t.access_token = "access_token"
}
)(mr || (mr = {}));
var Zh;
(function(t) {
    t.websocket = "websocket"
}
)(Zh || (Zh = {}));
var hs;
(function(t) {
    t.Connecting = "connecting",
    t.Open = "open",
    t.Closing = "closing",
    t.Closed = "closed"
}
)(hs || (hs = {}));
class OA {
    constructor(e) {
        this.HEADER_LENGTH = 1,
        this.USER_BROADCAST_PUSH_META_LENGTH = 6,
        this.KINDS = {
            userBroadcastPush: 3,
            userBroadcast: 4
        },
        this.BINARY_ENCODING = 0,
        this.JSON_ENCODING = 1,
        this.BROADCAST_EVENT = "broadcast",
        this.allowedMetadataKeys = [],
        this.allowedMetadataKeys = e ?? []
    }
    encode(e, r) {
        if (e.event === this.BROADCAST_EVENT && !(e.payload instanceof ArrayBuffer) && typeof e.payload.event == "string")
            return r(this._binaryEncodeUserBroadcastPush(e));
        let n = [e.join_ref, e.ref, e.topic, e.event, e.payload];
        return r(JSON.stringify(n))
    }
    _binaryEncodeUserBroadcastPush(e) {
        var r;
        return this._isArrayBuffer((r = e.payload) === null || r === void 0 ? void 0 : r.payload) ? this._encodeBinaryUserBroadcastPush(e) : this._encodeJsonUserBroadcastPush(e)
    }
    _encodeBinaryUserBroadcastPush(e) {
        var r, n;
        const s = (n = (r = e.payload) === null || r === void 0 ? void 0 : r.payload) !== null && n !== void 0 ? n : new ArrayBuffer(0);
        return this._encodeUserBroadcastPush(e, this.BINARY_ENCODING, s)
    }
    _encodeJsonUserBroadcastPush(e) {
        var r, n;
        const s = (n = (r = e.payload) === null || r === void 0 ? void 0 : r.payload) !== null && n !== void 0 ? n : {}
          , o = new TextEncoder().encode(JSON.stringify(s)).buffer;
        return this._encodeUserBroadcastPush(e, this.JSON_ENCODING, o)
    }
    _encodeUserBroadcastPush(e, r, n) {
        var s, i;
        const o = e.topic
          , a = (s = e.ref) !== null && s !== void 0 ? s : ""
          , l = (i = e.join_ref) !== null && i !== void 0 ? i : ""
          , c = e.payload.event
          , u = this.allowedMetadataKeys ? this._pick(e.payload, this.allowedMetadataKeys) : {}
          , h = Object.keys(u).length === 0 ? "" : JSON.stringify(u);
        if (l.length > 255)
            throw new Error(`joinRef length ${l.length} exceeds maximum of 255`);
        if (a.length > 255)
            throw new Error(`ref length ${a.length} exceeds maximum of 255`);
        if (o.length > 255)
            throw new Error(`topic length ${o.length} exceeds maximum of 255`);
        if (c.length > 255)
            throw new Error(`userEvent length ${c.length} exceeds maximum of 255`);
        if (h.length > 255)
            throw new Error(`metadata length ${h.length} exceeds maximum of 255`);
        const p = this.USER_BROADCAST_PUSH_META_LENGTH + l.length + a.length + o.length + c.length + h.length
          , f = new ArrayBuffer(this.HEADER_LENGTH + p);
        let b = new DataView(f)
          , m = 0;
        b.setUint8(m++, this.KINDS.userBroadcastPush),
        b.setUint8(m++, l.length),
        b.setUint8(m++, a.length),
        b.setUint8(m++, o.length),
        b.setUint8(m++, c.length),
        b.setUint8(m++, h.length),
        b.setUint8(m++, r),
        Array.from(l, w => b.setUint8(m++, w.charCodeAt(0))),
        Array.from(a, w => b.setUint8(m++, w.charCodeAt(0))),
        Array.from(o, w => b.setUint8(m++, w.charCodeAt(0))),
        Array.from(c, w => b.setUint8(m++, w.charCodeAt(0))),
        Array.from(h, w => b.setUint8(m++, w.charCodeAt(0)));
        var x = new Uint8Array(f.byteLength + n.byteLength);
        return x.set(new Uint8Array(f), 0),
        x.set(new Uint8Array(n), f.byteLength),
        x.buffer
    }
    decode(e, r) {
        if (this._isArrayBuffer(e)) {
            let n = this._binaryDecode(e);
            return r(n)
        }
        if (typeof e == "string") {
            const n = JSON.parse(e)
              , [s,i,o,a,l] = n;
            return r({
                join_ref: s,
                ref: i,
                topic: o,
                event: a,
                payload: l
            })
        }
        return r({})
    }
    _binaryDecode(e) {
        const r = new DataView(e)
          , n = r.getUint8(0)
          , s = new TextDecoder;
        switch (n) {
        case this.KINDS.userBroadcast:
            return this._decodeUserBroadcast(e, r, s)
        }
    }
    _decodeUserBroadcast(e, r, n) {
        const s = r.getUint8(1)
          , i = r.getUint8(2)
          , o = r.getUint8(3)
          , a = r.getUint8(4);
        let l = this.HEADER_LENGTH + 4;
        const c = n.decode(e.slice(l, l + s));
        l = l + s;
        const u = n.decode(e.slice(l, l + i));
        l = l + i;
        const h = n.decode(e.slice(l, l + o));
        l = l + o;
        const p = e.slice(l, e.byteLength)
          , f = a === this.JSON_ENCODING ? JSON.parse(n.decode(p)) : p
          , b = {
            type: this.BROADCAST_EVENT,
            event: u,
            payload: f
        };
        return o > 0 && (b.meta = JSON.parse(h)),
        {
            join_ref: null,
            ref: null,
            topic: c,
            event: this.BROADCAST_EVENT,
            payload: b
        }
    }
    _isArrayBuffer(e) {
        var r;
        return e instanceof ArrayBuffer || ((r = e == null ? void 0 : e.constructor) === null || r === void 0 ? void 0 : r.name) === "ArrayBuffer"
    }
    _pick(e, r) {
        return !e || typeof e != "object" ? {} : Object.fromEntries(Object.entries(e).filter( ([n]) => r.includes(n)))
    }
}
class Ib {
    constructor(e, r) {
        this.callback = e,
        this.timerCalc = r,
        this.timer = void 0,
        this.tries = 0,
        this.callback = e,
        this.timerCalc = r
    }
    reset() {
        this.tries = 0,
        clearTimeout(this.timer),
        this.timer = void 0
    }
    scheduleTimeout() {
        clearTimeout(this.timer),
        this.timer = setTimeout( () => {
            this.tries = this.tries + 1,
            this.callback()
        }
        , this.timerCalc(this.tries + 1))
    }
}
var ke;
(function(t) {
    t.abstime = "abstime",
    t.bool = "bool",
    t.date = "date",
    t.daterange = "daterange",
    t.float4 = "float4",
    t.float8 = "float8",
    t.int2 = "int2",
    t.int4 = "int4",
    t.int4range = "int4range",
    t.int8 = "int8",
    t.int8range = "int8range",
    t.json = "json",
    t.jsonb = "jsonb",
    t.money = "money",
    t.numeric = "numeric",
    t.oid = "oid",
    t.reltime = "reltime",
    t.text = "text",
    t.time = "time",
    t.timestamp = "timestamp",
    t.timestamptz = "timestamptz",
    t.timetz = "timetz",
    t.tsrange = "tsrange",
    t.tstzrange = "tstzrange"
}
)(ke || (ke = {}));
const rv = (t, e, r={}) => {
    var n;
    const s = (n = r.skipTypes) !== null && n !== void 0 ? n : [];
    return e ? Object.keys(e).reduce( (i, o) => (i[o] = IA(o, t, e, s),
    i), {}) : {}
}
  , IA = (t, e, r, n) => {
    const s = e.find(a => a.name === t)
      , i = s == null ? void 0 : s.type
      , o = r[t];
    return i && !n.includes(i) ? Lb(i, o) : Yh(o)
}
  , Lb = (t, e) => {
    if (t.charAt(0) === "_") {
        const r = t.slice(1, t.length);
        return MA(e, r)
    }
    switch (t) {
    case ke.bool:
        return LA(e);
    case ke.float4:
    case ke.float8:
    case ke.int2:
    case ke.int4:
    case ke.int8:
    case ke.numeric:
    case ke.oid:
        return $A(e);
    case ke.json:
    case ke.jsonb:
        return DA(e);
    case ke.timestamp:
        return FA(e);
    case ke.abstime:
    case ke.date:
    case ke.daterange:
    case ke.int4range:
    case ke.int8range:
    case ke.money:
    case ke.reltime:
    case ke.text:
    case ke.time:
    case ke.timestamptz:
    case ke.timetz:
    case ke.tsrange:
    case ke.tstzrange:
        return Yh(e);
    default:
        return Yh(e)
    }
}
  , Yh = t => t
  , LA = t => {
    switch (t) {
    case "t":
        return !0;
    case "f":
        return !1;
    default:
        return t
    }
}
  , $A = t => {
    if (typeof t == "string") {
        const e = parseFloat(t);
        if (!Number.isNaN(e))
            return e
    }
    return t
}
  , DA = t => {
    if (typeof t == "string")
        try {
            return JSON.parse(t)
        } catch {
            return t
        }
    return t
}
  , MA = (t, e) => {
    if (typeof t != "string")
        return t;
    const r = t.length - 1
      , n = t[r];
    if (t[0] === "{" && n === "}") {
        let i;
        const o = t.slice(1, r);
        try {
            i = JSON.parse("[" + o + "]")
        } catch {
            i = o ? o.split(",") : []
        }
        return i.map(a => Lb(e, a))
    }
    return t
}
  , FA = t => typeof t == "string" ? t.replace(" ", "T") : t
  , $b = t => {
    const e = new URL(t);
    return e.protocol = e.protocol.replace(/^ws/i, "http"),
    e.pathname = e.pathname.replace(/\/+$/, "").replace(/\/socket\/websocket$/i, "").replace(/\/socket$/i, "").replace(/\/websocket$/i, ""),
    e.pathname === "" || e.pathname === "/" ? e.pathname = "/api/broadcast" : e.pathname = e.pathname + "/api/broadcast",
    e.href
}
;
class ud {
    constructor(e, r, n={}, s=Jh) {
        this.channel = e,
        this.event = r,
        this.payload = n,
        this.timeout = s,
        this.sent = !1,
        this.timeoutTimer = void 0,
        this.ref = "",
        this.receivedResp = null,
        this.recHooks = [],
        this.refEvent = null
    }
    resend(e) {
        this.timeout = e,
        this._cancelRefEvent(),
        this.ref = "",
        this.refEvent = null,
        this.receivedResp = null,
        this.sent = !1,
        this.send()
    }
    send() {
        this._hasReceived("timeout") || (this.startTimeout(),
        this.sent = !0,
        this.channel.socket.push({
            topic: this.channel.topic,
            event: this.event,
            payload: this.payload,
            ref: this.ref,
            join_ref: this.channel._joinRef()
        }))
    }
    updatePayload(e) {
        this.payload = Object.assign(Object.assign({}, this.payload), e)
    }
    receive(e, r) {
        var n;
        return this._hasReceived(e) && r((n = this.receivedResp) === null || n === void 0 ? void 0 : n.response),
        this.recHooks.push({
            status: e,
            callback: r
        }),
        this
    }
    startTimeout() {
        if (this.timeoutTimer)
            return;
        this.ref = this.channel.socket._makeRef(),
        this.refEvent = this.channel._replyEventName(this.ref);
        const e = r => {
            this._cancelRefEvent(),
            this._cancelTimeout(),
            this.receivedResp = r,
            this._matchReceive(r)
        }
        ;
        this.channel._on(this.refEvent, {}, e),
        this.timeoutTimer = setTimeout( () => {
            this.trigger("timeout", {})
        }
        , this.timeout)
    }
    trigger(e, r) {
        this.refEvent && this.channel._trigger(this.refEvent, {
            status: e,
            response: r
        })
    }
    destroy() {
        this._cancelRefEvent(),
        this._cancelTimeout()
    }
    _cancelRefEvent() {
        this.refEvent && this.channel._off(this.refEvent, {})
    }
    _cancelTimeout() {
        clearTimeout(this.timeoutTimer),
        this.timeoutTimer = void 0
    }
    _matchReceive({status: e, response: r}) {
        this.recHooks.filter(n => n.status === e).forEach(n => n.callback(r))
    }
    _hasReceived(e) {
        return this.receivedResp && this.receivedResp.status === e
    }
}
var nv;
(function(t) {
    t.SYNC = "sync",
    t.JOIN = "join",
    t.LEAVE = "leave"
}
)(nv || (nv = {}));
class Yo {
    constructor(e, r) {
        this.channel = e,
        this.state = {},
        this.pendingDiffs = [],
        this.joinRef = null,
        this.enabled = !1,
        this.caller = {
            onJoin: () => {}
            ,
            onLeave: () => {}
            ,
            onSync: () => {}
        };
        const n = (r == null ? void 0 : r.events) || {
            state: "presence_state",
            diff: "presence_diff"
        };
        this.channel._on(n.state, {}, s => {
            const {onJoin: i, onLeave: o, onSync: a} = this.caller;
            this.joinRef = this.channel._joinRef(),
            this.state = Yo.syncState(this.state, s, i, o),
            this.pendingDiffs.forEach(l => {
                this.state = Yo.syncDiff(this.state, l, i, o)
            }
            ),
            this.pendingDiffs = [],
            a()
        }
        ),
        this.channel._on(n.diff, {}, s => {
            const {onJoin: i, onLeave: o, onSync: a} = this.caller;
            this.inPendingSyncState() ? this.pendingDiffs.push(s) : (this.state = Yo.syncDiff(this.state, s, i, o),
            a())
        }
        ),
        this.onJoin( (s, i, o) => {
            this.channel._trigger("presence", {
                event: "join",
                key: s,
                currentPresences: i,
                newPresences: o
            })
        }
        ),
        this.onLeave( (s, i, o) => {
            this.channel._trigger("presence", {
                event: "leave",
                key: s,
                currentPresences: i,
                leftPresences: o
            })
        }
        ),
        this.onSync( () => {
            this.channel._trigger("presence", {
                event: "sync"
            })
        }
        )
    }
    static syncState(e, r, n, s) {
        const i = this.cloneDeep(e)
          , o = this.transformState(r)
          , a = {}
          , l = {};
        return this.map(i, (c, u) => {
            o[c] || (l[c] = u)
        }
        ),
        this.map(o, (c, u) => {
            const h = i[c];
            if (h) {
                const p = u.map(x => x.presence_ref)
                  , f = h.map(x => x.presence_ref)
                  , b = u.filter(x => f.indexOf(x.presence_ref) < 0)
                  , m = h.filter(x => p.indexOf(x.presence_ref) < 0);
                b.length > 0 && (a[c] = b),
                m.length > 0 && (l[c] = m)
            } else
                a[c] = u
        }
        ),
        this.syncDiff(i, {
            joins: a,
            leaves: l
        }, n, s)
    }
    static syncDiff(e, r, n, s) {
        const {joins: i, leaves: o} = {
            joins: this.transformState(r.joins),
            leaves: this.transformState(r.leaves)
        };
        return n || (n = () => {}
        ),
        s || (s = () => {}
        ),
        this.map(i, (a, l) => {
            var c;
            const u = (c = e[a]) !== null && c !== void 0 ? c : [];
            if (e[a] = this.cloneDeep(l),
            u.length > 0) {
                const h = e[a].map(f => f.presence_ref)
                  , p = u.filter(f => h.indexOf(f.presence_ref) < 0);
                e[a].unshift(...p)
            }
            n(a, u, l)
        }
        ),
        this.map(o, (a, l) => {
            let c = e[a];
            if (!c)
                return;
            const u = l.map(h => h.presence_ref);
            c = c.filter(h => u.indexOf(h.presence_ref) < 0),
            e[a] = c,
            s(a, c, l),
            c.length === 0 && delete e[a]
        }
        ),
        e
    }
    static map(e, r) {
        return Object.getOwnPropertyNames(e).map(n => r(n, e[n]))
    }
    static transformState(e) {
        return e = this.cloneDeep(e),
        Object.getOwnPropertyNames(e).reduce( (r, n) => {
            const s = e[n];
            return "metas"in s ? r[n] = s.metas.map(i => (i.presence_ref = i.phx_ref,
            delete i.phx_ref,
            delete i.phx_ref_prev,
            i)) : r[n] = s,
            r
        }
        , {})
    }
    static cloneDeep(e) {
        return JSON.parse(JSON.stringify(e))
    }
    onJoin(e) {
        this.caller.onJoin = e
    }
    onLeave(e) {
        this.caller.onLeave = e
    }
    onSync(e) {
        this.caller.onSync = e
    }
    inPendingSyncState() {
        return !this.joinRef || this.joinRef !== this.channel._joinRef()
    }
}
var sv;
(function(t) {
    t.ALL = "*",
    t.INSERT = "INSERT",
    t.UPDATE = "UPDATE",
    t.DELETE = "DELETE"
}
)(sv || (sv = {}));
var Xo;
(function(t) {
    t.BROADCAST = "broadcast",
    t.PRESENCE = "presence",
    t.POSTGRES_CHANGES = "postgres_changes",
    t.SYSTEM = "system"
}
)(Xo || (Xo = {}));
var Ur;
(function(t) {
    t.SUBSCRIBED = "SUBSCRIBED",
    t.TIMED_OUT = "TIMED_OUT",
    t.CLOSED = "CLOSED",
    t.CHANNEL_ERROR = "CHANNEL_ERROR"
}
)(Ur || (Ur = {}));
class Si {
    constructor(e, r={
        config: {}
    }, n) {
        var s, i;
        if (this.topic = e,
        this.params = r,
        this.socket = n,
        this.bindings = {},
        this.state = Ge.closed,
        this.joinedOnce = !1,
        this.pushBuffer = [],
        this.subTopic = e.replace(/^realtime:/i, ""),
        this.params.config = Object.assign({
            broadcast: {
                ack: !1,
                self: !1
            },
            presence: {
                key: "",
                enabled: !1
            },
            private: !1
        }, r.config),
        this.timeout = this.socket.timeout,
        this.joinPush = new ud(this,mr.join,this.params,this.timeout),
        this.rejoinTimer = new Ib( () => this._rejoinUntilConnected(),this.socket.reconnectAfterMs),
        this.joinPush.receive("ok", () => {
            this.state = Ge.joined,
            this.rejoinTimer.reset(),
            this.pushBuffer.forEach(o => o.send()),
            this.pushBuffer = []
        }
        ),
        this._onClose( () => {
            this.rejoinTimer.reset(),
            this.socket.log("channel", `close ${this.topic} ${this._joinRef()}`),
            this.state = Ge.closed,
            this.socket._remove(this)
        }
        ),
        this._onError(o => {
            this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, o),
            this.state = Ge.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this.joinPush.receive("timeout", () => {
            this._isJoining() && (this.socket.log("channel", `timeout ${this.topic}`, this.joinPush.timeout),
            this.state = Ge.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this.joinPush.receive("error", o => {
            this._isLeaving() || this._isClosed() || (this.socket.log("channel", `error ${this.topic}`, o),
            this.state = Ge.errored,
            this.rejoinTimer.scheduleTimeout())
        }
        ),
        this._on(mr.reply, {}, (o, a) => {
            this._trigger(this._replyEventName(a), o)
        }
        ),
        this.presence = new Yo(this),
        this.broadcastEndpointURL = $b(this.socket.endPoint),
        this.private = this.params.config.private || !1,
        !this.private && (!((i = (s = this.params.config) === null || s === void 0 ? void 0 : s.broadcast) === null || i === void 0) && i.replay))
            throw `tried to use replay on public channel '${this.topic}'. It must be a private channel.`
    }
    subscribe(e, r=this.timeout) {
        var n, s, i;
        if (this.socket.isConnected() || this.socket.connect(),
        this.state == Ge.closed) {
            const {config: {broadcast: o, presence: a, private: l}} = this.params
              , c = (s = (n = this.bindings.postgres_changes) === null || n === void 0 ? void 0 : n.map(f => f.filter)) !== null && s !== void 0 ? s : []
              , u = !!this.bindings[Xo.PRESENCE] && this.bindings[Xo.PRESENCE].length > 0 || ((i = this.params.config.presence) === null || i === void 0 ? void 0 : i.enabled) === !0
              , h = {}
              , p = {
                broadcast: o,
                presence: Object.assign(Object.assign({}, a), {
                    enabled: u
                }),
                postgres_changes: c,
                private: l
            };
            this.socket.accessTokenValue && (h.access_token = this.socket.accessTokenValue),
            this._onError(f => e == null ? void 0 : e(Ur.CHANNEL_ERROR, f)),
            this._onClose( () => e == null ? void 0 : e(Ur.CLOSED)),
            this.updateJoinPayload(Object.assign({
                config: p
            }, h)),
            this.joinedOnce = !0,
            this._rejoin(r),
            this.joinPush.receive("ok", async ({postgres_changes: f}) => {
                var b;
                if (this.socket._isManualToken() || this.socket.setAuth(),
                f === void 0) {
                    e == null || e(Ur.SUBSCRIBED);
                    return
                } else {
                    const m = this.bindings.postgres_changes
                      , x = (b = m == null ? void 0 : m.length) !== null && b !== void 0 ? b : 0
                      , w = [];
                    for (let g = 0; g < x; g++) {
                        const v = m[g]
                          , {filter: {event: _, schema: S, table: k, filter: C}} = v
                          , T = f && f[g];
                        if (T && T.event === _ && Si.isFilterValueEqual(T.schema, S) && Si.isFilterValueEqual(T.table, k) && Si.isFilterValueEqual(T.filter, C))
                            w.push(Object.assign(Object.assign({}, v), {
                                id: T.id
                            }));
                        else {
                            this.unsubscribe(),
                            this.state = Ge.errored,
                            e == null || e(Ur.CHANNEL_ERROR, new Error("mismatch between server and client bindings for postgres changes"));
                            return
                        }
                    }
                    this.bindings.postgres_changes = w,
                    e && e(Ur.SUBSCRIBED);
                    return
                }
            }
            ).receive("error", f => {
                this.state = Ge.errored,
                e == null || e(Ur.CHANNEL_ERROR, new Error(JSON.stringify(Object.values(f).join(", ") || "error")))
            }
            ).receive("timeout", () => {
                e == null || e(Ur.TIMED_OUT)
            }
            )
        }
        return this
    }
    presenceState() {
        return this.presence.state
    }
    async track(e, r={}) {
        return await this.send({
            type: "presence",
            event: "track",
            payload: e
        }, r.timeout || this.timeout)
    }
    async untrack(e={}) {
        return await this.send({
            type: "presence",
            event: "untrack"
        }, e)
    }
    on(e, r, n) {
        return this.state === Ge.joined && e === Xo.PRESENCE && (this.socket.log("channel", `resubscribe to ${this.topic} due to change in presence callbacks on joined channel`),
        this.unsubscribe().then(async () => await this.subscribe())),
        this._on(e, r, n)
    }
    async httpSend(e, r, n={}) {
        var s;
        if (r == null)
            return Promise.reject("Payload is required for httpSend()");
        const i = {
            apikey: this.socket.apiKey ? this.socket.apiKey : "",
            "Content-Type": "application/json"
        };
        this.socket.accessTokenValue && (i.Authorization = `Bearer ${this.socket.accessTokenValue}`);
        const o = {
            method: "POST",
            headers: i,
            body: JSON.stringify({
                messages: [{
                    topic: this.subTopic,
                    event: e,
                    payload: r,
                    private: this.private
                }]
            })
        }
          , a = await this._fetchWithTimeout(this.broadcastEndpointURL, o, (s = n.timeout) !== null && s !== void 0 ? s : this.timeout);
        if (a.status === 202)
            return {
                success: !0
            };
        let l = a.statusText;
        try {
            const c = await a.json();
            l = c.error || c.message || l
        } catch {}
        return Promise.reject(new Error(l))
    }
    async send(e, r={}) {
        var n, s;
        if (!this._canPush() && e.type === "broadcast") {
            console.warn("Realtime send() is automatically falling back to REST API. This behavior will be deprecated in the future. Please use httpSend() explicitly for REST delivery.");
            const {event: i, payload: o} = e
              , a = {
                apikey: this.socket.apiKey ? this.socket.apiKey : "",
                "Content-Type": "application/json"
            };
            this.socket.accessTokenValue && (a.Authorization = `Bearer ${this.socket.accessTokenValue}`);
            const l = {
                method: "POST",
                headers: a,
                body: JSON.stringify({
                    messages: [{
                        topic: this.subTopic,
                        event: i,
                        payload: o,
                        private: this.private
                    }]
                })
            };
            try {
                const c = await this._fetchWithTimeout(this.broadcastEndpointURL, l, (n = r.timeout) !== null && n !== void 0 ? n : this.timeout);
                return await ((s = c.body) === null || s === void 0 ? void 0 : s.cancel()),
                c.ok ? "ok" : "error"
            } catch (c) {
                return c.name === "AbortError" ? "timed out" : "error"
            }
        } else
            return new Promise(i => {
                var o, a, l;
                const c = this._push(e.type, e, r.timeout || this.timeout);
                e.type === "broadcast" && !(!((l = (a = (o = this.params) === null || o === void 0 ? void 0 : o.config) === null || a === void 0 ? void 0 : a.broadcast) === null || l === void 0) && l.ack) && i("ok"),
                c.receive("ok", () => i("ok")),
                c.receive("error", () => i("error")),
                c.receive("timeout", () => i("timed out"))
            }
            )
    }
    updateJoinPayload(e) {
        this.joinPush.updatePayload(e)
    }
    unsubscribe(e=this.timeout) {
        this.state = Ge.leaving;
        const r = () => {
            this.socket.log("channel", `leave ${this.topic}`),
            this._trigger(mr.close, "leave", this._joinRef())
        }
        ;
        this.joinPush.destroy();
        let n = null;
        return new Promise(s => {
            n = new ud(this,mr.leave,{},e),
            n.receive("ok", () => {
                r(),
                s("ok")
            }
            ).receive("timeout", () => {
                r(),
                s("timed out")
            }
            ).receive("error", () => {
                s("error")
            }
            ),
            n.send(),
            this._canPush() || n.trigger("ok", {})
        }
        ).finally( () => {
            n == null || n.destroy()
        }
        )
    }
    teardown() {
        this.pushBuffer.forEach(e => e.destroy()),
        this.pushBuffer = [],
        this.rejoinTimer.reset(),
        this.joinPush.destroy(),
        this.state = Ge.closed,
        this.bindings = {}
    }
    async _fetchWithTimeout(e, r, n) {
        const s = new AbortController
          , i = setTimeout( () => s.abort(), n)
          , o = await this.socket.fetch(e, Object.assign(Object.assign({}, r), {
            signal: s.signal
        }));
        return clearTimeout(i),
        o
    }
    _push(e, r, n=this.timeout) {
        if (!this.joinedOnce)
            throw `tried to push '${e}' to '${this.topic}' before joining. Use channel.subscribe() before pushing events`;
        let s = new ud(this,e,r,n);
        return this._canPush() ? s.send() : this._addToPushBuffer(s),
        s
    }
    _addToPushBuffer(e) {
        if (e.startTimeout(),
        this.pushBuffer.push(e),
        this.pushBuffer.length > jA) {
            const r = this.pushBuffer.shift();
            r && (r.destroy(),
            this.socket.log("channel", `discarded push due to buffer overflow: ${r.event}`, r.payload))
        }
    }
    _onMessage(e, r, n) {
        return r
    }
    _isMember(e) {
        return this.topic === e
    }
    _joinRef() {
        return this.joinPush.ref
    }
    _trigger(e, r, n) {
        var s, i;
        const o = e.toLocaleLowerCase()
          , {close: a, error: l, leave: c, join: u} = mr;
        if (n && [a, l, c, u].indexOf(o) >= 0 && n !== this._joinRef())
            return;
        let p = this._onMessage(o, r, n);
        if (r && !p)
            throw "channel onMessage callbacks must return the payload, modified or unmodified";
        ["insert", "update", "delete"].includes(o) ? (s = this.bindings.postgres_changes) === null || s === void 0 || s.filter(f => {
            var b, m, x;
            return ((b = f.filter) === null || b === void 0 ? void 0 : b.event) === "*" || ((x = (m = f.filter) === null || m === void 0 ? void 0 : m.event) === null || x === void 0 ? void 0 : x.toLocaleLowerCase()) === o
        }
        ).map(f => f.callback(p, n)) : (i = this.bindings[o]) === null || i === void 0 || i.filter(f => {
            var b, m, x, w, g, v, _, S;
            if (["broadcast", "presence", "postgres_changes"].includes(o))
                if ("id"in f) {
                    const k = f.id
                      , C = (b = f.filter) === null || b === void 0 ? void 0 : b.event;
                    return k && ((m = r.ids) === null || m === void 0 ? void 0 : m.includes(k)) && (C === "*" || (C == null ? void 0 : C.toLocaleLowerCase()) === ((x = r.data) === null || x === void 0 ? void 0 : x.type.toLocaleLowerCase())) && (!(!((w = f.filter) === null || w === void 0) && w.table) || f.filter.table === ((g = r.data) === null || g === void 0 ? void 0 : g.table))
                } else {
                    const k = (_ = (v = f == null ? void 0 : f.filter) === null || v === void 0 ? void 0 : v.event) === null || _ === void 0 ? void 0 : _.toLocaleLowerCase();
                    return k === "*" || k === ((S = r == null ? void 0 : r.event) === null || S === void 0 ? void 0 : S.toLocaleLowerCase())
                }
            else
                return f.type.toLocaleLowerCase() === o
        }
        ).map(f => {
            if (typeof p == "object" && "ids"in p) {
                const b = p.data
                  , {schema: m, table: x, commit_timestamp: w, type: g, errors: v} = b;
                p = Object.assign(Object.assign({}, {
                    schema: m,
                    table: x,
                    commit_timestamp: w,
                    eventType: g,
                    new: {},
                    old: {},
                    errors: v
                }), this._getPayloadRecords(b))
            }
            f.callback(p, n)
        }
        )
    }
    _isClosed() {
        return this.state === Ge.closed
    }
    _isJoined() {
        return this.state === Ge.joined
    }
    _isJoining() {
        return this.state === Ge.joining
    }
    _isLeaving() {
        return this.state === Ge.leaving
    }
    _replyEventName(e) {
        return `chan_reply_${e}`
    }
    _on(e, r, n) {
        const s = e.toLocaleLowerCase()
          , i = {
            type: s,
            filter: r,
            callback: n
        };
        return this.bindings[s] ? this.bindings[s].push(i) : this.bindings[s] = [i],
        this
    }
    _off(e, r) {
        const n = e.toLocaleLowerCase();
        return this.bindings[n] && (this.bindings[n] = this.bindings[n].filter(s => {
            var i;
            return !(((i = s.type) === null || i === void 0 ? void 0 : i.toLocaleLowerCase()) === n && Si.isEqual(s.filter, r))
        }
        )),
        this
    }
    static isEqual(e, r) {
        if (Object.keys(e).length !== Object.keys(r).length)
            return !1;
        for (const n in e)
            if (e[n] !== r[n])
                return !1;
        return !0
    }
    static isFilterValueEqual(e, r) {
        return (e ?? void 0) === (r ?? void 0)
    }
    _rejoinUntilConnected() {
        this.rejoinTimer.scheduleTimeout(),
        this.socket.isConnected() && this._rejoin()
    }
    _onClose(e) {
        this._on(mr.close, {}, e)
    }
    _onError(e) {
        this._on(mr.error, {}, r => e(r))
    }
    _canPush() {
        return this.socket.isConnected() && this._isJoined()
    }
    _rejoin(e=this.timeout) {
        this._isLeaving() || (this.socket._leaveOpenTopic(this.topic),
        this.state = Ge.joining,
        this.joinPush.resend(e))
    }
    _getPayloadRecords(e) {
        const r = {
            new: {},
            old: {}
        };
        return (e.type === "INSERT" || e.type === "UPDATE") && (r.new = rv(e.columns, e.record)),
        (e.type === "UPDATE" || e.type === "DELETE") && (r.old = rv(e.columns, e.old_record)),
        r
    }
}
const dd = () => {}
  , bl = {
    HEARTBEAT_INTERVAL: 25e3,
    RECONNECT_DELAY: 10,
    HEARTBEAT_TIMEOUT_FALLBACK: 100
}
  , UA = [1e3, 2e3, 5e3, 1e4]
  , BA = 1e4
  , zA = `
  addEventListener("message", (e) => {
    if (e.data.event === "start") {
      setInterval(() => postMessage({ event: "keepAlive" }), e.data.interval);
    }
  });`;
class VA {
    constructor(e, r) {
        var n;
        if (this.accessTokenValue = null,
        this.apiKey = null,
        this._manuallySetToken = !1,
        this.channels = new Array,
        this.endPoint = "",
        this.httpEndpoint = "",
        this.headers = {},
        this.params = {},
        this.timeout = Jh,
        this.transport = null,
        this.heartbeatIntervalMs = bl.HEARTBEAT_INTERVAL,
        this.heartbeatTimer = void 0,
        this.pendingHeartbeatRef = null,
        this.heartbeatCallback = dd,
        this.ref = 0,
        this.reconnectTimer = null,
        this.vsn = tv,
        this.logger = dd,
        this.conn = null,
        this.sendBuffer = [],
        this.serializer = new OA,
        this.stateChangeCallbacks = {
            open: [],
            close: [],
            error: [],
            message: []
        },
        this.accessToken = null,
        this._connectionState = "disconnected",
        this._wasManualDisconnect = !1,
        this._authPromise = null,
        this._heartbeatSentAt = null,
        this._resolveFetch = s => s ? (...i) => s(...i) : (...i) => fetch(...i),
        !(!((n = r == null ? void 0 : r.params) === null || n === void 0) && n.apikey))
            throw new Error("API key is required to connect to Realtime");
        this.apiKey = r.params.apikey,
        this.endPoint = `${e}/${Zh.websocket}`,
        this.httpEndpoint = $b(e),
        this._initializeOptions(r),
        this._setupReconnectionTimer(),
        this.fetch = this._resolveFetch(r == null ? void 0 : r.fetch)
    }
    connect() {
        if (!(this.isConnecting() || this.isDisconnecting() || this.conn !== null && this.isConnected())) {
            if (this._setConnectionState("connecting"),
            this.accessToken && !this._authPromise && this._setAuthSafely("connect"),
            this.transport)
                this.conn = new this.transport(this.endpointURL());
            else
                try {
                    this.conn = TA.createWebSocket(this.endpointURL())
                } catch (e) {
                    this._setConnectionState("disconnected");
                    const r = e.message;
                    throw r.includes("Node.js") ? new Error(`${r}

To use Realtime in Node.js, you need to provide a WebSocket implementation:

Option 1: Use Node.js 22+ which has native WebSocket support
Option 2: Install and provide the "ws" package:

  npm install ws

  import ws from "ws"
  const client = new RealtimeClient(url, {
    ...options,
    transport: ws
  })`) : new Error(`WebSocket not available: ${r}`)
                }
            this._setupConnectionHandlers()
        }
    }
    endpointURL() {
        return this._appendParams(this.endPoint, Object.assign({}, this.params, {
            vsn: this.vsn
        }))
    }
    disconnect(e, r) {
        if (!this.isDisconnecting())
            if (this._setConnectionState("disconnecting", !0),
            this.conn) {
                const n = setTimeout( () => {
                    this._setConnectionState("disconnected")
                }
                , 100);
                this.conn.onclose = () => {
                    clearTimeout(n),
                    this._setConnectionState("disconnected")
                }
                ,
                typeof this.conn.close == "function" && (e ? this.conn.close(e, r ?? "") : this.conn.close()),
                this._teardownConnection()
            } else
                this._setConnectionState("disconnected")
    }
    getChannels() {
        return this.channels
    }
    async removeChannel(e) {
        const r = await e.unsubscribe();
        return this.channels.length === 0 && this.disconnect(),
        r
    }
    async removeAllChannels() {
        const e = await Promise.all(this.channels.map(r => r.unsubscribe()));
        return this.channels = [],
        this.disconnect(),
        e
    }
    log(e, r, n) {
        this.logger(e, r, n)
    }
    connectionState() {
        switch (this.conn && this.conn.readyState) {
        case mn.connecting:
            return hs.Connecting;
        case mn.open:
            return hs.Open;
        case mn.closing:
            return hs.Closing;
        default:
            return hs.Closed
        }
    }
    isConnected() {
        return this.connectionState() === hs.Open
    }
    isConnecting() {
        return this._connectionState === "connecting"
    }
    isDisconnecting() {
        return this._connectionState === "disconnecting"
    }
    channel(e, r={
        config: {}
    }) {
        const n = `realtime:${e}`
          , s = this.getChannels().find(i => i.topic === n);
        if (s)
            return s;
        {
            const i = new Si(`realtime:${e}`,r,this);
            return this.channels.push(i),
            i
        }
    }
    push(e) {
        const {topic: r, event: n, payload: s, ref: i} = e
          , o = () => {
            this.encode(e, a => {
                var l;
                (l = this.conn) === null || l === void 0 || l.send(a)
            }
            )
        }
        ;
        this.log("push", `${r} ${n} (${i})`, s),
        this.isConnected() ? o() : this.sendBuffer.push(o)
    }
    async setAuth(e=null) {
        this._authPromise = this._performAuth(e);
        try {
            await this._authPromise
        } finally {
            this._authPromise = null
        }
    }
    _isManualToken() {
        return this._manuallySetToken
    }
    async sendHeartbeat() {
        var e;
        if (!this.isConnected()) {
            try {
                this.heartbeatCallback("disconnected")
            } catch (r) {
                this.log("error", "error in heartbeat callback", r)
            }
            return
        }
        if (this.pendingHeartbeatRef) {
            this.pendingHeartbeatRef = null,
            this._heartbeatSentAt = null,
            this.log("transport", "heartbeat timeout. Attempting to re-establish connection");
            try {
                this.heartbeatCallback("timeout")
            } catch (r) {
                this.log("error", "error in heartbeat callback", r)
            }
            this._wasManualDisconnect = !1,
            (e = this.conn) === null || e === void 0 || e.close(AA, "heartbeat timeout"),
            setTimeout( () => {
                var r;
                this.isConnected() || (r = this.reconnectTimer) === null || r === void 0 || r.scheduleTimeout()
            }
            , bl.HEARTBEAT_TIMEOUT_FALLBACK);
            return
        }
        this._heartbeatSentAt = Date.now(),
        this.pendingHeartbeatRef = this._makeRef(),
        this.push({
            topic: "phoenix",
            event: "heartbeat",
            payload: {},
            ref: this.pendingHeartbeatRef
        });
        try {
            this.heartbeatCallback("sent")
        } catch (r) {
            this.log("error", "error in heartbeat callback", r)
        }
        this._setAuthSafely("heartbeat")
    }
    onHeartbeat(e) {
        this.heartbeatCallback = e
    }
    flushSendBuffer() {
        this.isConnected() && this.sendBuffer.length > 0 && (this.sendBuffer.forEach(e => e()),
        this.sendBuffer = [])
    }
    _makeRef() {
        let e = this.ref + 1;
        return e === this.ref ? this.ref = 0 : this.ref = e,
        this.ref.toString()
    }
    _leaveOpenTopic(e) {
        let r = this.channels.find(n => n.topic === e && (n._isJoined() || n._isJoining()));
        r && (this.log("transport", `leaving duplicate topic "${e}"`),
        r.unsubscribe())
    }
    _remove(e) {
        this.channels = this.channels.filter(r => r.topic !== e.topic)
    }
    _onConnMessage(e) {
        this.decode(e.data, r => {
            if (r.topic === "phoenix" && r.event === "phx_reply" && r.ref && r.ref === this.pendingHeartbeatRef) {
                const c = this._heartbeatSentAt ? Date.now() - this._heartbeatSentAt : void 0;
                try {
                    this.heartbeatCallback(r.payload.status === "ok" ? "ok" : "error", c)
                } catch (u) {
                    this.log("error", "error in heartbeat callback", u)
                }
                this._heartbeatSentAt = null,
                this.pendingHeartbeatRef = null
            }
            const {topic: n, event: s, payload: i, ref: o} = r
              , a = o ? `(${o})` : ""
              , l = i.status || "";
            this.log("receive", `${l} ${n} ${s} ${a}`.trim(), i),
            this.channels.filter(c => c._isMember(n)).forEach(c => c._trigger(s, i, o)),
            this._triggerStateCallbacks("message", r)
        }
        )
    }
    _clearTimer(e) {
        var r;
        e === "heartbeat" && this.heartbeatTimer ? (clearInterval(this.heartbeatTimer),
        this.heartbeatTimer = void 0) : e === "reconnect" && ((r = this.reconnectTimer) === null || r === void 0 || r.reset())
    }
    _clearAllTimers() {
        this._clearTimer("heartbeat"),
        this._clearTimer("reconnect")
    }
    _setupConnectionHandlers() {
        this.conn && ("binaryType"in this.conn && (this.conn.binaryType = "arraybuffer"),
        this.conn.onopen = () => this._onConnOpen(),
        this.conn.onerror = e => this._onConnError(e),
        this.conn.onmessage = e => this._onConnMessage(e),
        this.conn.onclose = e => this._onConnClose(e),
        this.conn.readyState === mn.open && this._onConnOpen())
    }
    _teardownConnection() {
        if (this.conn) {
            if (this.conn.readyState === mn.open || this.conn.readyState === mn.connecting)
                try {
                    this.conn.close()
                } catch (e) {
                    this.log("error", "Error closing connection", e)
                }
            this.conn.onopen = null,
            this.conn.onerror = null,
            this.conn.onmessage = null,
            this.conn.onclose = null,
            this.conn = null
        }
        this._clearAllTimers(),
        this._terminateWorker(),
        this.channels.forEach(e => e.teardown())
    }
    _onConnOpen() {
        this._setConnectionState("connected"),
        this.log("transport", `connected to ${this.endpointURL()}`),
        (this._authPromise || (this.accessToken && !this.accessTokenValue ? this.setAuth() : Promise.resolve())).then( () => {
            this.flushSendBuffer()
        }
        ).catch(r => {
            this.log("error", "error waiting for auth on connect", r),
            this.flushSendBuffer()
        }
        ),
        this._clearTimer("reconnect"),
        this.worker ? this.workerRef || this._startWorkerHeartbeat() : this._startHeartbeat(),
        this._triggerStateCallbacks("open")
    }
    _startHeartbeat() {
        this.heartbeatTimer && clearInterval(this.heartbeatTimer),
        this.heartbeatTimer = setInterval( () => this.sendHeartbeat(), this.heartbeatIntervalMs)
    }
    _startWorkerHeartbeat() {
        this.workerUrl ? this.log("worker", `starting worker for from ${this.workerUrl}`) : this.log("worker", "starting default worker");
        const e = this._workerObjectUrl(this.workerUrl);
        this.workerRef = new Worker(e),
        this.workerRef.onerror = r => {
            this.log("worker", "worker error", r.message),
            this._terminateWorker()
        }
        ,
        this.workerRef.onmessage = r => {
            r.data.event === "keepAlive" && this.sendHeartbeat()
        }
        ,
        this.workerRef.postMessage({
            event: "start",
            interval: this.heartbeatIntervalMs
        })
    }
    _terminateWorker() {
        this.workerRef && (this.log("worker", "terminating worker"),
        this.workerRef.terminate(),
        this.workerRef = void 0)
    }
    _onConnClose(e) {
        var r;
        this._setConnectionState("disconnected"),
        this.log("transport", "close", e),
        this._triggerChanError(),
        this._clearTimer("heartbeat"),
        this._wasManualDisconnect || (r = this.reconnectTimer) === null || r === void 0 || r.scheduleTimeout(),
        this._triggerStateCallbacks("close", e)
    }
    _onConnError(e) {
        this._setConnectionState("disconnected"),
        this.log("transport", `${e}`),
        this._triggerChanError(),
        this._triggerStateCallbacks("error", e)
    }
    _triggerChanError() {
        this.channels.forEach(e => e._trigger(mr.error))
    }
    _appendParams(e, r) {
        if (Object.keys(r).length === 0)
            return e;
        const n = e.match(/\?/) ? "&" : "?"
          , s = new URLSearchParams(r);
        return `${e}${n}${s}`
    }
    _workerObjectUrl(e) {
        let r;
        if (e)
            r = e;
        else {
            const n = new Blob([zA],{
                type: "application/javascript"
            });
            r = URL.createObjectURL(n)
        }
        return r
    }
    _setConnectionState(e, r=!1) {
        this._connectionState = e,
        e === "connecting" ? this._wasManualDisconnect = !1 : e === "disconnecting" && (this._wasManualDisconnect = r)
    }
    async _performAuth(e=null) {
        let r, n = !1;
        if (e)
            r = e,
            n = !0;
        else if (this.accessToken)
            try {
                r = await this.accessToken()
            } catch (s) {
                this.log("error", "Error fetching access token from callback", s),
                r = this.accessTokenValue
            }
        else
            r = this.accessTokenValue;
        n ? this._manuallySetToken = !0 : this.accessToken && (this._manuallySetToken = !1),
        this.accessTokenValue != r && (this.accessTokenValue = r,
        this.channels.forEach(s => {
            const i = {
                access_token: r,
                version: NA
            };
            r && s.updateJoinPayload(i),
            s.joinedOnce && s._isJoined() && s._push(mr.access_token, {
                access_token: r
            })
        }
        ))
    }
    async _waitForAuthIfNeeded() {
        this._authPromise && await this._authPromise
    }
    _setAuthSafely(e="general") {
        this._isManualToken() || this.setAuth().catch(r => {
            this.log("error", `Error setting auth in ${e}`, r)
        }
        )
    }
    _triggerStateCallbacks(e, r) {
        try {
            this.stateChangeCallbacks[e].forEach(n => {
                try {
                    n(r)
                } catch (s) {
                    this.log("error", `error in ${e} callback`, s)
                }
            }
            )
        } catch (n) {
            this.log("error", `error triggering ${e} callbacks`, n)
        }
    }
    _setupReconnectionTimer() {
        this.reconnectTimer = new Ib(async () => {
            setTimeout(async () => {
                await this._waitForAuthIfNeeded(),
                this.isConnected() || this.connect()
            }
            , bl.RECONNECT_DELAY)
        }
        ,this.reconnectAfterMs)
    }
    _initializeOptions(e) {
        var r, n, s, i, o, a, l, c, u, h, p, f;
        switch (this.transport = (r = e == null ? void 0 : e.transport) !== null && r !== void 0 ? r : null,
        this.timeout = (n = e == null ? void 0 : e.timeout) !== null && n !== void 0 ? n : Jh,
        this.heartbeatIntervalMs = (s = e == null ? void 0 : e.heartbeatIntervalMs) !== null && s !== void 0 ? s : bl.HEARTBEAT_INTERVAL,
        this.worker = (i = e == null ? void 0 : e.worker) !== null && i !== void 0 ? i : !1,
        this.accessToken = (o = e == null ? void 0 : e.accessToken) !== null && o !== void 0 ? o : null,
        this.heartbeatCallback = (a = e == null ? void 0 : e.heartbeatCallback) !== null && a !== void 0 ? a : dd,
        this.vsn = (l = e == null ? void 0 : e.vsn) !== null && l !== void 0 ? l : tv,
        e != null && e.params && (this.params = e.params),
        e != null && e.logger && (this.logger = e.logger),
        (e != null && e.logLevel || e != null && e.log_level) && (this.logLevel = e.logLevel || e.log_level,
        this.params = Object.assign(Object.assign({}, this.params), {
            log_level: this.logLevel
        })),
        this.reconnectAfterMs = (c = e == null ? void 0 : e.reconnectAfterMs) !== null && c !== void 0 ? c : b => UA[b - 1] || BA,
        this.vsn) {
        case Ob:
            this.encode = (u = e == null ? void 0 : e.encode) !== null && u !== void 0 ? u : (b, m) => m(JSON.stringify(b)),
            this.decode = (h = e == null ? void 0 : e.decode) !== null && h !== void 0 ? h : (b, m) => m(JSON.parse(b));
            break;
        case PA:
            this.encode = (p = e == null ? void 0 : e.encode) !== null && p !== void 0 ? p : this.serializer.encode.bind(this.serializer),
            this.decode = (f = e == null ? void 0 : e.decode) !== null && f !== void 0 ? f : this.serializer.decode.bind(this.serializer);
            break;
        default:
            throw new Error(`Unsupported serializer version: ${this.vsn}`)
        }
        if (this.worker) {
            if (typeof window < "u" && !window.Worker)
                throw new Error("Web Worker is not supported");
            this.workerUrl = e == null ? void 0 : e.workerUrl
        }
    }
}
var ka = class extends Error {
    constructor(t, e) {
        var r;
        super(t),
        this.name = "IcebergError",
        this.status = e.status,
        this.icebergType = e.icebergType,
        this.icebergCode = e.icebergCode,
        this.details = e.details,
        this.isCommitStateUnknown = e.icebergType === "CommitStateUnknownException" || [500, 502, 504].includes(e.status) && ((r = e.icebergType) == null ? void 0 : r.includes("CommitState")) === !0
    }
    isNotFound() {
        return this.status === 404
    }
    isConflict() {
        return this.status === 409
    }
    isAuthenticationTimeout() {
        return this.status === 419
    }
}
;
function WA(t, e, r) {
    const n = new URL(e,t);
    if (r)
        for (const [s,i] of Object.entries(r))
            i !== void 0 && n.searchParams.set(s, i);
    return n.toString()
}
async function HA(t) {
    return !t || t.type === "none" ? {} : t.type === "bearer" ? {
        Authorization: `Bearer ${t.token}`
    } : t.type === "header" ? {
        [t.name]: t.value
    } : t.type === "custom" ? await t.getHeaders() : {}
}
function KA(t) {
    const e = t.fetchImpl ?? globalThis.fetch;
    return {
        async request({method: r, path: n, query: s, body: i, headers: o}) {
            const a = WA(t.baseUrl, n, s)
              , l = await HA(t.auth)
              , c = await e(a, {
                method: r,
                headers: {
                    ...i ? {
                        "Content-Type": "application/json"
                    } : {},
                    ...l,
                    ...o
                },
                body: i ? JSON.stringify(i) : void 0
            })
              , u = await c.text()
              , h = (c.headers.get("content-type") || "").includes("application/json")
              , p = h && u ? JSON.parse(u) : u;
            if (!c.ok) {
                const f = h ? p : void 0
                  , b = f == null ? void 0 : f.error;
                throw new ka((b == null ? void 0 : b.message) ?? `Request failed with status ${c.status}`,{
                    status: c.status,
                    icebergType: b == null ? void 0 : b.type,
                    icebergCode: b == null ? void 0 : b.code,
                    details: f
                })
            }
            return {
                status: c.status,
                headers: c.headers,
                data: p
            }
        }
    }
}
function _l(t) {
    return t.join("")
}
var qA = class {
    constructor(t, e="") {
        this.client = t,
        this.prefix = e
    }
    async listNamespaces(t) {
        const e = t ? {
            parent: _l(t.namespace)
        } : void 0;
        return (await this.client.request({
            method: "GET",
            path: `${this.prefix}/namespaces`,
            query: e
        })).data.namespaces.map(n => ({
            namespace: n
        }))
    }
    async createNamespace(t, e) {
        const r = {
            namespace: t.namespace,
            properties: e == null ? void 0 : e.properties
        };
        return (await this.client.request({
            method: "POST",
            path: `${this.prefix}/namespaces`,
            body: r
        })).data
    }
    async dropNamespace(t) {
        await this.client.request({
            method: "DELETE",
            path: `${this.prefix}/namespaces/${_l(t.namespace)}`
        })
    }
    async loadNamespaceMetadata(t) {
        return {
            properties: (await this.client.request({
                method: "GET",
                path: `${this.prefix}/namespaces/${_l(t.namespace)}`
            })).data.properties
        }
    }
    async namespaceExists(t) {
        try {
            return await this.client.request({
                method: "HEAD",
                path: `${this.prefix}/namespaces/${_l(t.namespace)}`
            }),
            !0
        } catch (e) {
            if (e instanceof ka && e.status === 404)
                return !1;
            throw e
        }
    }
    async createNamespaceIfNotExists(t, e) {
        try {
            return await this.createNamespace(t, e)
        } catch (r) {
            if (r instanceof ka && r.status === 409)
                return;
            throw r
        }
    }
}
;
function Js(t) {
    return t.join("")
}
var GA = class {
    constructor(t, e="", r) {
        this.client = t,
        this.prefix = e,
        this.accessDelegation = r
    }
    async listTables(t) {
        return (await this.client.request({
            method: "GET",
            path: `${this.prefix}/namespaces/${Js(t.namespace)}/tables`
        })).data.identifiers
    }
    async createTable(t, e) {
        const r = {};
        return this.accessDelegation && (r["X-Iceberg-Access-Delegation"] = this.accessDelegation),
        (await this.client.request({
            method: "POST",
            path: `${this.prefix}/namespaces/${Js(t.namespace)}/tables`,
            body: e,
            headers: r
        })).data.metadata
    }
    async updateTable(t, e) {
        const r = await this.client.request({
            method: "POST",
            path: `${this.prefix}/namespaces/${Js(t.namespace)}/tables/${t.name}`,
            body: e
        });
        return {
            "metadata-location": r.data["metadata-location"],
            metadata: r.data.metadata
        }
    }
    async dropTable(t, e) {
        await this.client.request({
            method: "DELETE",
            path: `${this.prefix}/namespaces/${Js(t.namespace)}/tables/${t.name}`,
            query: {
                purgeRequested: String((e == null ? void 0 : e.purge) ?? !1)
            }
        })
    }
    async loadTable(t) {
        const e = {};
        return this.accessDelegation && (e["X-Iceberg-Access-Delegation"] = this.accessDelegation),
        (await this.client.request({
            method: "GET",
            path: `${this.prefix}/namespaces/${Js(t.namespace)}/tables/${t.name}`,
            headers: e
        })).data.metadata
    }
    async tableExists(t) {
        const e = {};
        this.accessDelegation && (e["X-Iceberg-Access-Delegation"] = this.accessDelegation);
        try {
            return await this.client.request({
                method: "HEAD",
                path: `${this.prefix}/namespaces/${Js(t.namespace)}/tables/${t.name}`,
                headers: e
            }),
            !0
        } catch (r) {
            if (r instanceof ka && r.status === 404)
                return !1;
            throw r
        }
    }
    async createTableIfNotExists(t, e) {
        try {
            return await this.createTable(t, e)
        } catch (r) {
            if (r instanceof ka && r.status === 409)
                return await this.loadTable({
                    namespace: t.namespace,
                    name: e.name
                });
            throw r
        }
    }
}
  , QA = class {
    constructor(t) {
        var n;
        let e = "v1";
        t.catalogName && (e += `/${t.catalogName}`);
        const r = t.baseUrl.endsWith("/") ? t.baseUrl : `${t.baseUrl}/`;
        this.client = KA({
            baseUrl: r,
            auth: t.auth,
            fetchImpl: t.fetch
        }),
        this.accessDelegation = (n = t.accessDelegation) == null ? void 0 : n.join(","),
        this.namespaceOps = new qA(this.client,e),
        this.tableOps = new GA(this.client,e,this.accessDelegation)
    }
    async listNamespaces(t) {
        return this.namespaceOps.listNamespaces(t)
    }
    async createNamespace(t, e) {
        return this.namespaceOps.createNamespace(t, e)
    }
    async dropNamespace(t) {
        await this.namespaceOps.dropNamespace(t)
    }
    async loadNamespaceMetadata(t) {
        return this.namespaceOps.loadNamespaceMetadata(t)
    }
    async listTables(t) {
        return this.tableOps.listTables(t)
    }
    async createTable(t, e) {
        return this.tableOps.createTable(t, e)
    }
    async updateTable(t, e) {
        return this.tableOps.updateTable(t, e)
    }
    async dropTable(t, e) {
        await this.tableOps.dropTable(t, e)
    }
    async loadTable(t) {
        return this.tableOps.loadTable(t)
    }
    async namespaceExists(t) {
        return this.namespaceOps.namespaceExists(t)
    }
    async tableExists(t) {
        return this.tableOps.tableExists(t)
    }
    async createNamespaceIfNotExists(t, e) {
        return this.namespaceOps.createNamespaceIfNotExists(t, e)
    }
    async createTableIfNotExists(t, e) {
        return this.tableOps.createTableIfNotExists(t, e)
    }
}
  , wu = class extends Error {
    constructor(t) {
        super(t),
        this.__isStorageError = !0,
        this.name = "StorageError"
    }
}
;
function Ie(t) {
    return typeof t == "object" && t !== null && "__isStorageError"in t
}
var JA = class extends wu {
    constructor(t, e, r) {
        super(t),
        this.name = "StorageApiError",
        this.status = e,
        this.statusCode = r
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            statusCode: this.statusCode
        }
    }
}
  , Xh = class extends wu {
    constructor(t, e) {
        super(t),
        this.name = "StorageUnknownError",
        this.originalError = e
    }
}
;
const Vp = t => t ? (...e) => t(...e) : (...e) => fetch(...e)
  , ZA = () => Response
  , ef = t => {
    if (Array.isArray(t))
        return t.map(r => ef(r));
    if (typeof t == "function" || t !== Object(t))
        return t;
    const e = {};
    return Object.entries(t).forEach( ([r,n]) => {
        const s = r.replace(/([-_][a-z])/gi, i => i.toUpperCase().replace(/[-_]/g, ""));
        e[s] = ef(n)
    }
    ),
    e
}
  , YA = t => {
    if (typeof t != "object" || t === null)
        return !1;
    const e = Object.getPrototypeOf(t);
    return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t)
}
  , XA = t => !t || typeof t != "string" || t.length === 0 || t.length > 100 || t.trim() !== t || t.includes("/") || t.includes("\\") ? !1 : /^[\w!.\*'() &$@=;:+,?-]+$/.test(t);
function Ea(t) {
    "@babel/helpers - typeof";
    return Ea = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ,
    Ea(t)
}
function ej(t, e) {
    if (Ea(t) != "object" || !t)
        return t;
    var r = t[Symbol.toPrimitive];
    if (r !== void 0) {
        var n = r.call(t, e || "default");
        if (Ea(n) != "object")
            return n;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(t)
}
function tj(t) {
    var e = ej(t, "string");
    return Ea(e) == "symbol" ? e : e + ""
}
function rj(t, e, r) {
    return (e = tj(e))in t ? Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = r,
    t
}
function iv(t, e) {
    var r = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(t);
        e && (n = n.filter(function(s) {
            return Object.getOwnPropertyDescriptor(t, s).enumerable
        })),
        r.push.apply(r, n)
    }
    return r
}
function Z(t) {
    for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? iv(Object(r), !0).forEach(function(n) {
            rj(t, n, r[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : iv(Object(r)).forEach(function(n) {
            Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
        })
    }
    return t
}
const hd = t => {
    var e;
    return t.msg || t.message || t.error_description || (typeof t.error == "string" ? t.error : (e = t.error) === null || e === void 0 ? void 0 : e.message) || JSON.stringify(t)
}
  , nj = async (t, e, r) => {
    t instanceof await ZA() && !(r != null && r.noResolveJson) ? t.json().then(n => {
        const s = t.status || 500
          , i = (n == null ? void 0 : n.statusCode) || s + "";
        e(new JA(hd(n),s,i))
    }
    ).catch(n => {
        e(new Xh(hd(n),n))
    }
    ) : e(new Xh(hd(t),t))
}
  , sj = (t, e, r, n) => {
    const s = {
        method: t,
        headers: (e == null ? void 0 : e.headers) || {}
    };
    return t === "GET" || !n ? s : (YA(n) ? (s.headers = Z({
        "Content-Type": "application/json"
    }, e == null ? void 0 : e.headers),
    s.body = JSON.stringify(n)) : s.body = n,
    e != null && e.duplex && (s.duplex = e.duplex),
    Z(Z({}, s), r))
}
;
async function Qa(t, e, r, n, s, i) {
    return new Promise( (o, a) => {
        t(r, sj(e, n, s, i)).then(l => {
            if (!l.ok)
                throw l;
            return n != null && n.noResolveJson ? l : l.json()
        }
        ).then(l => o(l)).catch(l => nj(l, a, n))
    }
    )
}
async function Ca(t, e, r, n) {
    return Qa(t, "GET", e, r, n)
}
async function dr(t, e, r, n, s) {
    return Qa(t, "POST", e, n, s, r)
}
async function tf(t, e, r, n, s) {
    return Qa(t, "PUT", e, n, s, r)
}
async function ij(t, e, r, n) {
    return Qa(t, "HEAD", e, Z(Z({}, r), {}, {
        noResolveJson: !0
    }), n)
}
async function Wp(t, e, r, n, s) {
    return Qa(t, "DELETE", e, n, s, r)
}
var oj = class {
    constructor(t, e) {
        this.downloadFn = t,
        this.shouldThrowOnError = e
    }
    then(t, e) {
        return this.execute().then(t, e)
    }
    async execute() {
        var t = this;
        try {
            return {
                data: (await t.downloadFn()).body,
                error: null
            }
        } catch (e) {
            if (t.shouldThrowOnError)
                throw e;
            if (Ie(e))
                return {
                    data: null,
                    error: e
                };
            throw e
        }
    }
}
;
let Db;
Db = Symbol.toStringTag;
var aj = class {
    constructor(t, e) {
        this.downloadFn = t,
        this.shouldThrowOnError = e,
        this[Db] = "BlobDownloadBuilder",
        this.promise = null
    }
    asStream() {
        return new oj(this.downloadFn,this.shouldThrowOnError)
    }
    then(t, e) {
        return this.getPromise().then(t, e)
    }
    catch(t) {
        return this.getPromise().catch(t)
    }
    finally(t) {
        return this.getPromise().finally(t)
    }
    getPromise() {
        return this.promise || (this.promise = this.execute()),
        this.promise
    }
    async execute() {
        var t = this;
        try {
            return {
                data: await (await t.downloadFn()).blob(),
                error: null
            }
        } catch (e) {
            if (t.shouldThrowOnError)
                throw e;
            if (Ie(e))
                return {
                    data: null,
                    error: e
                };
            throw e
        }
    }
}
;
const lj = {
    limit: 100,
    offset: 0,
    sortBy: {
        column: "name",
        order: "asc"
    }
}
  , ov = {
    cacheControl: "3600",
    contentType: "text/plain;charset=UTF-8",
    upsert: !1
};
var cj = class {
    constructor(t, e={}, r, n) {
        this.shouldThrowOnError = !1,
        this.url = t,
        this.headers = e,
        this.bucketId = r,
        this.fetch = Vp(n)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    async uploadOrUpdate(t, e, r, n) {
        var s = this;
        try {
            let i;
            const o = Z(Z({}, ov), n);
            let a = Z(Z({}, s.headers), t === "POST" && {
                "x-upsert": String(o.upsert)
            });
            const l = o.metadata;
            typeof Blob < "u" && r instanceof Blob ? (i = new FormData,
            i.append("cacheControl", o.cacheControl),
            l && i.append("metadata", s.encodeMetadata(l)),
            i.append("", r)) : typeof FormData < "u" && r instanceof FormData ? (i = r,
            i.has("cacheControl") || i.append("cacheControl", o.cacheControl),
            l && !i.has("metadata") && i.append("metadata", s.encodeMetadata(l))) : (i = r,
            a["cache-control"] = `max-age=${o.cacheControl}`,
            a["content-type"] = o.contentType,
            l && (a["x-metadata"] = s.toBase64(s.encodeMetadata(l))),
            (typeof ReadableStream < "u" && i instanceof ReadableStream || i && typeof i == "object" && "pipe"in i && typeof i.pipe == "function") && !o.duplex && (o.duplex = "half")),
            n != null && n.headers && (a = Z(Z({}, a), n.headers));
            const c = s._removeEmptyFolders(e)
              , u = s._getFinalPath(c)
              , h = await (t == "PUT" ? tf : dr)(s.fetch, `${s.url}/object/${u}`, i, Z({
                headers: a
            }, o != null && o.duplex ? {
                duplex: o.duplex
            } : {}));
            return {
                data: {
                    path: c,
                    id: h.Id,
                    fullPath: h.Key
                },
                error: null
            }
        } catch (i) {
            if (s.shouldThrowOnError)
                throw i;
            if (Ie(i))
                return {
                    data: null,
                    error: i
                };
            throw i
        }
    }
    async upload(t, e, r) {
        return this.uploadOrUpdate("POST", t, e, r)
    }
    async uploadToSignedUrl(t, e, r, n) {
        var s = this;
        const i = s._removeEmptyFolders(t)
          , o = s._getFinalPath(i)
          , a = new URL(s.url + `/object/upload/sign/${o}`);
        a.searchParams.set("token", e);
        try {
            let l;
            const c = Z({
                upsert: ov.upsert
            }, n)
              , u = Z(Z({}, s.headers), {
                "x-upsert": String(c.upsert)
            });
            return typeof Blob < "u" && r instanceof Blob ? (l = new FormData,
            l.append("cacheControl", c.cacheControl),
            l.append("", r)) : typeof FormData < "u" && r instanceof FormData ? (l = r,
            l.append("cacheControl", c.cacheControl)) : (l = r,
            u["cache-control"] = `max-age=${c.cacheControl}`,
            u["content-type"] = c.contentType),
            {
                data: {
                    path: i,
                    fullPath: (await tf(s.fetch, a.toString(), l, {
                        headers: u
                    })).Key
                },
                error: null
            }
        } catch (l) {
            if (s.shouldThrowOnError)
                throw l;
            if (Ie(l))
                return {
                    data: null,
                    error: l
                };
            throw l
        }
    }
    async createSignedUploadUrl(t, e) {
        var r = this;
        try {
            let n = r._getFinalPath(t);
            const s = Z({}, r.headers);
            e != null && e.upsert && (s["x-upsert"] = "true");
            const i = await dr(r.fetch, `${r.url}/object/upload/sign/${n}`, {}, {
                headers: s
            })
              , o = new URL(r.url + i.url)
              , a = o.searchParams.get("token");
            if (!a)
                throw new wu("No token returned by API");
            return {
                data: {
                    signedUrl: o.toString(),
                    path: t,
                    token: a
                },
                error: null
            }
        } catch (n) {
            if (r.shouldThrowOnError)
                throw n;
            if (Ie(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async update(t, e, r) {
        return this.uploadOrUpdate("PUT", t, e, r)
    }
    async move(t, e, r) {
        var n = this;
        try {
            return {
                data: await dr(n.fetch, `${n.url}/object/move`, {
                    bucketId: n.bucketId,
                    sourceKey: t,
                    destinationKey: e,
                    destinationBucket: r == null ? void 0 : r.destinationBucket
                }, {
                    headers: n.headers
                }),
                error: null
            }
        } catch (s) {
            if (n.shouldThrowOnError)
                throw s;
            if (Ie(s))
                return {
                    data: null,
                    error: s
                };
            throw s
        }
    }
    async copy(t, e, r) {
        var n = this;
        try {
            return {
                data: {
                    path: (await dr(n.fetch, `${n.url}/object/copy`, {
                        bucketId: n.bucketId,
                        sourceKey: t,
                        destinationKey: e,
                        destinationBucket: r == null ? void 0 : r.destinationBucket
                    }, {
                        headers: n.headers
                    })).Key
                },
                error: null
            }
        } catch (s) {
            if (n.shouldThrowOnError)
                throw s;
            if (Ie(s))
                return {
                    data: null,
                    error: s
                };
            throw s
        }
    }
    async createSignedUrl(t, e, r) {
        var n = this;
        try {
            let s = n._getFinalPath(t)
              , i = await dr(n.fetch, `${n.url}/object/sign/${s}`, Z({
                expiresIn: e
            }, r != null && r.transform ? {
                transform: r.transform
            } : {}), {
                headers: n.headers
            });
            const o = r != null && r.download ? `&download=${r.download === !0 ? "" : r.download}` : "";
            return i = {
                signedUrl: encodeURI(`${n.url}${i.signedURL}${o}`)
            },
            {
                data: i,
                error: null
            }
        } catch (s) {
            if (n.shouldThrowOnError)
                throw s;
            if (Ie(s))
                return {
                    data: null,
                    error: s
                };
            throw s
        }
    }
    async createSignedUrls(t, e, r) {
        var n = this;
        try {
            const s = await dr(n.fetch, `${n.url}/object/sign/${n.bucketId}`, {
                expiresIn: e,
                paths: t
            }, {
                headers: n.headers
            })
              , i = r != null && r.download ? `&download=${r.download === !0 ? "" : r.download}` : "";
            return {
                data: s.map(o => Z(Z({}, o), {}, {
                    signedUrl: o.signedURL ? encodeURI(`${n.url}${o.signedURL}${i}`) : null
                })),
                error: null
            }
        } catch (s) {
            if (n.shouldThrowOnError)
                throw s;
            if (Ie(s))
                return {
                    data: null,
                    error: s
                };
            throw s
        }
    }
    download(t, e) {
        const r = typeof (e == null ? void 0 : e.transform) < "u" ? "render/image/authenticated" : "object"
          , n = this.transformOptsToQueryString((e == null ? void 0 : e.transform) || {})
          , s = n ? `?${n}` : ""
          , i = this._getFinalPath(t)
          , o = () => Ca(this.fetch, `${this.url}/${r}/${i}${s}`, {
            headers: this.headers,
            noResolveJson: !0
        });
        return new aj(o,this.shouldThrowOnError)
    }
    async info(t) {
        var e = this;
        const r = e._getFinalPath(t);
        try {
            return {
                data: ef(await Ca(e.fetch, `${e.url}/object/info/${r}`, {
                    headers: e.headers
                })),
                error: null
            }
        } catch (n) {
            if (e.shouldThrowOnError)
                throw n;
            if (Ie(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async exists(t) {
        var e = this;
        const r = e._getFinalPath(t);
        try {
            return await ij(e.fetch, `${e.url}/object/${r}`, {
                headers: e.headers
            }),
            {
                data: !0,
                error: null
            }
        } catch (n) {
            if (e.shouldThrowOnError)
                throw n;
            if (Ie(n) && n instanceof Xh) {
                const s = n.originalError;
                if ([400, 404].includes(s == null ? void 0 : s.status))
                    return {
                        data: !1,
                        error: n
                    }
            }
            throw n
        }
    }
    getPublicUrl(t, e) {
        const r = this._getFinalPath(t)
          , n = []
          , s = e != null && e.download ? `download=${e.download === !0 ? "" : e.download}` : "";
        s !== "" && n.push(s);
        const i = typeof (e == null ? void 0 : e.transform) < "u" ? "render/image" : "object"
          , o = this.transformOptsToQueryString((e == null ? void 0 : e.transform) || {});
        o !== "" && n.push(o);
        let a = n.join("&");
        return a !== "" && (a = `?${a}`),
        {
            data: {
                publicUrl: encodeURI(`${this.url}/${i}/public/${r}${a}`)
            }
        }
    }
    async remove(t) {
        var e = this;
        try {
            return {
                data: await Wp(e.fetch, `${e.url}/object/${e.bucketId}`, {
                    prefixes: t
                }, {
                    headers: e.headers
                }),
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (Ie(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async list(t, e, r) {
        var n = this;
        try {
            const s = Z(Z(Z({}, lj), e), {}, {
                prefix: t || ""
            });
            return {
                data: await dr(n.fetch, `${n.url}/object/list/${n.bucketId}`, s, {
                    headers: n.headers
                }, r),
                error: null
            }
        } catch (s) {
            if (n.shouldThrowOnError)
                throw s;
            if (Ie(s))
                return {
                    data: null,
                    error: s
                };
            throw s
        }
    }
    async listV2(t, e) {
        var r = this;
        try {
            const n = Z({}, t);
            return {
                data: await dr(r.fetch, `${r.url}/object/list-v2/${r.bucketId}`, n, {
                    headers: r.headers
                }, e),
                error: null
            }
        } catch (n) {
            if (r.shouldThrowOnError)
                throw n;
            if (Ie(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    encodeMetadata(t) {
        return JSON.stringify(t)
    }
    toBase64(t) {
        return typeof Buffer < "u" ? Buffer.from(t).toString("base64") : btoa(t)
    }
    _getFinalPath(t) {
        return `${this.bucketId}/${t.replace(/^\/+/, "")}`
    }
    _removeEmptyFolders(t) {
        return t.replace(/^\/|\/$/g, "").replace(/\/+/g, "/")
    }
    transformOptsToQueryString(t) {
        const e = [];
        return t.width && e.push(`width=${t.width}`),
        t.height && e.push(`height=${t.height}`),
        t.resize && e.push(`resize=${t.resize}`),
        t.format && e.push(`format=${t.format}`),
        t.quality && e.push(`quality=${t.quality}`),
        e.join("&")
    }
}
;
const Mb = "2.90.1"
  , Fb = {
    "X-Client-Info": `storage-js/${Mb}`
};
var uj = class {
    constructor(t, e={}, r, n) {
        this.shouldThrowOnError = !1;
        const s = new URL(t);
        n != null && n.useNewHostname && /supabase\.(co|in|red)$/.test(s.hostname) && !s.hostname.includes("storage.supabase.") && (s.hostname = s.hostname.replace("supabase.", "storage.supabase.")),
        this.url = s.href.replace(/\/$/, ""),
        this.headers = Z(Z({}, Fb), e),
        this.fetch = Vp(r)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    async listBuckets(t) {
        var e = this;
        try {
            const r = e.listBucketOptionsToQueryString(t);
            return {
                data: await Ca(e.fetch, `${e.url}/bucket${r}`, {
                    headers: e.headers
                }),
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (Ie(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async getBucket(t) {
        var e = this;
        try {
            return {
                data: await Ca(e.fetch, `${e.url}/bucket/${t}`, {
                    headers: e.headers
                }),
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (Ie(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async createBucket(t, e={
        public: !1
    }) {
        var r = this;
        try {
            return {
                data: await dr(r.fetch, `${r.url}/bucket`, {
                    id: t,
                    name: t,
                    type: e.type,
                    public: e.public,
                    file_size_limit: e.fileSizeLimit,
                    allowed_mime_types: e.allowedMimeTypes
                }, {
                    headers: r.headers
                }),
                error: null
            }
        } catch (n) {
            if (r.shouldThrowOnError)
                throw n;
            if (Ie(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async updateBucket(t, e) {
        var r = this;
        try {
            return {
                data: await tf(r.fetch, `${r.url}/bucket/${t}`, {
                    id: t,
                    name: t,
                    public: e.public,
                    file_size_limit: e.fileSizeLimit,
                    allowed_mime_types: e.allowedMimeTypes
                }, {
                    headers: r.headers
                }),
                error: null
            }
        } catch (n) {
            if (r.shouldThrowOnError)
                throw n;
            if (Ie(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async emptyBucket(t) {
        var e = this;
        try {
            return {
                data: await dr(e.fetch, `${e.url}/bucket/${t}/empty`, {}, {
                    headers: e.headers
                }),
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (Ie(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async deleteBucket(t) {
        var e = this;
        try {
            return {
                data: await Wp(e.fetch, `${e.url}/bucket/${t}`, {}, {
                    headers: e.headers
                }),
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (Ie(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    listBucketOptionsToQueryString(t) {
        const e = {};
        return t && ("limit"in t && (e.limit = String(t.limit)),
        "offset"in t && (e.offset = String(t.offset)),
        t.search && (e.search = t.search),
        t.sortColumn && (e.sortColumn = t.sortColumn),
        t.sortOrder && (e.sortOrder = t.sortOrder)),
        Object.keys(e).length > 0 ? "?" + new URLSearchParams(e).toString() : ""
    }
}
  , dj = class {
    constructor(t, e={}, r) {
        this.shouldThrowOnError = !1,
        this.url = t.replace(/\/$/, ""),
        this.headers = Z(Z({}, Fb), e),
        this.fetch = Vp(r)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    async createBucket(t) {
        var e = this;
        try {
            return {
                data: await dr(e.fetch, `${e.url}/bucket`, {
                    name: t
                }, {
                    headers: e.headers
                }),
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (Ie(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async listBuckets(t) {
        var e = this;
        try {
            const r = new URLSearchParams;
            (t == null ? void 0 : t.limit) !== void 0 && r.set("limit", t.limit.toString()),
            (t == null ? void 0 : t.offset) !== void 0 && r.set("offset", t.offset.toString()),
            t != null && t.sortColumn && r.set("sortColumn", t.sortColumn),
            t != null && t.sortOrder && r.set("sortOrder", t.sortOrder),
            t != null && t.search && r.set("search", t.search);
            const n = r.toString()
              , s = n ? `${e.url}/bucket?${n}` : `${e.url}/bucket`;
            return {
                data: await Ca(e.fetch, s, {
                    headers: e.headers
                }),
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (Ie(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async deleteBucket(t) {
        var e = this;
        try {
            return {
                data: await Wp(e.fetch, `${e.url}/bucket/${t}`, {}, {
                    headers: e.headers
                }),
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (Ie(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    from(t) {
        var e = this;
        if (!XA(t))
            throw new wu("Invalid bucket name: File, folder, and bucket names must follow AWS object key naming guidelines and should avoid the use of any other characters.");
        const r = new QA({
            baseUrl: this.url,
            catalogName: t,
            auth: {
                type: "custom",
                getHeaders: async () => e.headers
            },
            fetch: this.fetch
        })
          , n = this.shouldThrowOnError;
        return new Proxy(r,{
            get(s, i) {
                const o = s[i];
                return typeof o != "function" ? o : async (...a) => {
                    try {
                        return {
                            data: await o.apply(s, a),
                            error: null
                        }
                    } catch (l) {
                        if (n)
                            throw l;
                        return {
                            data: null,
                            error: l
                        }
                    }
                }
            }
        })
    }
}
;
const Hp = {
    "X-Client-Info": `storage-js/${Mb}`,
    "Content-Type": "application/json"
};
var Ub = class extends Error {
    constructor(t) {
        super(t),
        this.__isStorageVectorsError = !0,
        this.name = "StorageVectorsError"
    }
}
;
function It(t) {
    return typeof t == "object" && t !== null && "__isStorageVectorsError"in t
}
var fd = class extends Ub {
    constructor(t, e, r) {
        super(t),
        this.name = "StorageVectorsApiError",
        this.status = e,
        this.statusCode = r
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            statusCode: this.statusCode
        }
    }
}
  , hj = class extends Ub {
    constructor(t, e) {
        super(t),
        this.name = "StorageVectorsUnknownError",
        this.originalError = e
    }
}
;
const Kp = t => t ? (...e) => t(...e) : (...e) => fetch(...e)
  , fj = t => {
    if (typeof t != "object" || t === null)
        return !1;
    const e = Object.getPrototypeOf(t);
    return (e === null || e === Object.prototype || Object.getPrototypeOf(e) === null) && !(Symbol.toStringTag in t) && !(Symbol.iterator in t)
}
  , av = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t)
  , pj = async (t, e, r) => {
    if (t && typeof t == "object" && "status"in t && "ok"in t && typeof t.status == "number" && !(r != null && r.noResolveJson)) {
        const n = t.status || 500
          , s = t;
        if (typeof s.json == "function")
            s.json().then(i => {
                const o = (i == null ? void 0 : i.statusCode) || (i == null ? void 0 : i.code) || n + "";
                e(new fd(av(i),n,o))
            }
            ).catch( () => {
                const i = n + "";
                e(new fd(s.statusText || `HTTP ${n} error`,n,i))
            }
            );
        else {
            const i = n + "";
            e(new fd(s.statusText || `HTTP ${n} error`,n,i))
        }
    } else
        e(new hj(av(t),t))
}
  , mj = (t, e, r, n) => {
    const s = {
        method: t,
        headers: (e == null ? void 0 : e.headers) || {}
    };
    return n ? (fj(n) ? (s.headers = Z({
        "Content-Type": "application/json"
    }, e == null ? void 0 : e.headers),
    s.body = JSON.stringify(n)) : s.body = n,
    Z(Z({}, s), r)) : s
}
;
async function gj(t, e, r, n, s, i) {
    return new Promise( (o, a) => {
        t(r, mj(e, n, s, i)).then(l => {
            if (!l.ok)
                throw l;
            if (n != null && n.noResolveJson)
                return l;
            const c = l.headers.get("content-type");
            return !c || !c.includes("application/json") ? {} : l.json()
        }
        ).then(l => o(l)).catch(l => pj(l, a, n))
    }
    )
}
async function Lt(t, e, r, n, s) {
    return gj(t, "POST", e, n, s, r)
}
var vj = class {
    constructor(t, e={}, r) {
        this.shouldThrowOnError = !1,
        this.url = t.replace(/\/$/, ""),
        this.headers = Z(Z({}, Hp), e),
        this.fetch = Kp(r)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    async createIndex(t) {
        var e = this;
        try {
            return {
                data: await Lt(e.fetch, `${e.url}/CreateIndex`, t, {
                    headers: e.headers
                }) || {},
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (It(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async getIndex(t, e) {
        var r = this;
        try {
            return {
                data: await Lt(r.fetch, `${r.url}/GetIndex`, {
                    vectorBucketName: t,
                    indexName: e
                }, {
                    headers: r.headers
                }),
                error: null
            }
        } catch (n) {
            if (r.shouldThrowOnError)
                throw n;
            if (It(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async listIndexes(t) {
        var e = this;
        try {
            return {
                data: await Lt(e.fetch, `${e.url}/ListIndexes`, t, {
                    headers: e.headers
                }),
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (It(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async deleteIndex(t, e) {
        var r = this;
        try {
            return {
                data: await Lt(r.fetch, `${r.url}/DeleteIndex`, {
                    vectorBucketName: t,
                    indexName: e
                }, {
                    headers: r.headers
                }) || {},
                error: null
            }
        } catch (n) {
            if (r.shouldThrowOnError)
                throw n;
            if (It(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
}
  , yj = class {
    constructor(t, e={}, r) {
        this.shouldThrowOnError = !1,
        this.url = t.replace(/\/$/, ""),
        this.headers = Z(Z({}, Hp), e),
        this.fetch = Kp(r)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    async putVectors(t) {
        var e = this;
        try {
            if (t.vectors.length < 1 || t.vectors.length > 500)
                throw new Error("Vector batch size must be between 1 and 500 items");
            return {
                data: await Lt(e.fetch, `${e.url}/PutVectors`, t, {
                    headers: e.headers
                }) || {},
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (It(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async getVectors(t) {
        var e = this;
        try {
            return {
                data: await Lt(e.fetch, `${e.url}/GetVectors`, t, {
                    headers: e.headers
                }),
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (It(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async listVectors(t) {
        var e = this;
        try {
            if (t.segmentCount !== void 0) {
                if (t.segmentCount < 1 || t.segmentCount > 16)
                    throw new Error("segmentCount must be between 1 and 16");
                if (t.segmentIndex !== void 0 && (t.segmentIndex < 0 || t.segmentIndex >= t.segmentCount))
                    throw new Error(`segmentIndex must be between 0 and ${t.segmentCount - 1}`)
            }
            return {
                data: await Lt(e.fetch, `${e.url}/ListVectors`, t, {
                    headers: e.headers
                }),
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (It(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async queryVectors(t) {
        var e = this;
        try {
            return {
                data: await Lt(e.fetch, `${e.url}/QueryVectors`, t, {
                    headers: e.headers
                }),
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (It(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async deleteVectors(t) {
        var e = this;
        try {
            if (t.keys.length < 1 || t.keys.length > 500)
                throw new Error("Keys batch size must be between 1 and 500 items");
            return {
                data: await Lt(e.fetch, `${e.url}/DeleteVectors`, t, {
                    headers: e.headers
                }) || {},
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (It(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
}
  , wj = class {
    constructor(t, e={}, r) {
        this.shouldThrowOnError = !1,
        this.url = t.replace(/\/$/, ""),
        this.headers = Z(Z({}, Hp), e),
        this.fetch = Kp(r)
    }
    throwOnError() {
        return this.shouldThrowOnError = !0,
        this
    }
    async createBucket(t) {
        var e = this;
        try {
            return {
                data: await Lt(e.fetch, `${e.url}/CreateVectorBucket`, {
                    vectorBucketName: t
                }, {
                    headers: e.headers
                }) || {},
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (It(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async getBucket(t) {
        var e = this;
        try {
            return {
                data: await Lt(e.fetch, `${e.url}/GetVectorBucket`, {
                    vectorBucketName: t
                }, {
                    headers: e.headers
                }),
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (It(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async listBuckets(t={}) {
        var e = this;
        try {
            return {
                data: await Lt(e.fetch, `${e.url}/ListVectorBuckets`, t, {
                    headers: e.headers
                }),
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (It(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async deleteBucket(t) {
        var e = this;
        try {
            return {
                data: await Lt(e.fetch, `${e.url}/DeleteVectorBucket`, {
                    vectorBucketName: t
                }, {
                    headers: e.headers
                }) || {},
                error: null
            }
        } catch (r) {
            if (e.shouldThrowOnError)
                throw r;
            if (It(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
}
  , xj = class extends wj {
    constructor(t, e={}) {
        super(t, e.headers || {}, e.fetch)
    }
    from(t) {
        return new bj(this.url,this.headers,t,this.fetch)
    }
    async createBucket(t) {
        var e = () => super.createBucket
          , r = this;
        return e().call(r, t)
    }
    async getBucket(t) {
        var e = () => super.getBucket
          , r = this;
        return e().call(r, t)
    }
    async listBuckets(t={}) {
        var e = () => super.listBuckets
          , r = this;
        return e().call(r, t)
    }
    async deleteBucket(t) {
        var e = () => super.deleteBucket
          , r = this;
        return e().call(r, t)
    }
}
  , bj = class extends vj {
    constructor(t, e, r, n) {
        super(t, e, n),
        this.vectorBucketName = r
    }
    async createIndex(t) {
        var e = () => super.createIndex
          , r = this;
        return e().call(r, Z(Z({}, t), {}, {
            vectorBucketName: r.vectorBucketName
        }))
    }
    async listIndexes(t={}) {
        var e = () => super.listIndexes
          , r = this;
        return e().call(r, Z(Z({}, t), {}, {
            vectorBucketName: r.vectorBucketName
        }))
    }
    async getIndex(t) {
        var e = () => super.getIndex
          , r = this;
        return e().call(r, r.vectorBucketName, t)
    }
    async deleteIndex(t) {
        var e = () => super.deleteIndex
          , r = this;
        return e().call(r, r.vectorBucketName, t)
    }
    index(t) {
        return new _j(this.url,this.headers,this.vectorBucketName,t,this.fetch)
    }
}
  , _j = class extends yj {
    constructor(t, e, r, n, s) {
        super(t, e, s),
        this.vectorBucketName = r,
        this.indexName = n
    }
    async putVectors(t) {
        var e = () => super.putVectors
          , r = this;
        return e().call(r, Z(Z({}, t), {}, {
            vectorBucketName: r.vectorBucketName,
            indexName: r.indexName
        }))
    }
    async getVectors(t) {
        var e = () => super.getVectors
          , r = this;
        return e().call(r, Z(Z({}, t), {}, {
            vectorBucketName: r.vectorBucketName,
            indexName: r.indexName
        }))
    }
    async listVectors(t={}) {
        var e = () => super.listVectors
          , r = this;
        return e().call(r, Z(Z({}, t), {}, {
            vectorBucketName: r.vectorBucketName,
            indexName: r.indexName
        }))
    }
    async queryVectors(t) {
        var e = () => super.queryVectors
          , r = this;
        return e().call(r, Z(Z({}, t), {}, {
            vectorBucketName: r.vectorBucketName,
            indexName: r.indexName
        }))
    }
    async deleteVectors(t) {
        var e = () => super.deleteVectors
          , r = this;
        return e().call(r, Z(Z({}, t), {}, {
            vectorBucketName: r.vectorBucketName,
            indexName: r.indexName
        }))
    }
}
  , Sj = class extends uj {
    constructor(t, e={}, r, n) {
        super(t, e, r, n)
    }
    from(t) {
        return new cj(this.url,this.headers,t,this.fetch)
    }
    get vectors() {
        return new xj(this.url + "/vector",{
            headers: this.headers,
            fetch: this.fetch
        })
    }
    get analytics() {
        return new dj(this.url + "/iceberg",this.headers,this.fetch)
    }
}
;
const Bb = "2.90.1"
  , ai = 30 * 1e3
  , rf = 3
  , pd = rf * ai
  , kj = "http://localhost:9999"
  , Ej = "supabase.auth.token"
  , Cj = {
    "X-Client-Info": `gotrue-js/${Bb}`
}
  , nf = "X-Supabase-Api-Version"
  , zb = {
    "2024-01-01": {
        timestamp: Date.parse("2024-01-01T00:00:00.0Z"),
        name: "2024-01-01"
    }
}
  , Tj = /^([a-z0-9_-]{4})*($|[a-z0-9_-]{3}$|[a-z0-9_-]{2}$)$/i
  , Rj = 10 * 60 * 1e3;
class Ta extends Error {
    constructor(e, r, n) {
        super(e),
        this.__isAuthError = !0,
        this.name = "AuthError",
        this.status = r,
        this.code = n
    }
}
function K(t) {
    return typeof t == "object" && t !== null && "__isAuthError"in t
}
class Nj extends Ta {
    constructor(e, r, n) {
        super(e, r, n),
        this.name = "AuthApiError",
        this.status = r,
        this.code = n
    }
}
function Pj(t) {
    return K(t) && t.name === "AuthApiError"
}
class fs extends Ta {
    constructor(e, r) {
        super(e),
        this.name = "AuthUnknownError",
        this.originalError = r
    }
}
class rn extends Ta {
    constructor(e, r, n, s) {
        super(e, n, s),
        this.name = r,
        this.status = n
    }
}
class Nt extends rn {
    constructor() {
        super("Auth session missing!", "AuthSessionMissingError", 400, void 0)
    }
}
function Aj(t) {
    return K(t) && t.name === "AuthSessionMissingError"
}
class Zs extends rn {
    constructor() {
        super("Auth session or user missing", "AuthInvalidTokenResponseError", 500, void 0)
    }
}
class Sl extends rn {
    constructor(e) {
        super(e, "AuthInvalidCredentialsError", 400, void 0)
    }
}
class kl extends rn {
    constructor(e, r=null) {
        super(e, "AuthImplicitGrantRedirectError", 500, void 0),
        this.details = null,
        this.details = r
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            details: this.details
        }
    }
}
function jj(t) {
    return K(t) && t.name === "AuthImplicitGrantRedirectError"
}
class lv extends rn {
    constructor(e, r=null) {
        super(e, "AuthPKCEGrantCodeExchangeError", 500, void 0),
        this.details = null,
        this.details = r
    }
    toJSON() {
        return {
            name: this.name,
            message: this.message,
            status: this.status,
            details: this.details
        }
    }
}
class Oj extends rn {
    constructor() {
        super("PKCE code verifier not found in storage. This can happen if the auth flow was initiated in a different browser or device, or if the storage was cleared. For SSR frameworks (Next.js, SvelteKit, etc.), use @supabase/ssr on both the server and client to store the code verifier in cookies.", "AuthPKCECodeVerifierMissingError", 400, "pkce_code_verifier_not_found")
    }
}
class sf extends rn {
    constructor(e, r) {
        super(e, "AuthRetryableFetchError", r, void 0)
    }
}
function md(t) {
    return K(t) && t.name === "AuthRetryableFetchError"
}
class cv extends rn {
    constructor(e, r, n) {
        super(e, "AuthWeakPasswordError", r, "weak_password"),
        this.reasons = n
    }
}
class of extends rn {
    constructor(e) {
        super(e, "AuthInvalidJwtError", 400, "invalid_jwt")
    }
}
const Pc = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_".split("")
  , uv = ` 	
\r=`.split("")
  , Ij = ( () => {
    const t = new Array(128);
    for (let e = 0; e < t.length; e += 1)
        t[e] = -1;
    for (let e = 0; e < uv.length; e += 1)
        t[uv[e].charCodeAt(0)] = -2;
    for (let e = 0; e < Pc.length; e += 1)
        t[Pc[e].charCodeAt(0)] = e;
    return t
}
)();
function dv(t, e, r) {
    if (t !== null)
        for (e.queue = e.queue << 8 | t,
        e.queuedBits += 8; e.queuedBits >= 6; ) {
            const n = e.queue >> e.queuedBits - 6 & 63;
            r(Pc[n]),
            e.queuedBits -= 6
        }
    else if (e.queuedBits > 0)
        for (e.queue = e.queue << 6 - e.queuedBits,
        e.queuedBits = 6; e.queuedBits >= 6; ) {
            const n = e.queue >> e.queuedBits - 6 & 63;
            r(Pc[n]),
            e.queuedBits -= 6
        }
}
function Vb(t, e, r) {
    const n = Ij[t];
    if (n > -1)
        for (e.queue = e.queue << 6 | n,
        e.queuedBits += 6; e.queuedBits >= 8; )
            r(e.queue >> e.queuedBits - 8 & 255),
            e.queuedBits -= 8;
    else {
        if (n === -2)
            return;
        throw new Error(`Invalid Base64-URL character "${String.fromCharCode(t)}"`)
    }
}
function hv(t) {
    const e = []
      , r = o => {
        e.push(String.fromCodePoint(o))
    }
      , n = {
        utf8seq: 0,
        codepoint: 0
    }
      , s = {
        queue: 0,
        queuedBits: 0
    }
      , i = o => {
        Dj(o, n, r)
    }
    ;
    for (let o = 0; o < t.length; o += 1)
        Vb(t.charCodeAt(o), s, i);
    return e.join("")
}
function Lj(t, e) {
    if (t <= 127) {
        e(t);
        return
    } else if (t <= 2047) {
        e(192 | t >> 6),
        e(128 | t & 63);
        return
    } else if (t <= 65535) {
        e(224 | t >> 12),
        e(128 | t >> 6 & 63),
        e(128 | t & 63);
        return
    } else if (t <= 1114111) {
        e(240 | t >> 18),
        e(128 | t >> 12 & 63),
        e(128 | t >> 6 & 63),
        e(128 | t & 63);
        return
    }
    throw new Error(`Unrecognized Unicode codepoint: ${t.toString(16)}`)
}
function $j(t, e) {
    for (let r = 0; r < t.length; r += 1) {
        let n = t.charCodeAt(r);
        if (n > 55295 && n <= 56319) {
            const s = (n - 55296) * 1024 & 65535;
            n = (t.charCodeAt(r + 1) - 56320 & 65535 | s) + 65536,
            r += 1
        }
        Lj(n, e)
    }
}
function Dj(t, e, r) {
    if (e.utf8seq === 0) {
        if (t <= 127) {
            r(t);
            return
        }
        for (let n = 1; n < 6; n += 1)
            if (!(t >> 7 - n & 1)) {
                e.utf8seq = n;
                break
            }
        if (e.utf8seq === 2)
            e.codepoint = t & 31;
        else if (e.utf8seq === 3)
            e.codepoint = t & 15;
        else if (e.utf8seq === 4)
            e.codepoint = t & 7;
        else
            throw new Error("Invalid UTF-8 sequence");
        e.utf8seq -= 1
    } else if (e.utf8seq > 0) {
        if (t <= 127)
            throw new Error("Invalid UTF-8 sequence");
        e.codepoint = e.codepoint << 6 | t & 63,
        e.utf8seq -= 1,
        e.utf8seq === 0 && r(e.codepoint)
    }
}
function Ii(t) {
    const e = []
      , r = {
        queue: 0,
        queuedBits: 0
    }
      , n = s => {
        e.push(s)
    }
    ;
    for (let s = 0; s < t.length; s += 1)
        Vb(t.charCodeAt(s), r, n);
    return new Uint8Array(e)
}
function Mj(t) {
    const e = [];
    return $j(t, r => e.push(r)),
    new Uint8Array(e)
}
function vs(t) {
    const e = []
      , r = {
        queue: 0,
        queuedBits: 0
    }
      , n = s => {
        e.push(s)
    }
    ;
    return t.forEach(s => dv(s, r, n)),
    dv(null, r, n),
    e.join("")
}
function Fj(t) {
    return Math.round(Date.now() / 1e3) + t
}
function Uj() {
    return Symbol("auth-callback")
}
const rt = () => typeof window < "u" && typeof document < "u"
  , as = {
    tested: !1,
    writable: !1
}
  , Wb = () => {
    if (!rt())
        return !1;
    try {
        if (typeof globalThis.localStorage != "object")
            return !1
    } catch {
        return !1
    }
    if (as.tested)
        return as.writable;
    const t = `lswt-${Math.random()}${Math.random()}`;
    try {
        globalThis.localStorage.setItem(t, t),
        globalThis.localStorage.removeItem(t),
        as.tested = !0,
        as.writable = !0
    } catch {
        as.tested = !0,
        as.writable = !1
    }
    return as.writable
}
;
function Bj(t) {
    const e = {}
      , r = new URL(t);
    if (r.hash && r.hash[0] === "#")
        try {
            new URLSearchParams(r.hash.substring(1)).forEach( (s, i) => {
                e[i] = s
            }
            )
        } catch {}
    return r.searchParams.forEach( (n, s) => {
        e[s] = n
    }
    ),
    e
}
const Hb = t => t ? (...e) => t(...e) : (...e) => fetch(...e)
  , zj = t => typeof t == "object" && t !== null && "status"in t && "ok"in t && "json"in t && typeof t.json == "function"
  , li = async (t, e, r) => {
    await t.setItem(e, JSON.stringify(r))
}
  , ls = async (t, e) => {
    const r = await t.getItem(e);
    if (!r)
        return null;
    try {
        return JSON.parse(r)
    } catch {
        return r
    }
}
  , tt = async (t, e) => {
    await t.removeItem(e)
}
;
class xu {
    constructor() {
        this.promise = new xu.promiseConstructor( (e, r) => {
            this.resolve = e,
            this.reject = r
        }
        )
    }
}
xu.promiseConstructor = Promise;
function gd(t) {
    const e = t.split(".");
    if (e.length !== 3)
        throw new of("Invalid JWT structure");
    for (let n = 0; n < e.length; n++)
        if (!Tj.test(e[n]))
            throw new of("JWT not in base64url format");
    return {
        header: JSON.parse(hv(e[0])),
        payload: JSON.parse(hv(e[1])),
        signature: Ii(e[2]),
        raw: {
            header: e[0],
            payload: e[1]
        }
    }
}
async function Vj(t) {
    return await new Promise(e => {
        setTimeout( () => e(null), t)
    }
    )
}
function Wj(t, e) {
    return new Promise( (n, s) => {
        (async () => {
            for (let i = 0; i < 1 / 0; i++)
                try {
                    const o = await t(i);
                    if (!e(i, null, o)) {
                        n(o);
                        return
                    }
                } catch (o) {
                    if (!e(i, o)) {
                        s(o);
                        return
                    }
                }
        }
        )()
    }
    )
}
function Hj(t) {
    return ("0" + t.toString(16)).substr(-2)
}
function Kj() {
    const e = new Uint32Array(56);
    if (typeof crypto > "u") {
        const r = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-._~"
          , n = r.length;
        let s = "";
        for (let i = 0; i < 56; i++)
            s += r.charAt(Math.floor(Math.random() * n));
        return s
    }
    return crypto.getRandomValues(e),
    Array.from(e, Hj).join("")
}
async function qj(t) {
    const r = new TextEncoder().encode(t)
      , n = await crypto.subtle.digest("SHA-256", r)
      , s = new Uint8Array(n);
    return Array.from(s).map(i => String.fromCharCode(i)).join("")
}
async function Gj(t) {
    if (!(typeof crypto < "u" && typeof crypto.subtle < "u" && typeof TextEncoder < "u"))
        return console.warn("WebCrypto API is not supported. Code challenge method will default to use plain instead of sha256."),
        t;
    const r = await qj(t);
    return btoa(r).replace(/\+/g, "-").replace(/\//g, "_").replace(/=+$/, "")
}
async function Ys(t, e, r=!1) {
    const n = Kj();
    let s = n;
    r && (s += "/PASSWORD_RECOVERY"),
    await li(t, `${e}-code-verifier`, s);
    const i = await Gj(n);
    return [i, n === i ? "plain" : "s256"]
}
const Qj = /^2[0-9]{3}-(0[1-9]|1[0-2])-(0[1-9]|1[0-9]|2[0-9]|3[0-1])$/i;
function Jj(t) {
    const e = t.headers.get(nf);
    if (!e || !e.match(Qj))
        return null;
    try {
        return new Date(`${e}T00:00:00.0Z`)
    } catch {
        return null
    }
}
function Zj(t) {
    if (!t)
        throw new Error("Missing exp claim");
    const e = Math.floor(Date.now() / 1e3);
    if (t <= e)
        throw new Error("JWT has expired")
}
function Yj(t) {
    switch (t) {
    case "RS256":
        return {
            name: "RSASSA-PKCS1-v1_5",
            hash: {
                name: "SHA-256"
            }
        };
    case "ES256":
        return {
            name: "ECDSA",
            namedCurve: "P-256",
            hash: {
                name: "SHA-256"
            }
        };
    default:
        throw new Error("Invalid alg claim")
    }
}
const Xj = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/;
function Xs(t) {
    if (!Xj.test(t))
        throw new Error("@supabase/auth-js: Expected parameter to be UUID but is not")
}
function vd() {
    const t = {};
    return new Proxy(t,{
        get: (e, r) => {
            if (r === "__isUserNotAvailableProxy")
                return !0;
            if (typeof r == "symbol") {
                const n = r.toString();
                if (n === "Symbol(Symbol.toPrimitive)" || n === "Symbol(Symbol.toStringTag)" || n === "Symbol(util.inspect.custom)")
                    return
            }
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Accessing the "${r}" property of the session object is not supported. Please use getUser() instead.`)
        }
        ,
        set: (e, r) => {
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Setting the "${r}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)
        }
        ,
        deleteProperty: (e, r) => {
            throw new Error(`@supabase/auth-js: client was created with userStorage option and there was no user stored in the user storage. Deleting the "${r}" property of the session object is not supported. Please use getUser() to fetch a user object you can manipulate.`)
        }
    })
}
function eO(t, e) {
    return new Proxy(t,{
        get: (r, n, s) => {
            if (n === "__isInsecureUserWarningProxy")
                return !0;
            if (typeof n == "symbol") {
                const i = n.toString();
                if (i === "Symbol(Symbol.toPrimitive)" || i === "Symbol(Symbol.toStringTag)" || i === "Symbol(util.inspect.custom)" || i === "Symbol(nodejs.util.inspect.custom)")
                    return Reflect.get(r, n, s)
            }
            return !e.value && typeof n == "string" && (console.warn("Using the user object as returned from supabase.auth.getSession() or from some supabase.auth.onAuthStateChange() events could be insecure! This value comes directly from the storage medium (usually cookies on the server) and may not be authentic. Use supabase.auth.getUser() instead which authenticates the data by contacting the Supabase Auth server."),
            e.value = !0),
            Reflect.get(r, n, s)
        }
    })
}
function fv(t) {
    return JSON.parse(JSON.stringify(t))
}
const ds = t => t.msg || t.message || t.error_description || t.error || JSON.stringify(t)
  , tO = [502, 503, 504];
async function pv(t) {
    var e;
    if (!zj(t))
        throw new sf(ds(t),0);
    if (tO.includes(t.status))
        throw new sf(ds(t),t.status);
    let r;
    try {
        r = await t.json()
    } catch (i) {
        throw new fs(ds(i),i)
    }
    let n;
    const s = Jj(t);
    if (s && s.getTime() >= zb["2024-01-01"].timestamp && typeof r == "object" && r && typeof r.code == "string" ? n = r.code : typeof r == "object" && r && typeof r.error_code == "string" && (n = r.error_code),
    n) {
        if (n === "weak_password")
            throw new cv(ds(r),t.status,((e = r.weak_password) === null || e === void 0 ? void 0 : e.reasons) || []);
        if (n === "session_not_found")
            throw new Nt
    } else if (typeof r == "object" && r && typeof r.weak_password == "object" && r.weak_password && Array.isArray(r.weak_password.reasons) && r.weak_password.reasons.length && r.weak_password.reasons.reduce( (i, o) => i && typeof o == "string", !0))
        throw new cv(ds(r),t.status,r.weak_password.reasons);
    throw new Nj(ds(r),t.status || 500,n)
}
const rO = (t, e, r, n) => {
    const s = {
        method: t,
        headers: (e == null ? void 0 : e.headers) || {}
    };
    return t === "GET" ? s : (s.headers = Object.assign({
        "Content-Type": "application/json;charset=UTF-8"
    }, e == null ? void 0 : e.headers),
    s.body = JSON.stringify(n),
    Object.assign(Object.assign({}, s), r))
}
;
async function J(t, e, r, n) {
    var s;
    const i = Object.assign({}, n == null ? void 0 : n.headers);
    i[nf] || (i[nf] = zb["2024-01-01"].name),
    n != null && n.jwt && (i.Authorization = `Bearer ${n.jwt}`);
    const o = (s = n == null ? void 0 : n.query) !== null && s !== void 0 ? s : {};
    n != null && n.redirectTo && (o.redirect_to = n.redirectTo);
    const a = Object.keys(o).length ? "?" + new URLSearchParams(o).toString() : ""
      , l = await nO(t, e, r + a, {
        headers: i,
        noResolveJson: n == null ? void 0 : n.noResolveJson
    }, {}, n == null ? void 0 : n.body);
    return n != null && n.xform ? n == null ? void 0 : n.xform(l) : {
        data: Object.assign({}, l),
        error: null
    }
}
async function nO(t, e, r, n, s, i) {
    const o = rO(e, n, s, i);
    let a;
    try {
        a = await t(r, Object.assign({}, o))
    } catch (l) {
        throw console.error(l),
        new sf(ds(l),0)
    }
    if (a.ok || await pv(a),
    n != null && n.noResolveJson)
        return a;
    try {
        return await a.json()
    } catch (l) {
        await pv(l)
    }
}
function lr(t) {
    var e;
    let r = null;
    oO(t) && (r = Object.assign({}, t),
    t.expires_at || (r.expires_at = Fj(t.expires_in)));
    const n = (e = t.user) !== null && e !== void 0 ? e : t;
    return {
        data: {
            session: r,
            user: n
        },
        error: null
    }
}
function mv(t) {
    const e = lr(t);
    return !e.error && t.weak_password && typeof t.weak_password == "object" && Array.isArray(t.weak_password.reasons) && t.weak_password.reasons.length && t.weak_password.message && typeof t.weak_password.message == "string" && t.weak_password.reasons.reduce( (r, n) => r && typeof n == "string", !0) && (e.data.weak_password = t.weak_password),
    e
}
function wn(t) {
    var e;
    return {
        data: {
            user: (e = t.user) !== null && e !== void 0 ? e : t
        },
        error: null
    }
}
function sO(t) {
    return {
        data: t,
        error: null
    }
}
function iO(t) {
    const {action_link: e, email_otp: r, hashed_token: n, redirect_to: s, verification_type: i} = t
      , o = wo(t, ["action_link", "email_otp", "hashed_token", "redirect_to", "verification_type"])
      , a = {
        action_link: e,
        email_otp: r,
        hashed_token: n,
        redirect_to: s,
        verification_type: i
    }
      , l = Object.assign({}, o);
    return {
        data: {
            properties: a,
            user: l
        },
        error: null
    }
}
function gv(t) {
    return t
}
function oO(t) {
    return t.access_token && t.refresh_token && t.expires_in
}
const yd = ["global", "local", "others"];
class aO {
    constructor({url: e="", headers: r={}, fetch: n}) {
        this.url = e,
        this.headers = r,
        this.fetch = Hb(n),
        this.mfa = {
            listFactors: this._listFactors.bind(this),
            deleteFactor: this._deleteFactor.bind(this)
        },
        this.oauth = {
            listClients: this._listOAuthClients.bind(this),
            createClient: this._createOAuthClient.bind(this),
            getClient: this._getOAuthClient.bind(this),
            updateClient: this._updateOAuthClient.bind(this),
            deleteClient: this._deleteOAuthClient.bind(this),
            regenerateClientSecret: this._regenerateOAuthClientSecret.bind(this)
        }
    }
    async signOut(e, r=yd[0]) {
        if (yd.indexOf(r) < 0)
            throw new Error(`@supabase/auth-js: Parameter scope must be one of ${yd.join(", ")}`);
        try {
            return await J(this.fetch, "POST", `${this.url}/logout?scope=${r}`, {
                headers: this.headers,
                jwt: e,
                noResolveJson: !0
            }),
            {
                data: null,
                error: null
            }
        } catch (n) {
            if (K(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async inviteUserByEmail(e, r={}) {
        try {
            return await J(this.fetch, "POST", `${this.url}/invite`, {
                body: {
                    email: e,
                    data: r.data
                },
                headers: this.headers,
                redirectTo: r.redirectTo,
                xform: wn
            })
        } catch (n) {
            if (K(n))
                return {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async generateLink(e) {
        try {
            const {options: r} = e
              , n = wo(e, ["options"])
              , s = Object.assign(Object.assign({}, n), r);
            return "newEmail"in n && (s.new_email = n == null ? void 0 : n.newEmail,
            delete s.newEmail),
            await J(this.fetch, "POST", `${this.url}/admin/generate_link`, {
                body: s,
                headers: this.headers,
                xform: iO,
                redirectTo: r == null ? void 0 : r.redirectTo
            })
        } catch (r) {
            if (K(r))
                return {
                    data: {
                        properties: null,
                        user: null
                    },
                    error: r
                };
            throw r
        }
    }
    async createUser(e) {
        try {
            return await J(this.fetch, "POST", `${this.url}/admin/users`, {
                body: e,
                headers: this.headers,
                xform: wn
            })
        } catch (r) {
            if (K(r))
                return {
                    data: {
                        user: null
                    },
                    error: r
                };
            throw r
        }
    }
    async listUsers(e) {
        var r, n, s, i, o, a, l;
        try {
            const c = {
                nextPage: null,
                lastPage: 0,
                total: 0
            }
              , u = await J(this.fetch, "GET", `${this.url}/admin/users`, {
                headers: this.headers,
                noResolveJson: !0,
                query: {
                    page: (n = (r = e == null ? void 0 : e.page) === null || r === void 0 ? void 0 : r.toString()) !== null && n !== void 0 ? n : "",
                    per_page: (i = (s = e == null ? void 0 : e.perPage) === null || s === void 0 ? void 0 : s.toString()) !== null && i !== void 0 ? i : ""
                },
                xform: gv
            });
            if (u.error)
                throw u.error;
            const h = await u.json()
              , p = (o = u.headers.get("x-total-count")) !== null && o !== void 0 ? o : 0
              , f = (l = (a = u.headers.get("link")) === null || a === void 0 ? void 0 : a.split(",")) !== null && l !== void 0 ? l : [];
            return f.length > 0 && (f.forEach(b => {
                const m = parseInt(b.split(";")[0].split("=")[1].substring(0, 1))
                  , x = JSON.parse(b.split(";")[1].split("=")[1]);
                c[`${x}Page`] = m
            }
            ),
            c.total = parseInt(p)),
            {
                data: Object.assign(Object.assign({}, h), c),
                error: null
            }
        } catch (c) {
            if (K(c))
                return {
                    data: {
                        users: []
                    },
                    error: c
                };
            throw c
        }
    }
    async getUserById(e) {
        Xs(e);
        try {
            return await J(this.fetch, "GET", `${this.url}/admin/users/${e}`, {
                headers: this.headers,
                xform: wn
            })
        } catch (r) {
            if (K(r))
                return {
                    data: {
                        user: null
                    },
                    error: r
                };
            throw r
        }
    }
    async updateUserById(e, r) {
        Xs(e);
        try {
            return await J(this.fetch, "PUT", `${this.url}/admin/users/${e}`, {
                body: r,
                headers: this.headers,
                xform: wn
            })
        } catch (n) {
            if (K(n))
                return {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async deleteUser(e, r=!1) {
        Xs(e);
        try {
            return await J(this.fetch, "DELETE", `${this.url}/admin/users/${e}`, {
                headers: this.headers,
                body: {
                    should_soft_delete: r
                },
                xform: wn
            })
        } catch (n) {
            if (K(n))
                return {
                    data: {
                        user: null
                    },
                    error: n
                };
            throw n
        }
    }
    async _listFactors(e) {
        Xs(e.userId);
        try {
            const {data: r, error: n} = await J(this.fetch, "GET", `${this.url}/admin/users/${e.userId}/factors`, {
                headers: this.headers,
                xform: s => ({
                    data: {
                        factors: s
                    },
                    error: null
                })
            });
            return {
                data: r,
                error: n
            }
        } catch (r) {
            if (K(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _deleteFactor(e) {
        Xs(e.userId),
        Xs(e.id);
        try {
            return {
                data: await J(this.fetch, "DELETE", `${this.url}/admin/users/${e.userId}/factors/${e.id}`, {
                    headers: this.headers
                }),
                error: null
            }
        } catch (r) {
            if (K(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _listOAuthClients(e) {
        var r, n, s, i, o, a, l;
        try {
            const c = {
                nextPage: null,
                lastPage: 0,
                total: 0
            }
              , u = await J(this.fetch, "GET", `${this.url}/admin/oauth/clients`, {
                headers: this.headers,
                noResolveJson: !0,
                query: {
                    page: (n = (r = e == null ? void 0 : e.page) === null || r === void 0 ? void 0 : r.toString()) !== null && n !== void 0 ? n : "",
                    per_page: (i = (s = e == null ? void 0 : e.perPage) === null || s === void 0 ? void 0 : s.toString()) !== null && i !== void 0 ? i : ""
                },
                xform: gv
            });
            if (u.error)
                throw u.error;
            const h = await u.json()
              , p = (o = u.headers.get("x-total-count")) !== null && o !== void 0 ? o : 0
              , f = (l = (a = u.headers.get("link")) === null || a === void 0 ? void 0 : a.split(",")) !== null && l !== void 0 ? l : [];
            return f.length > 0 && (f.forEach(b => {
                const m = parseInt(b.split(";")[0].split("=")[1].substring(0, 1))
                  , x = JSON.parse(b.split(";")[1].split("=")[1]);
                c[`${x}Page`] = m
            }
            ),
            c.total = parseInt(p)),
            {
                data: Object.assign(Object.assign({}, h), c),
                error: null
            }
        } catch (c) {
            if (K(c))
                return {
                    data: {
                        clients: []
                    },
                    error: c
                };
            throw c
        }
    }
    async _createOAuthClient(e) {
        try {
            return await J(this.fetch, "POST", `${this.url}/admin/oauth/clients`, {
                body: e,
                headers: this.headers,
                xform: r => ({
                    data: r,
                    error: null
                })
            })
        } catch (r) {
            if (K(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _getOAuthClient(e) {
        try {
            return await J(this.fetch, "GET", `${this.url}/admin/oauth/clients/${e}`, {
                headers: this.headers,
                xform: r => ({
                    data: r,
                    error: null
                })
            })
        } catch (r) {
            if (K(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _updateOAuthClient(e, r) {
        try {
            return await J(this.fetch, "PUT", `${this.url}/admin/oauth/clients/${e}`, {
                body: r,
                headers: this.headers,
                xform: n => ({
                    data: n,
                    error: null
                })
            })
        } catch (n) {
            if (K(n))
                return {
                    data: null,
                    error: n
                };
            throw n
        }
    }
    async _deleteOAuthClient(e) {
        try {
            return await J(this.fetch, "DELETE", `${this.url}/admin/oauth/clients/${e}`, {
                headers: this.headers,
                noResolveJson: !0
            }),
            {
                data: null,
                error: null
            }
        } catch (r) {
            if (K(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
    async _regenerateOAuthClientSecret(e) {
        try {
            return await J(this.fetch, "POST", `${this.url}/admin/oauth/clients/${e}/regenerate_secret`, {
                headers: this.headers,
                xform: r => ({
                    data: r,
                    error: null
                })
            })
        } catch (r) {
            if (K(r))
                return {
                    data: null,
                    error: r
                };
            throw r
        }
    }
}
function vv(t={}) {
    return {
        getItem: e => t[e] || null,
        setItem: (e, r) => {
            t[e] = r
        }
        ,
        removeItem: e => {
            delete t[e]
        }
    }
}
const ei = {
    debug: !!(globalThis && Wb() && globalThis.localStorage && globalThis.localStorage.getItem("supabase.gotrue-js.locks.debug") === "true")
};
class Kb extends Error {
    constructor(e) {
        super(e),
        this.isAcquireTimeout = !0
    }
}
class lO extends Kb {
}
async function cO(t, e, r) {
    ei.debug && console.log("@supabase/gotrue-js: navigatorLock: acquire lock", t, e);
    const n = new globalThis.AbortController;
    return e > 0 && setTimeout( () => {
        n.abort(),
        ei.debug && console.log("@supabase/gotrue-js: navigatorLock acquire timed out", t)
    }
    , e),
    await Promise.resolve().then( () => globalThis.navigator.locks.request(t, e === 0 ? {
        mode: "exclusive",
        ifAvailable: !0
    } : {
        mode: "exclusive",
        signal: n.signal
    }, async s => {
        if (s) {
            ei.debug && console.log("@supabase/gotrue-js: navigatorLock: acquired", t, s.name);
            try {
                return await r()
            } finally {
                ei.debug && console.log("@supabase/gotrue-js: navigatorLock: released", t, s.name)
            }
        } else {
            if (e === 0)
                throw ei.debug && console.log("@supabase/gotrue-js: navigatorLock: not immediately available", t),
                new lO(`Acquiring an exclusive Navigator LockManager lock "${t}" immediately failed`);
            if (ei.debug)
                try {
                    const i = await globalThis.navigator.locks.query();
                    console.log("@supabase/gotrue-js: Navigator LockManager state", JSON.stringify(i, null, "  "))
                } catch (i) {
                    console.warn("@supabase/gotrue-js: Error when querying Navigator LockManager state", i)
                }
            return console.warn("@supabase/gotrue-js: Navigator LockManager returned a null lock when using #request without ifAvailable set to true, it appears this browser is not following the LockManager spec https://developer.mozilla.org/en-US/docs/Web/API/LockManager/request"),
            await r()
        }
    }
    ))
}
function uO() {
    if (typeof globalThis != "object")
        try {
            Object.defineProperty(Object.prototype, "__magic__", {
                get: function() {
                    return this
                },
                configurable: !0
            }),
            __magic__.globalThis = __magic__,
            delete Object.prototype.__magic__
        } catch {
            typeof self < "u" && (self.globalThis = self)
        }
}
function qb(t) {
    if (!/^0x[a-fA-F0-9]{40}$/.test(t))
        throw new Error(`@supabase/auth-js: Address "${t}" is invalid.`);
    return t.toLowerCase()
}
function dO(t) {
    return parseInt(t, 16)
}
function hO(t) {
    const e = new TextEncoder().encode(t);
    return "0x" + Array.from(e, n => n.toString(16).padStart(2, "0")).join("")
}
function fO(t) {
    var e;
    const {chainId: r, domain: n, expirationTime: s, issuedAt: i=new Date, nonce: o, notBefore: a, requestId: l, resources: c, scheme: u, uri: h, version: p} = t;
    {
        if (!Number.isInteger(r))
            throw new Error(`@supabase/auth-js: Invalid SIWE message field "chainId". Chain ID must be a EIP-155 chain ID. Provided value: ${r}`);
        if (!n)
            throw new Error('@supabase/auth-js: Invalid SIWE message field "domain". Domain must be provided.');
        if (o && o.length < 8)
            throw new Error(`@supabase/auth-js: Invalid SIWE message field "nonce". Nonce must be at least 8 characters. Provided value: ${o}`);
        if (!h)
            throw new Error('@supabase/auth-js: Invalid SIWE message field "uri". URI must be provided.');
        if (p !== "1")
            throw new Error(`@supabase/auth-js: Invalid SIWE message field "version". Version must be '1'. Provided value: ${p}`);
        if (!((e = t.statement) === null || e === void 0) && e.includes(`
`))
            throw new Error(`@supabase/auth-js: Invalid SIWE message field "statement". Statement must not include '\\n'. Provided value: ${t.statement}`)
    }
    const f = qb(t.address)
      , b = u ? `${u}://${n}` : n
      , m = t.statement ? `${t.statement}
` : ""
      , x = `${b} wants you to sign in with your Ethereum account:
${f}

${m}`;
    let w = `URI: ${h}
Version: ${p}
Chain ID: ${r}${o ? `
Nonce: ${o}` : ""}
Issued At: ${i.toISOString()}`;
    if (s && (w += `
Expiration Time: ${s.toISOString()}`),
    a && (w += `
Not Before: ${a.toISOString()}`),
    l && (w += `
Request ID: ${l}`),
    c) {
        let g = `
Resources:`;
        for (const v of c) {
            if (!v || typeof v != "string")
                throw new Error(`@supabase/auth-js: Invalid SIWE message field "resources". Every resource must be a valid string. Provided value: ${v}`);
            g += `
- ${v}`
        }
        w += g
    }
    return `${x}
${w}`
}
class Ke extends Error {
    constructor({message: e, code: r, cause: n, name: s}) {
        var i;
        super(e, {
            cause: n
        }),
        this.__isWebAuthnError = !0,
        this.name = (i = s ?? (n instanceof Error ? n.name : void 0)) !== null && i !== void 0 ? i : "Unknown Error",
        this.code = r
    }
}
class Ac extends Ke {
    constructor(e, r) {
        super({
            code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
            cause: r,
            message: e
        }),
        this.name = "WebAuthnUnknownError",
        this.originalError = r
    }
}
function pO({error: t, options: e}) {
    var r, n, s;
    const {publicKey: i} = e;
    if (!i)
        throw Error("options was missing required publicKey property");
    if (t.name === "AbortError") {
        if (e.signal instanceof AbortSignal)
            return new Ke({
                message: "Registration ceremony was sent an abort signal",
                code: "ERROR_CEREMONY_ABORTED",
                cause: t
            })
    } else if (t.name === "ConstraintError") {
        if (((r = i.authenticatorSelection) === null || r === void 0 ? void 0 : r.requireResidentKey) === !0)
            return new Ke({
                message: "Discoverable credentials were required but no available authenticator supported it",
                code: "ERROR_AUTHENTICATOR_MISSING_DISCOVERABLE_CREDENTIAL_SUPPORT",
                cause: t
            });
        if (e.mediation === "conditional" && ((n = i.authenticatorSelection) === null || n === void 0 ? void 0 : n.userVerification) === "required")
            return new Ke({
                message: "User verification was required during automatic registration but it could not be performed",
                code: "ERROR_AUTO_REGISTER_USER_VERIFICATION_FAILURE",
                cause: t
            });
        if (((s = i.authenticatorSelection) === null || s === void 0 ? void 0 : s.userVerification) === "required")
            return new Ke({
                message: "User verification was required but no available authenticator supported it",
                code: "ERROR_AUTHENTICATOR_MISSING_USER_VERIFICATION_SUPPORT",
                cause: t
            })
    } else {
        if (t.name === "InvalidStateError")
            return new Ke({
                message: "The authenticator was previously registered",
                code: "ERROR_AUTHENTICATOR_PREVIOUSLY_REGISTERED",
                cause: t
            });
        if (t.name === "NotAllowedError")
            return new Ke({
                message: t.message,
                code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
                cause: t
            });
        if (t.name === "NotSupportedError")
            return i.pubKeyCredParams.filter(a => a.type === "public-key").length === 0 ? new Ke({
                message: 'No entry in pubKeyCredParams was of type "public-key"',
                code: "ERROR_MALFORMED_PUBKEYCREDPARAMS",
                cause: t
            }) : new Ke({
                message: "No available authenticator supported any of the specified pubKeyCredParams algorithms",
                code: "ERROR_AUTHENTICATOR_NO_SUPPORTED_PUBKEYCREDPARAMS_ALG",
                cause: t
            });
        if (t.name === "SecurityError") {
            const o = window.location.hostname;
            if (Gb(o)) {
                if (i.rp.id !== o)
                    return new Ke({
                        message: `The RP ID "${i.rp.id}" is invalid for this domain`,
                        code: "ERROR_INVALID_RP_ID",
                        cause: t
                    })
            } else
                return new Ke({
                    message: `${window.location.hostname} is an invalid domain`,
                    code: "ERROR_INVALID_DOMAIN",
                    cause: t
                })
        } else if (t.name === "TypeError") {
            if (i.user.id.byteLength < 1 || i.user.id.byteLength > 64)
                return new Ke({
                    message: "User ID was not between 1 and 64 characters",
                    code: "ERROR_INVALID_USER_ID_LENGTH",
                    cause: t
                })
        } else if (t.name === "UnknownError")
            return new Ke({
                message: "The authenticator was unable to process the specified options, or could not create a new credential",
                code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
                cause: t
            })
    }
    return new Ke({
        message: "a Non-Webauthn related error has occurred",
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: t
    })
}
function mO({error: t, options: e}) {
    const {publicKey: r} = e;
    if (!r)
        throw Error("options was missing required publicKey property");
    if (t.name === "AbortError") {
        if (e.signal instanceof AbortSignal)
            return new Ke({
                message: "Authentication ceremony was sent an abort signal",
                code: "ERROR_CEREMONY_ABORTED",
                cause: t
            })
    } else {
        if (t.name === "NotAllowedError")
            return new Ke({
                message: t.message,
                code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
                cause: t
            });
        if (t.name === "SecurityError") {
            const n = window.location.hostname;
            if (Gb(n)) {
                if (r.rpId !== n)
                    return new Ke({
                        message: `The RP ID "${r.rpId}" is invalid for this domain`,
                        code: "ERROR_INVALID_RP_ID",
                        cause: t
                    })
            } else
                return new Ke({
                    message: `${window.location.hostname} is an invalid domain`,
                    code: "ERROR_INVALID_DOMAIN",
                    cause: t
                })
        } else if (t.name === "UnknownError")
            return new Ke({
                message: "The authenticator was unable to process the specified options, or could not create a new assertion signature",
                code: "ERROR_AUTHENTICATOR_GENERAL_ERROR",
                cause: t
            })
    }
    return new Ke({
        message: "a Non-Webauthn related error has occurred",
        code: "ERROR_PASSTHROUGH_SEE_CAUSE_PROPERTY",
        cause: t
    })
}
class gO {
    createNewAbortSignal() {
        if (this.controller) {
            const r = new Error("Cancelling existing WebAuthn API call for new one");
            r.name = "AbortError",
            this.controller.abort(r)
        }
        const e = new AbortController;
        return this.controller = e,
        e.signal
    }
    cancelCeremony() {
        if (this.controller) {
            const e = new Error("Manually cancelling existing WebAuthn API call");
            e.name = "AbortError",
            this.controller.abort(e),
            this.controller = void 0
        }
    }
}
const vO = new gO;
function yO(t) {
    if (!t)
        throw new Error("Credential creation options are required");
    if (typeof PublicKeyCredential < "u" && "parseCreationOptionsFromJSON"in PublicKeyCredential && typeof PublicKeyCredential.parseCreationOptionsFromJSON == "function")
        return PublicKeyCredential.parseCreationOptionsFromJSON(t);
    const {challenge: e, user: r, excludeCredentials: n} = t
      , s = wo(t, ["challenge", "user", "excludeCredentials"])
      , i = Ii(e).buffer
      , o = Object.assign(Object.assign({}, r), {
        id: Ii(r.id).buffer
    })
      , a = Object.assign(Object.assign({}, s), {
        challenge: i,
        user: o
    });
    if (n && n.length > 0) {
        a.excludeCredentials = new Array(n.length);
        for (let l = 0; l < n.length; l++) {
            const c = n[l];
            a.excludeCredentials[l] = Object.assign(Object.assign({}, c), {
                id: Ii(c.id).buffer,
                type: c.type || "public-key",
                transports: c.transports
            })
        }
    }
    return a
}
function wO(t) {
    if (!t)
        throw new Error("Credential request options are required");
    if (typeof PublicKeyCredential < "u" && "parseRequestOptionsFromJSON"in PublicKeyCredential && typeof PublicKeyCredential.parseRequestOptionsFromJSON == "function")
        return PublicKeyCredential.parseRequestOptionsFromJSON(t);
    const {challenge: e, allowCredentials: r} = t
      , n = wo(t, ["challenge", "allowCredentials"])
      , s = Ii(e).buffer
      , i = Object.assign(Object.assign({}, n), {
        challenge: s
    });
    if (r && r.length > 0) {
        i.allowCredentials = new Array(r.length);
        for (let o = 0; o < r.length; o++) {
            const a = r[o];
            i.allowCredentials[o] = Object.assign(Object.assign({}, a), {
                id: Ii(a.id).buffer,
                type: a.type || "public-key",
                transports: a.transports
            })
        }
    }
    return i
}
function xO(t) {
    var e;
    if ("toJSON"in t && typeof t.toJSON == "function")
        return t.toJSON();
    const r = t;
    return {
        id: t.id,
        rawId: t.id,
        response: {
            attestationObject: vs(new Uint8Array(t.response.attestationObject)),
            clientDataJSON: vs(new Uint8Array(t.response.clientDataJSON))
        },
        type: "public-key",
        clientExtensionResults: t.getClientExtensionResults(),
        authenticatorAttachment: (e = r.authenticatorAttachment) !== null && e !== void 0 ? e : void 0
    }
}
function bO(t) {
    var e;
    if ("toJSON"in t && typeof t.toJSON == "function")
        return t.toJSON();
    const r = t
      , n = t.getClientExtensionResults()
      , s = t.response;
    return {
        id: t.id,
        rawId: t.id,
        response: {
            authenticatorData: vs(new Uint8Array(s.authenticatorData)),
            clientDataJSON: vs(new Uint8Array(s.clientDataJSON)),
            signature: vs(new Uint8Array(s.signature)),
            userHandle: s.userHandle ? vs(new Uint8Array(s.userHandle)) : void 0
        },
        type: "public-key",
        clientExtensionResults: n,
        authenticatorAttachment: (e = r.authenticatorAttachment) !== null && e !== void 0 ? e : void 0
    }
}
function Gb(t) {
    return t === "localhost" || /^([a-z0-9]+(-[a-z0-9]+)*\.)+[a-z]{2,}$/i.test(t)
}
function yv() {
    var t, e;
    return !!(rt() && "PublicKeyCredential"in window && window.PublicKeyCredential && "credentials"in navigator && typeof ((t = navigator == null ? void 0 : navigator.credentials) === null || t === void 0 ? void 0 : t.create) == "function" && typeof ((e = navigator == null ? void 0 : navigator.credentials) === null || e === void 0 ? void 0 : e.get) == "function")
}
async function _O(t) {
    try {
        const e = await navigator.credentials.create(t);
        return e ? e instanceof PublicKeyCredential ? {
            data: e,
            error: null
        } : {
            data: null,
            error: new Ac("Browser returned unexpected credential type",e)
        } : {
            data: null,
            error: new Ac("Empty credential response",e)
        }
    } catch (e) {
        return {
            data: null,
            error: pO({
                error: e,
                options: t
            })
        }
    }
}
async function SO(t) {
    try {
        const e = await navigator.credentials.get(t);
        return e ? e instanceof PublicKeyCredential ? {
            data: e,
            error: null
        } : {
            data: null,
            error: new Ac("Browser returned unexpected credential type",e)
        } : {
            data: null,
            error: new Ac("Empty credential response",e)
        }
    } catch (e) {
        return {
            data: null,
            error: mO({
                error: e,
                options: t
            })
        }
    }
}
const kO = {
    hints: ["security-key"],
    authenticatorSelection: {
        authenticatorAttachment: "cross-platform",
        requireResidentKey: !1,
        userVerification: "preferred",
        residentKey: "discouraged"
    },
    attestation: "direct"
}
  , EO = {
    userVerification: "preferred",
    hints: ["security-key"],
    attestation: "direct"
};
function jc(...t) {
    const e = s => s !== null && typeof s == "object" && !Array.isArray(s)
      , r = s => s instanceof ArrayBuffer || ArrayBuffer.isView(s)
      , n = {};
    for (const s of t)
        if (s)
            for (const i in s) {
                const o = s[i];
                if (o !== void 0)
                    if (Array.isArray(o))
                        n[i] = o;
                    else if (r(o))
                        n[i] = o;
                    else if (e(o)) {
                        const a = n[i];
                        e(a) ? n[i] = jc(a, o) : n[i] = jc(o)
                    } else
                        n[i] = o
            }
    return n
}
function CO(t, e) {
    return jc(kO, t, e || {})
}
function TO(t, e) {
    return jc(EO, t, e || {})
}
class RO {
    constructor(e) {
        this.client = e,
        this.enroll = this._enroll.bind(this),
        this.challenge = this._challenge.bind(this),
        this.verify = this._verify.bind(this),
        this.authenticate = this._authenticate.bind(this),
        this.register = this._register.bind(this)
    }
    async _enroll(e) {
        return this.client.mfa.enroll(Object.assign(Object.assign({}, e), {
            factorType: "webauthn"
        }))
    }
    async _challenge({factorId: e, webauthn: r, friendlyName: n, signal: s}, i) {
        try {
            const {data: o, error: a} = await this.client.mfa.challenge({
                factorId: e,
                webauthn: r
            });
            if (!o)
                return {
                    data: null,
                    error: a
                };
            const l = s ?? vO.createNewAbortSignal();
            if (o.webauthn.type === "create") {
                const {user: c} = o.webauthn.credential_options.publicKey;
                c.name || (c.name = `${c.id}:${n}`),
                c.displayName || (c.displayName = c.name)
            }
            switch (o.webauthn.type) {
            case "create":
                {
                    const c = CO(o.webauthn.credential_options.publicKey, i == null ? void 0 : i.create)
                      , {data: u, error: h} = await _O({
                        publicKey: c,
                        signal: l
                    });
                    return u ? {
                        data: {
                            factorId: e,
                            challengeId: o.id,
                            webauthn: {
                                type: o.webauthn.type,
                                credential_response: u
                            }
                        },
                        error: null
                    } : {
                        data: null,
                        error: h
                    }
                }
            case "request":
                {
                    const c = TO(o.webauthn.credential_options.publicKey, i == null ? void 0 : i.request)
                      , {data: u, error: h} = await SO(Object.assign(Object.assign({}, o.webauthn.credential_options), {
                        publicKey: c,
                        signal: l
                    }));
                    return u ? {
                        data: {
                            factorId: e,
                            challengeId: o.id,
                            webauthn: {
                                type: o.webauthn.type,
                                credential_response: u
                            }
                        },
                        error: null
                    } : {
                        data: null,
                        error: h
                    }
                }
            }
        } catch (o) {
            return K(o) ? {
                data: null,
                error: o
            } : {
                data: null,
                error: new fs("Unexpected error in challenge",o)
            }
        }
    }
    async _verify({challengeId: e, factorId: r, webauthn: n}) {
        return this.client.mfa.verify({
            factorId: r,
            challengeId: e,
            webauthn: n
        })
    }
    async _authenticate({factorId: e, webauthn: {rpId: r=typeof window < "u" ? window.location.hostname : void 0, rpOrigins: n=typeof window < "u" ? [window.location.origin] : void 0, signal: s}={}}, i) {
        if (!r)
            return {
                data: null,
                error: new Ta("rpId is required for WebAuthn authentication")
            };
        try {
            if (!yv())
                return {
                    data: null,
                    error: new fs("Browser does not support WebAuthn",null)
                };
            const {data: o, error: a} = await this.challenge({
                factorId: e,
                webauthn: {
                    rpId: r,
                    rpOrigins: n
                },
                signal: s
            }, {
                request: i
            });
            if (!o)
                return {
                    data: null,
                    error: a
                };
            const {webauthn: l} = o;
            return this._verify({
                factorId: e,
                challengeId: o.challengeId,
                webauthn: {
                    type: l.type,
                    rpId: r,
                    rpOrigins: n,
                    credential_response: l.credential_response
                }
            })
        } catch (o) {
            return K(o) ? {
                data: null,
                error: o
            } : {
                data: null,
                error: new fs("Unexpected error in authenticate",o)
            }
        }
    }
    async _register({friendlyName: e, webauthn: {rpId: r=typeof window < "u" ? window.location.hostname : void 0, rpOrigins: n=typeof window < "u" ? [window.location.origin] : void 0, signal: s}={}}, i) {
        if (!r)
            return {
                data: null,
                error: new Ta("rpId is required for WebAuthn registration")
            };
        try {
            if (!yv())
                return {
                    data: null,
                    error: new fs("Browser does not support WebAuthn",null)
                };
            const {data: o, error: a} = await this._enroll({
                friendlyName: e
            });
            if (!o)
                return await this.client.mfa.listFactors().then(u => {
                    var h;
                    return (h = u.data) === null || h === void 0 ? void 0 : h.all.find(p => p.factor_type === "webauthn" && p.friendly_name === e && p.status !== "unverified")
                }
                ).then(u => u ? this.client.mfa.unenroll({
                    factorId: u == null ? void 0 : u.id
                }) : void 0),
                {
                    data: null,
                    error: a
                };
            const {data: l, error: c} = await this._challenge({
                factorId: o.id,
                friendlyName: o.friendly_name,
                webauthn: {
                    rpId: r,
                    rpOrigins: n
                },
                signal: s
            }, {
                create: i
            });
            return l ? this._verify({
                factorId: o.id,
                challengeId: l.challengeId,
                webauthn: {
                    rpId: r,
                    rpOrigins: n,
                    type: l.webauthn.type,
                    credential_response: l.webauthn.credential_response
                }
            }) : {
                data: null,
                error: c
            }
        } catch (o) {
            return K(o) ? {
                data: null,
                error: o
            } : {
                data: null,
                error: new fs("Unexpected error in register",o)
            }
        }
    }
}
uO();
const NO = {
    url: kj,
    storageKey: Ej,
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    headers: Cj,
    flowType: "implicit",
    debug: !1,
    hasCustomAuthorizationHeader: !1,
    throwOnError: !1,
    lockAcquireTimeout: 1e4
};
async function wv(t, e, r) {
    return await r()
}
const ti = {};
class Ra {
    get jwks() {
        var e, r;
        return (r = (e = ti[this.storageKey]) === null || e === void 0 ? void 0 : e.jwks) !== null && r !== void 0 ? r : {
            keys: []
        }
    }
    set jwks(e) {
        ti[this.storageKey] = Object.assign(Object.assign({}, ti[this.storageKey]), {
            jwks: e
        })
    }
    get jwks_cached_at() {
        var e, r;
        return (r = (e = ti[this.storageKey]) === null || e === void 0 ? void 0 : e.cachedAt) !== null && r !== void 0 ? r : Number.MIN_SAFE_INTEGER
    }
    set jwks_cached_at(e) {
        ti[this.storageKey] = Object.assign(Object.assign({}, ti[this.storageKey]), {
            cachedAt: e
        })
    }
    constructor(e) {
        var r, n, s;
        this.userStorage = null,
        this.memoryStorage = null,
        this.stateChangeEmitters = new Map,
        this.autoRefreshTicker = null,
        this.autoRefreshTickTimeout = null,
        this.visibilityChangedCallback = null,
        this.refreshingDeferred = null,
        this.initializePromise = null,
        this.detectSessionInUrl = !0,
        this.hasCustomAuthorizationHeader = !1,
        this.suppressGetSessionWarning = !1,
        this.lockAcquired = !1,
        this.pendingInLock = [],
        this.broadcastChannel = null,
        this.logger = console.log;
        const i = Object.assign(Object.assign({}, NO), e);
        if (this.storageKey = i.storageKey,
        this.instanceID = (r = Ra.nextInstanceID[this.storageKey]) !== null && r !== void 0 ? r : 0,
        Ra.nextInstanceID[this.storageKey] = this.instanceID + 1,
        this.logDebugMessages = !!i.debug,
        typeof i.debug == "function" && (this.logger = i.debug),
        this.instanceID > 0 && rt()) {
            const o = `${this._logPrefix()} Multiple GoTrueClient instances detected in the same browser context. It is not an error, but this should be avoided as it may produce undefined behavior when used concurrently under the same storage key.`;
            console.warn(o),
            this.logDebugMessages && console.trace(o)
        }
        if (this.persistSession = i.persistSession,
        this.autoRefreshToken = i.autoRefreshToken,
        this.admin = new aO({
            url: i.url,
            headers: i.headers,
            fetch: i.fetch
        }),
        this.url = i.url,
        this.headers = i.headers,
        this.fetch = Hb(i.fetch),
        this.lock = i.lock || wv,
        this.detectSessionInUrl = i.detectSessionInUrl,
        this.flowType = i.flowType,
        this.hasCustomAuthorizationHeader = i.hasCustomAuthorizationHeader,
        this.throwOnError = i.throwOnError,
        this.lockAcquireTimeout = i.lockAcquireTimeout,
        i.lock ? this.lock = i.lock : this.persistSession && rt() && (!((n = globalThis == null ? void 0 : globalThis.navigator) === null || n === void 0) && n.locks) ? this.lock = cO : this.lock = wv,
        this.jwks || (this.jwks = {
            keys: []
        },
        this.jwks_cached_at = Number.MIN_SAFE_INTEGER),
        this.mfa = {
            verify: this._verify.bind(this),
            enroll: this._enroll.bind(this),
            unenroll: this._unenroll.bind(this),
            challenge: this._challenge.bind(this),
            listFactors: this._listFactors.bind(this),
            challengeAndVerify: this._challengeAndVerify.bind(this),
            getAuthenticatorAssuranceLevel: this._getAuthenticatorAssuranceLevel.bind(this),
            webauthn: new RO(this)
        },
        this.oauth = {
            getAuthorizationDetails: this._getAuthorizationDetails.bind(this),
            approveAuthorization: this._approveAuthorization.bind(this),
            denyAuthorization: this._denyAuthorization.bind(this),
            listGrants: this._listOAuthGrants.bind(this),
            revokeGrant: this._revokeOAuthGrant.bind(this)
        },
        this.persistSession ? (i.storage ? this.storage = i.storage : Wb() ? this.storage = globalThis.localStorage : (this.memoryStorage = {},
        this.storage = vv(this.memoryStorage)),
        i.userStorage && (this.userStorage = i.userStorage)) : (this.memoryStorage = {},
        this.storage = vv(this.memoryStorage)),
        rt() && globalThis.BroadcastChannel && this.persistSession && this.storageKey) {
            try {
                this.broadcastChannel = new globalThis.BroadcastChannel(this.storageKey)
            } catch (o) {
                console.error("Failed to create a new BroadcastChannel, multi-tab state changes will not be available", o)
            }
            (s = this.broadcastChannel) === null || s === void 0 || s.addEventListener("message", async o => {
                this._debug("received broadcast notification from other tab or client", o),
                await this._notifyAllSubscribers(o.data.event, o.data.session, !1)
            }
            )
        }
        this.initialize()
    }
    isThrowOnErrorEnabled() {
        return this.throwOnError
    }
    _returnResult(e) {
        if (this.throwOnError && e && e.error)
            throw e.error;
        return e
    }
    _logPrefix() {
        return `GoTrueClient@${this.storageKey}:${this.instanceID} (${Bb}) ${new Date().toISOString()}`
    }
    _debug(...e) {
        return this.logDebugMessages && this.logger(this._logPrefix(), ...e),
        this
    }
    async initialize() {
        return this.initializePromise ? await this.initializePromise : (this.initializePromise = (async () => await this._acquireLock(this.lockAcquireTimeout, async () => await this._initialize()))(),
        await this.initializePromise)
    }
    async _initialize() {
        var e;
        try {
            let r = {}
              , n = "none";
            if (rt() && (r = Bj(window.location.href),
            this._isImplicitGrantCallback(r) ? n = "implicit" : await this._isPKCECallback(r) && (n = "pkce")),
            rt() && this.detectSessionInUrl && n !== "none") {
                const {data: s, error: i} = await this._getSessionFromURL(r, n);
                if (i) {
                    if (this._debug("#_initialize()", "error detecting session from URL", i),
                    jj(i)) {
                        const l = (e = i.details) === null || e === void 0 ? void 0 : e.code;
                        if (l === "identity_already_exists" || l === "identity_not_found" || l === "single_identity_not_deletable")
                            return {
                                error: i
                            }
                    }
                    return {
                        error: i
                    }
                }
                const {session: o, redirectType: a} = s;
                return this._debug("#_initialize()", "detected session in URL", o, "redirect type", a),
                await this._saveSession(o),
                setTimeout(async () => {
                    a === "recovery" ? await this._notifyAllSubscribers("PASSWORD_RECOVERY", o) : await this._notifyAllSubscribers("SIGNED_IN", o)
                }
                , 0),
                {
                    error: null
                }
            }
            return await this._recoverAndRefresh(),
            {
                error: null
            }
        } catch (r) {
            return K(r) ? this._returnResult({
                error: r
            }) : this._returnResult({
                error: new fs("Unexpected error during initialization",r)
            })
        } finally {
            await this._handleVisibilityChange(),
            this._debug("#_initialize()", "end")
        }
    }
    async signInAnonymously(e) {
        var r, n, s;
        try {
            const i = await J(this.fetch, "POST", `${this.url}/signup`, {
                headers: this.headers,
                body: {
                    data: (n = (r = e == null ? void 0 : e.options) === null || r === void 0 ? void 0 : r.data) !== null && n !== void 0 ? n : {},
                    gotrue_meta_security: {
                        captcha_token: (s = e == null ? void 0 : e.options) === null || s === void 0 ? void 0 : s.captchaToken
                    }
                },
                xform: lr
            })
              , {data: o, error: a} = i;
            if (a || !o)
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                });
            const l = o.session
              , c = o.user;
            return o.session && (await this._saveSession(o.session),
            await this._notifyAllSubscribers("SIGNED_IN", l)),
            this._returnResult({
                data: {
                    user: c,
                    session: l
                },
                error: null
            })
        } catch (i) {
            if (K(i))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                });
            throw i
        }
    }
    async signUp(e) {
        var r, n, s;
        try {
            let i;
            if ("email"in e) {
                const {email: u, password: h, options: p} = e;
                let f = null
                  , b = null;
                this.flowType === "pkce" && ([f,b] = await Ys(this.storage, this.storageKey)),
                i = await J(this.fetch, "POST", `${this.url}/signup`, {
                    headers: this.headers,
                    redirectTo: p == null ? void 0 : p.emailRedirectTo,
                    body: {
                        email: u,
                        password: h,
                        data: (r = p == null ? void 0 : p.data) !== null && r !== void 0 ? r : {},
                        gotrue_meta_security: {
                            captcha_token: p == null ? void 0 : p.captchaToken
                        },
                        code_challenge: f,
                        code_challenge_method: b
                    },
                    xform: lr
                })
            } else if ("phone"in e) {
                const {phone: u, password: h, options: p} = e;
                i = await J(this.fetch, "POST", `${this.url}/signup`, {
                    headers: this.headers,
                    body: {
                        phone: u,
                        password: h,
                        data: (n = p == null ? void 0 : p.data) !== null && n !== void 0 ? n : {},
                        channel: (s = p == null ? void 0 : p.channel) !== null && s !== void 0 ? s : "sms",
                        gotrue_meta_security: {
                            captcha_token: p == null ? void 0 : p.captchaToken
                        }
                    },
                    xform: lr
                })
            } else
                throw new Sl("You must provide either an email or phone number and a password");
            const {data: o, error: a} = i;
            if (a || !o)
                return await tt(this.storage, `${this.storageKey}-code-verifier`),
                this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                });
            const l = o.session
              , c = o.user;
            return o.session && (await this._saveSession(o.session),
            await this._notifyAllSubscribers("SIGNED_IN", l)),
            this._returnResult({
                data: {
                    user: c,
                    session: l
                },
                error: null
            })
        } catch (i) {
            if (await tt(this.storage, `${this.storageKey}-code-verifier`),
            K(i))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                });
            throw i
        }
    }
    async signInWithPassword(e) {
        try {
            let r;
            if ("email"in e) {
                const {email: i, password: o, options: a} = e;
                r = await J(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
                    headers: this.headers,
                    body: {
                        email: i,
                        password: o,
                        gotrue_meta_security: {
                            captcha_token: a == null ? void 0 : a.captchaToken
                        }
                    },
                    xform: mv
                })
            } else if ("phone"in e) {
                const {phone: i, password: o, options: a} = e;
                r = await J(this.fetch, "POST", `${this.url}/token?grant_type=password`, {
                    headers: this.headers,
                    body: {
                        phone: i,
                        password: o,
                        gotrue_meta_security: {
                            captcha_token: a == null ? void 0 : a.captchaToken
                        }
                    },
                    xform: mv
                })
            } else
                throw new Sl("You must provide either an email or phone number and a password");
            const {data: n, error: s} = r;
            if (s)
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                });
            if (!n || !n.session || !n.user) {
                const i = new Zs;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                })
            }
            return n.session && (await this._saveSession(n.session),
            await this._notifyAllSubscribers("SIGNED_IN", n.session)),
            this._returnResult({
                data: Object.assign({
                    user: n.user,
                    session: n.session
                }, n.weak_password ? {
                    weakPassword: n.weak_password
                } : null),
                error: s
            })
        } catch (r) {
            if (K(r))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                });
            throw r
        }
    }
    async signInWithOAuth(e) {
        var r, n, s, i;
        return await this._handleProviderSignIn(e.provider, {
            redirectTo: (r = e.options) === null || r === void 0 ? void 0 : r.redirectTo,
            scopes: (n = e.options) === null || n === void 0 ? void 0 : n.scopes,
            queryParams: (s = e.options) === null || s === void 0 ? void 0 : s.queryParams,
            skipBrowserRedirect: (i = e.options) === null || i === void 0 ? void 0 : i.skipBrowserRedirect
        })
    }
    async exchangeCodeForSession(e) {
        return await this.initializePromise,
        this._acquireLock(this.lockAcquireTimeout, async () => this._exchangeCodeForSession(e))
    }
    async signInWithWeb3(e) {
        const {chain: r} = e;
        switch (r) {
        case "ethereum":
            return await this.signInWithEthereum(e);
        case "solana":
            return await this.signInWithSolana(e);
        default:
            throw new Error(`@supabase/auth-js: Unsupported chain "${r}"`)
        }
    }
    async signInWithEthereum(e) {
        var r, n, s, i, o, a, l, c, u, h, p;
        let f, b;
        if ("message"in e)
            f = e.message,
            b = e.signature;
        else {
            const {chain: m, wallet: x, statement: w, options: g} = e;
            let v;
            if (rt())
                if (typeof x == "object")
                    v = x;
                else {
                    const A = window;
                    if ("ethereum"in A && typeof A.ethereum == "object" && "request"in A.ethereum && typeof A.ethereum.request == "function")
                        v = A.ethereum;
                    else
                        throw new Error("@supabase/auth-js: No compatible Ethereum wallet interface on the window object (window.ethereum) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'ethereum', wallet: resolvedUserWallet }) instead.")
                }
            else {
                if (typeof x != "object" || !(g != null && g.url))
                    throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
                v = x
            }
            const _ = new URL((r = g == null ? void 0 : g.url) !== null && r !== void 0 ? r : window.location.href)
              , S = await v.request({
                method: "eth_requestAccounts"
            }).then(A => A).catch( () => {
                throw new Error("@supabase/auth-js: Wallet method eth_requestAccounts is missing or invalid")
            }
            );
            if (!S || S.length === 0)
                throw new Error("@supabase/auth-js: No accounts available. Please ensure the wallet is connected.");
            const k = qb(S[0]);
            let C = (n = g == null ? void 0 : g.signInWithEthereum) === null || n === void 0 ? void 0 : n.chainId;
            if (!C) {
                const A = await v.request({
                    method: "eth_chainId"
                });
                C = dO(A)
            }
            const T = {
                domain: _.host,
                address: k,
                statement: w,
                uri: _.href,
                version: "1",
                chainId: C,
                nonce: (s = g == null ? void 0 : g.signInWithEthereum) === null || s === void 0 ? void 0 : s.nonce,
                issuedAt: (o = (i = g == null ? void 0 : g.signInWithEthereum) === null || i === void 0 ? void 0 : i.issuedAt) !== null && o !== void 0 ? o : new Date,
                expirationTime: (a = g == null ? void 0 : g.signInWithEthereum) === null || a === void 0 ? void 0 : a.expirationTime,
                notBefore: (l = g == null ? void 0 : g.signInWithEthereum) === null || l === void 0 ? void 0 : l.notBefore,
                requestId: (c = g == null ? void 0 : g.signInWithEthereum) === null || c === void 0 ? void 0 : c.requestId,
                resources: (u = g == null ? void 0 : g.signInWithEthereum) === null || u === void 0 ? void 0 : u.resources
            };
            f = fO(T),
            b = await v.request({
                method: "personal_sign",
                params: [hO(f), k]
            })
        }
        try {
            const {data: m, error: x} = await J(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
                headers: this.headers,
                body: Object.assign({
                    chain: "ethereum",
                    message: f,
                    signature: b
                }, !((h = e.options) === null || h === void 0) && h.captchaToken ? {
                    gotrue_meta_security: {
                        captcha_token: (p = e.options) === null || p === void 0 ? void 0 : p.captchaToken
                    }
                } : null),
                xform: lr
            });
            if (x)
                throw x;
            if (!m || !m.session || !m.user) {
                const w = new Zs;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: w
                })
            }
            return m.session && (await this._saveSession(m.session),
            await this._notifyAllSubscribers("SIGNED_IN", m.session)),
            this._returnResult({
                data: Object.assign({}, m),
                error: x
            })
        } catch (m) {
            if (K(m))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: m
                });
            throw m
        }
    }
    async signInWithSolana(e) {
        var r, n, s, i, o, a, l, c, u, h, p, f;
        let b, m;
        if ("message"in e)
            b = e.message,
            m = e.signature;
        else {
            const {chain: x, wallet: w, statement: g, options: v} = e;
            let _;
            if (rt())
                if (typeof w == "object")
                    _ = w;
                else {
                    const k = window;
                    if ("solana"in k && typeof k.solana == "object" && ("signIn"in k.solana && typeof k.solana.signIn == "function" || "signMessage"in k.solana && typeof k.solana.signMessage == "function"))
                        _ = k.solana;
                    else
                        throw new Error("@supabase/auth-js: No compatible Solana wallet interface on the window object (window.solana) detected. Make sure the user already has a wallet installed and connected for this app. Prefer passing the wallet interface object directly to signInWithWeb3({ chain: 'solana', wallet: resolvedUserWallet }) instead.")
                }
            else {
                if (typeof w != "object" || !(v != null && v.url))
                    throw new Error("@supabase/auth-js: Both wallet and url must be specified in non-browser environments.");
                _ = w
            }
            const S = new URL((r = v == null ? void 0 : v.url) !== null && r !== void 0 ? r : window.location.href);
            if ("signIn"in _ && _.signIn) {
                const k = await _.signIn(Object.assign(Object.assign(Object.assign({
                    issuedAt: new Date().toISOString()
                }, v == null ? void 0 : v.signInWithSolana), {
                    version: "1",
                    domain: S.host,
                    uri: S.href
                }), g ? {
                    statement: g
                } : null));
                let C;
                if (Array.isArray(k) && k[0] && typeof k[0] == "object")
                    C = k[0];
                else if (k && typeof k == "object" && "signedMessage"in k && "signature"in k)
                    C = k;
                else
                    throw new Error("@supabase/auth-js: Wallet method signIn() returned unrecognized value");
                if ("signedMessage"in C && "signature"in C && (typeof C.signedMessage == "string" || C.signedMessage instanceof Uint8Array) && C.signature instanceof Uint8Array)
                    b = typeof C.signedMessage == "string" ? C.signedMessage : new TextDecoder().decode(C.signedMessage),
                    m = C.signature;
                else
                    throw new Error("@supabase/auth-js: Wallet method signIn() API returned object without signedMessage and signature fields")
            } else {
                if (!("signMessage"in _) || typeof _.signMessage != "function" || !("publicKey"in _) || typeof _ != "object" || !_.publicKey || !("toBase58"in _.publicKey) || typeof _.publicKey.toBase58 != "function")
                    throw new Error("@supabase/auth-js: Wallet does not have a compatible signMessage() and publicKey.toBase58() API");
                b = [`${S.host} wants you to sign in with your Solana account:`, _.publicKey.toBase58(), ...g ? ["", g, ""] : [""], "Version: 1", `URI: ${S.href}`, `Issued At: ${(s = (n = v == null ? void 0 : v.signInWithSolana) === null || n === void 0 ? void 0 : n.issuedAt) !== null && s !== void 0 ? s : new Date().toISOString()}`, ...!((i = v == null ? void 0 : v.signInWithSolana) === null || i === void 0) && i.notBefore ? [`Not Before: ${v.signInWithSolana.notBefore}`] : [], ...!((o = v == null ? void 0 : v.signInWithSolana) === null || o === void 0) && o.expirationTime ? [`Expiration Time: ${v.signInWithSolana.expirationTime}`] : [], ...!((a = v == null ? void 0 : v.signInWithSolana) === null || a === void 0) && a.chainId ? [`Chain ID: ${v.signInWithSolana.chainId}`] : [], ...!((l = v == null ? void 0 : v.signInWithSolana) === null || l === void 0) && l.nonce ? [`Nonce: ${v.signInWithSolana.nonce}`] : [], ...!((c = v == null ? void 0 : v.signInWithSolana) === null || c === void 0) && c.requestId ? [`Request ID: ${v.signInWithSolana.requestId}`] : [], ...!((h = (u = v == null ? void 0 : v.signInWithSolana) === null || u === void 0 ? void 0 : u.resources) === null || h === void 0) && h.length ? ["Resources", ...v.signInWithSolana.resources.map(C => `- ${C}`)] : []].join(`
`);
                const k = await _.signMessage(new TextEncoder().encode(b), "utf8");
                if (!k || !(k instanceof Uint8Array))
                    throw new Error("@supabase/auth-js: Wallet signMessage() API returned an recognized value");
                m = k
            }
        }
        try {
            const {data: x, error: w} = await J(this.fetch, "POST", `${this.url}/token?grant_type=web3`, {
                headers: this.headers,
                body: Object.assign({
                    chain: "solana",
                    message: b,
                    signature: vs(m)
                }, !((p = e.options) === null || p === void 0) && p.captchaToken ? {
                    gotrue_meta_security: {
                        captcha_token: (f = e.options) === null || f === void 0 ? void 0 : f.captchaToken
                    }
                } : null),
                xform: lr
            });
            if (w)
                throw w;
            if (!x || !x.session || !x.user) {
                const g = new Zs;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: g
                })
            }
            return x.session && (await this._saveSession(x.session),
            await this._notifyAllSubscribers("SIGNED_IN", x.session)),
            this._returnResult({
                data: Object.assign({}, x),
                error: w
            })
        } catch (x) {
            if (K(x))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: x
                });
            throw x
        }
    }
    async _exchangeCodeForSession(e) {
        const r = await ls(this.storage, `${this.storageKey}-code-verifier`)
          , [n,s] = (r ?? "").split("/");
        try {
            if (!n && this.flowType === "pkce")
                throw new Oj;
            const {data: i, error: o} = await J(this.fetch, "POST", `${this.url}/token?grant_type=pkce`, {
                headers: this.headers,
                body: {
                    auth_code: e,
                    code_verifier: n
                },
                xform: lr
            });
            if (await tt(this.storage, `${this.storageKey}-code-verifier`),
            o)
                throw o;
            if (!i || !i.session || !i.user) {
                const a = new Zs;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null,
                        redirectType: null
                    },
                    error: a
                })
            }
            return i.session && (await this._saveSession(i.session),
            await this._notifyAllSubscribers("SIGNED_IN", i.session)),
            this._returnResult({
                data: Object.assign(Object.assign({}, i), {
                    redirectType: s ?? null
                }),
                error: o
            })
        } catch (i) {
            if (await tt(this.storage, `${this.storageKey}-code-verifier`),
            K(i))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null,
                        redirectType: null
                    },
                    error: i
                });
            throw i
        }
    }
    async signInWithIdToken(e) {
        try {
            const {options: r, provider: n, token: s, access_token: i, nonce: o} = e
              , a = await J(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
                headers: this.headers,
                body: {
                    provider: n,
                    id_token: s,
                    access_token: i,
                    nonce: o,
                    gotrue_meta_security: {
                        captcha_token: r == null ? void 0 : r.captchaToken
                    }
                },
                xform: lr
            })
              , {data: l, error: c} = a;
            if (c)
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: c
                });
            if (!l || !l.session || !l.user) {
                const u = new Zs;
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: u
                })
            }
            return l.session && (await this._saveSession(l.session),
            await this._notifyAllSubscribers("SIGNED_IN", l.session)),
            this._returnResult({
                data: l,
                error: c
            })
        } catch (r) {
            if (K(r))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                });
            throw r
        }
    }
    async signInWithOtp(e) {
        var r, n, s, i, o;
        try {
            if ("email"in e) {
                const {email: a, options: l} = e;
                let c = null
                  , u = null;
                this.flowType === "pkce" && ([c,u] = await Ys(this.storage, this.storageKey));
                const {error: h} = await J(this.fetch, "POST", `${this.url}/otp`, {
                    headers: this.headers,
                    body: {
                        email: a,
                        data: (r = l == null ? void 0 : l.data) !== null && r !== void 0 ? r : {},
                        create_user: (n = l == null ? void 0 : l.shouldCreateUser) !== null && n !== void 0 ? n : !0,
                        gotrue_meta_security: {
                            captcha_token: l == null ? void 0 : l.captchaToken
                        },
                        code_challenge: c,
                        code_challenge_method: u
                    },
                    redirectTo: l == null ? void 0 : l.emailRedirectTo
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: h
                })
            }
            if ("phone"in e) {
                const {phone: a, options: l} = e
                  , {data: c, error: u} = await J(this.fetch, "POST", `${this.url}/otp`, {
                    headers: this.headers,
                    body: {
                        phone: a,
                        data: (s = l == null ? void 0 : l.data) !== null && s !== void 0 ? s : {},
                        create_user: (i = l == null ? void 0 : l.shouldCreateUser) !== null && i !== void 0 ? i : !0,
                        gotrue_meta_security: {
                            captcha_token: l == null ? void 0 : l.captchaToken
                        },
                        channel: (o = l == null ? void 0 : l.channel) !== null && o !== void 0 ? o : "sms"
                    }
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null,
                        messageId: c == null ? void 0 : c.message_id
                    },
                    error: u
                })
            }
            throw new Sl("You must provide either an email or phone number.")
        } catch (a) {
            if (await tt(this.storage, `${this.storageKey}-code-verifier`),
            K(a))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: a
                });
            throw a
        }
    }
    async verifyOtp(e) {
        var r, n;
        try {
            let s, i;
            "options"in e && (s = (r = e.options) === null || r === void 0 ? void 0 : r.redirectTo,
            i = (n = e.options) === null || n === void 0 ? void 0 : n.captchaToken);
            const {data: o, error: a} = await J(this.fetch, "POST", `${this.url}/verify`, {
                headers: this.headers,
                body: Object.assign(Object.assign({}, e), {
                    gotrue_meta_security: {
                        captcha_token: i
                    }
                }),
                redirectTo: s,
                xform: lr
            });
            if (a)
                throw a;
            if (!o)
                throw new Error("An error occurred on token verification.");
            const l = o.session
              , c = o.user;
            return l != null && l.access_token && (await this._saveSession(l),
            await this._notifyAllSubscribers(e.type == "recovery" ? "PASSWORD_RECOVERY" : "SIGNED_IN", l)),
            this._returnResult({
                data: {
                    user: c,
                    session: l
                },
                error: null
            })
        } catch (s) {
            if (K(s))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                });
            throw s
        }
    }
    async signInWithSSO(e) {
        var r, n, s, i, o;
        try {
            let a = null
              , l = null;
            this.flowType === "pkce" && ([a,l] = await Ys(this.storage, this.storageKey));
            const c = await J(this.fetch, "POST", `${this.url}/sso`, {
                body: Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, "providerId"in e ? {
                    provider_id: e.providerId
                } : null), "domain"in e ? {
                    domain: e.domain
                } : null), {
                    redirect_to: (n = (r = e.options) === null || r === void 0 ? void 0 : r.redirectTo) !== null && n !== void 0 ? n : void 0
                }), !((s = e == null ? void 0 : e.options) === null || s === void 0) && s.captchaToken ? {
                    gotrue_meta_security: {
                        captcha_token: e.options.captchaToken
                    }
                } : null), {
                    skip_http_redirect: !0,
                    code_challenge: a,
                    code_challenge_method: l
                }),
                headers: this.headers,
                xform: sO
            });
            return !((i = c.data) === null || i === void 0) && i.url && rt() && !(!((o = e.options) === null || o === void 0) && o.skipBrowserRedirect) && window.location.assign(c.data.url),
            this._returnResult(c)
        } catch (a) {
            if (await tt(this.storage, `${this.storageKey}-code-verifier`),
            K(a))
                return this._returnResult({
                    data: null,
                    error: a
                });
            throw a
        }
    }
    async reauthenticate() {
        return await this.initializePromise,
        await this._acquireLock(this.lockAcquireTimeout, async () => await this._reauthenticate())
    }
    async _reauthenticate() {
        try {
            return await this._useSession(async e => {
                const {data: {session: r}, error: n} = e;
                if (n)
                    throw n;
                if (!r)
                    throw new Nt;
                const {error: s} = await J(this.fetch, "GET", `${this.url}/reauthenticate`, {
                    headers: this.headers,
                    jwt: r.access_token
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: s
                })
            }
            )
        } catch (e) {
            if (K(e))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: e
                });
            throw e
        }
    }
    async resend(e) {
        try {
            const r = `${this.url}/resend`;
            if ("email"in e) {
                const {email: n, type: s, options: i} = e
                  , {error: o} = await J(this.fetch, "POST", r, {
                    headers: this.headers,
                    body: {
                        email: n,
                        type: s,
                        gotrue_meta_security: {
                            captcha_token: i == null ? void 0 : i.captchaToken
                        }
                    },
                    redirectTo: i == null ? void 0 : i.emailRedirectTo
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: o
                })
            } else if ("phone"in e) {
                const {phone: n, type: s, options: i} = e
                  , {data: o, error: a} = await J(this.fetch, "POST", r, {
                    headers: this.headers,
                    body: {
                        phone: n,
                        type: s,
                        gotrue_meta_security: {
                            captcha_token: i == null ? void 0 : i.captchaToken
                        }
                    }
                });
                return this._returnResult({
                    data: {
                        user: null,
                        session: null,
                        messageId: o == null ? void 0 : o.message_id
                    },
                    error: a
                })
            }
            throw new Sl("You must provide either an email or phone number and a type")
        } catch (r) {
            if (K(r))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                });
            throw r
        }
    }
    async getSession() {
        return await this.initializePromise,
        await this._acquireLock(this.lockAcquireTimeout, async () => this._useSession(async r => r))
    }
    async _acquireLock(e, r) {
        this._debug("#_acquireLock", "begin", e);
        try {
            if (this.lockAcquired) {
                const n = this.pendingInLock.length ? this.pendingInLock[this.pendingInLock.length - 1] : Promise.resolve()
                  , s = (async () => (await n,
                await r()))();
                return this.pendingInLock.push((async () => {
                    try {
                        await s
                    } catch {}
                }
                )()),
                s
            }
            return await this.lock(`lock:${this.storageKey}`, e, async () => {
                this._debug("#_acquireLock", "lock acquired for storage key", this.storageKey);
                try {
                    this.lockAcquired = !0;
                    const n = r();
                    for (this.pendingInLock.push((async () => {
                        try {
                            await n
                        } catch {}
                    }
                    )()),
                    await n; this.pendingInLock.length; ) {
                        const s = [...this.pendingInLock];
                        await Promise.all(s),
                        this.pendingInLock.splice(0, s.length)
                    }
                    return await n
                } finally {
                    this._debug("#_acquireLock", "lock released for storage key", this.storageKey),
                    this.lockAcquired = !1
                }
            }
            )
        } finally {
            this._debug("#_acquireLock", "end")
        }
    }
    async _useSession(e) {
        this._debug("#_useSession", "begin");
        try {
            const r = await this.__loadSession();
            return await e(r)
        } finally {
            this._debug("#_useSession", "end")
        }
    }
    async __loadSession() {
        this._debug("#__loadSession()", "begin"),
        this.lockAcquired || this._debug("#__loadSession()", "used outside of an acquired lock!", new Error().stack);
        try {
            let e = null;
            const r = await ls(this.storage, this.storageKey);
            if (this._debug("#getSession()", "session from storage", r),
            r !== null && (this._isValidSession(r) ? e = r : (this._debug("#getSession()", "session from storage is not valid"),
            await this._removeSession())),
            !e)
                return {
                    data: {
                        session: null
                    },
                    error: null
                };
            const n = e.expires_at ? e.expires_at * 1e3 - Date.now() < pd : !1;
            if (this._debug("#__loadSession()", `session has${n ? "" : " not"} expired`, "expires_at", e.expires_at),
            !n) {
                if (this.userStorage) {
                    const o = await ls(this.userStorage, this.storageKey + "-user");
                    o != null && o.user ? e.user = o.user : e.user = vd()
                }
                if (this.storage.isServer && e.user && !e.user.__isUserNotAvailableProxy) {
                    const o = {
                        value: this.suppressGetSessionWarning
                    };
                    e.user = eO(e.user, o),
                    o.value && (this.suppressGetSessionWarning = !0)
                }
                return {
                    data: {
                        session: e
                    },
                    error: null
                }
            }
            const {data: s, error: i} = await this._callRefreshToken(e.refresh_token);
            return i ? this._returnResult({
                data: {
                    session: null
                },
                error: i
            }) : this._returnResult({
                data: {
                    session: s
                },
                error: null
            })
        } finally {
            this._debug("#__loadSession()", "end")
        }
    }
    async getUser(e) {
        if (e)
            return await this._getUser(e);
        await this.initializePromise;
        const r = await this._acquireLock(this.lockAcquireTimeout, async () => await this._getUser());
        return r.data.user && (this.suppressGetSessionWarning = !0),
        r
    }
    async _getUser(e) {
        try {
            return e ? await J(this.fetch, "GET", `${this.url}/user`, {
                headers: this.headers,
                jwt: e,
                xform: wn
            }) : await this._useSession(async r => {
                var n, s, i;
                const {data: o, error: a} = r;
                if (a)
                    throw a;
                return !(!((n = o.session) === null || n === void 0) && n.access_token) && !this.hasCustomAuthorizationHeader ? {
                    data: {
                        user: null
                    },
                    error: new Nt
                } : await J(this.fetch, "GET", `${this.url}/user`, {
                    headers: this.headers,
                    jwt: (i = (s = o.session) === null || s === void 0 ? void 0 : s.access_token) !== null && i !== void 0 ? i : void 0,
                    xform: wn
                })
            }
            )
        } catch (r) {
            if (K(r))
                return Aj(r) && (await this._removeSession(),
                await tt(this.storage, `${this.storageKey}-code-verifier`)),
                this._returnResult({
                    data: {
                        user: null
                    },
                    error: r
                });
            throw r
        }
    }
    async updateUser(e, r={}) {
        return await this.initializePromise,
        await this._acquireLock(this.lockAcquireTimeout, async () => await this._updateUser(e, r))
    }
    async _updateUser(e, r={}) {
        try {
            return await this._useSession(async n => {
                const {data: s, error: i} = n;
                if (i)
                    throw i;
                if (!s.session)
                    throw new Nt;
                const o = s.session;
                let a = null
                  , l = null;
                this.flowType === "pkce" && e.email != null && ([a,l] = await Ys(this.storage, this.storageKey));
                const {data: c, error: u} = await J(this.fetch, "PUT", `${this.url}/user`, {
                    headers: this.headers,
                    redirectTo: r == null ? void 0 : r.emailRedirectTo,
                    body: Object.assign(Object.assign({}, e), {
                        code_challenge: a,
                        code_challenge_method: l
                    }),
                    jwt: o.access_token,
                    xform: wn
                });
                if (u)
                    throw u;
                return o.user = c.user,
                await this._saveSession(o),
                await this._notifyAllSubscribers("USER_UPDATED", o),
                this._returnResult({
                    data: {
                        user: o.user
                    },
                    error: null
                })
            }
            )
        } catch (n) {
            if (await tt(this.storage, `${this.storageKey}-code-verifier`),
            K(n))
                return this._returnResult({
                    data: {
                        user: null
                    },
                    error: n
                });
            throw n
        }
    }
    async setSession(e) {
        return await this.initializePromise,
        await this._acquireLock(this.lockAcquireTimeout, async () => await this._setSession(e))
    }
    async _setSession(e) {
        try {
            if (!e.access_token || !e.refresh_token)
                throw new Nt;
            const r = Date.now() / 1e3;
            let n = r
              , s = !0
              , i = null;
            const {payload: o} = gd(e.access_token);
            if (o.exp && (n = o.exp,
            s = n <= r),
            s) {
                const {data: a, error: l} = await this._callRefreshToken(e.refresh_token);
                if (l)
                    return this._returnResult({
                        data: {
                            user: null,
                            session: null
                        },
                        error: l
                    });
                if (!a)
                    return {
                        data: {
                            user: null,
                            session: null
                        },
                        error: null
                    };
                i = a
            } else {
                const {data: a, error: l} = await this._getUser(e.access_token);
                if (l)
                    throw l;
                i = {
                    access_token: e.access_token,
                    refresh_token: e.refresh_token,
                    user: a.user,
                    token_type: "bearer",
                    expires_in: n - r,
                    expires_at: n
                },
                await this._saveSession(i),
                await this._notifyAllSubscribers("SIGNED_IN", i)
            }
            return this._returnResult({
                data: {
                    user: i.user,
                    session: i
                },
                error: null
            })
        } catch (r) {
            if (K(r))
                return this._returnResult({
                    data: {
                        session: null,
                        user: null
                    },
                    error: r
                });
            throw r
        }
    }
    async refreshSession(e) {
        return await this.initializePromise,
        await this._acquireLock(this.lockAcquireTimeout, async () => await this._refreshSession(e))
    }
    async _refreshSession(e) {
        try {
            return await this._useSession(async r => {
                var n;
                if (!e) {
                    const {data: o, error: a} = r;
                    if (a)
                        throw a;
                    e = (n = o.session) !== null && n !== void 0 ? n : void 0
                }
                if (!(e != null && e.refresh_token))
                    throw new Nt;
                const {data: s, error: i} = await this._callRefreshToken(e.refresh_token);
                return i ? this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: i
                }) : s ? this._returnResult({
                    data: {
                        user: s.user,
                        session: s
                    },
                    error: null
                }) : this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: null
                })
            }
            )
        } catch (r) {
            if (K(r))
                return this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: r
                });
            throw r
        }
    }
    async _getSessionFromURL(e, r) {
        try {
            if (!rt())
                throw new kl("No browser detected.");
            if (e.error || e.error_description || e.error_code)
                throw new kl(e.error_description || "Error in URL with unspecified error_description",{
                    error: e.error || "unspecified_error",
                    code: e.error_code || "unspecified_code"
                });
            switch (r) {
            case "implicit":
                if (this.flowType === "pkce")
                    throw new lv("Not a valid PKCE flow url.");
                break;
            case "pkce":
                if (this.flowType === "implicit")
                    throw new kl("Not a valid implicit grant flow url.");
                break;
            default:
            }
            if (r === "pkce") {
                if (this._debug("#_initialize()", "begin", "is PKCE flow", !0),
                !e.code)
                    throw new lv("No code detected.");
                const {data: g, error: v} = await this._exchangeCodeForSession(e.code);
                if (v)
                    throw v;
                const _ = new URL(window.location.href);
                return _.searchParams.delete("code"),
                window.history.replaceState(window.history.state, "", _.toString()),
                {
                    data: {
                        session: g.session,
                        redirectType: null
                    },
                    error: null
                }
            }
            const {provider_token: n, provider_refresh_token: s, access_token: i, refresh_token: o, expires_in: a, expires_at: l, token_type: c} = e;
            if (!i || !a || !o || !c)
                throw new kl("No session defined in URL");
            const u = Math.round(Date.now() / 1e3)
              , h = parseInt(a);
            let p = u + h;
            l && (p = parseInt(l));
            const f = p - u;
            f * 1e3 <= ai && console.warn(`@supabase/gotrue-js: Session as retrieved from URL expires in ${f}s, should have been closer to ${h}s`);
            const b = p - h;
            u - b >= 120 ? console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued over 120s ago, URL could be stale", b, p, u) : u - b < 0 && console.warn("@supabase/gotrue-js: Session as retrieved from URL was issued in the future? Check the device clock for skew", b, p, u);
            const {data: m, error: x} = await this._getUser(i);
            if (x)
                throw x;
            const w = {
                provider_token: n,
                provider_refresh_token: s,
                access_token: i,
                expires_in: h,
                expires_at: p,
                refresh_token: o,
                token_type: c,
                user: m.user
            };
            return window.location.hash = "",
            this._debug("#_getSessionFromURL()", "clearing window.location.hash"),
            this._returnResult({
                data: {
                    session: w,
                    redirectType: e.type
                },
                error: null
            })
        } catch (n) {
            if (K(n))
                return this._returnResult({
                    data: {
                        session: null,
                        redirectType: null
                    },
                    error: n
                });
            throw n
        }
    }
    _isImplicitGrantCallback(e) {
        return typeof this.detectSessionInUrl == "function" ? this.detectSessionInUrl(new URL(window.location.href), e) : !!(e.access_token || e.error_description)
    }
    async _isPKCECallback(e) {
        const r = await ls(this.storage, `${this.storageKey}-code-verifier`);
        return !!(e.code && r)
    }
    async signOut(e={
        scope: "global"
    }) {
        return await this.initializePromise,
        await this._acquireLock(this.lockAcquireTimeout, async () => await this._signOut(e))
    }
    async _signOut({scope: e}={
        scope: "global"
    }) {
        return await this._useSession(async r => {
            var n;
            const {data: s, error: i} = r;
            if (i)
                return this._returnResult({
                    error: i
                });
            const o = (n = s.session) === null || n === void 0 ? void 0 : n.access_token;
            if (o) {
                const {error: a} = await this.admin.signOut(o, e);
                if (a && !(Pj(a) && (a.status === 404 || a.status === 401 || a.status === 403)))
                    return this._returnResult({
                        error: a
                    })
            }
            return e !== "others" && (await this._removeSession(),
            await tt(this.storage, `${this.storageKey}-code-verifier`)),
            this._returnResult({
                error: null
            })
        }
        )
    }
    onAuthStateChange(e) {
        const r = Uj()
          , n = {
            id: r,
            callback: e,
            unsubscribe: () => {
                this._debug("#unsubscribe()", "state change callback with id removed", r),
                this.stateChangeEmitters.delete(r)
            }
        };
        return this._debug("#onAuthStateChange()", "registered callback with id", r),
        this.stateChangeEmitters.set(r, n),
        (async () => (await this.initializePromise,
        await this._acquireLock(this.lockAcquireTimeout, async () => {
            this._emitInitialSession(r)
        }
        )))(),
        {
            data: {
                subscription: n
            }
        }
    }
    async _emitInitialSession(e) {
        return await this._useSession(async r => {
            var n, s;
            try {
                const {data: {session: i}, error: o} = r;
                if (o)
                    throw o;
                await ((n = this.stateChangeEmitters.get(e)) === null || n === void 0 ? void 0 : n.callback("INITIAL_SESSION", i)),
                this._debug("INITIAL_SESSION", "callback id", e, "session", i)
            } catch (i) {
                await ((s = this.stateChangeEmitters.get(e)) === null || s === void 0 ? void 0 : s.callback("INITIAL_SESSION", null)),
                this._debug("INITIAL_SESSION", "callback id", e, "error", i),
                console.error(i)
            }
        }
        )
    }
    async resetPasswordForEmail(e, r={}) {
        let n = null
          , s = null;
        this.flowType === "pkce" && ([n,s] = await Ys(this.storage, this.storageKey, !0));
        try {
            return await J(this.fetch, "POST", `${this.url}/recover`, {
                body: {
                    email: e,
                    code_challenge: n,
                    code_challenge_method: s,
                    gotrue_meta_security: {
                        captcha_token: r.captchaToken
                    }
                },
                headers: this.headers,
                redirectTo: r.redirectTo
            })
        } catch (i) {
            if (await tt(this.storage, `${this.storageKey}-code-verifier`),
            K(i))
                return this._returnResult({
                    data: null,
                    error: i
                });
            throw i
        }
    }
    async getUserIdentities() {
        var e;
        try {
            const {data: r, error: n} = await this.getUser();
            if (n)
                throw n;
            return this._returnResult({
                data: {
                    identities: (e = r.user.identities) !== null && e !== void 0 ? e : []
                },
                error: null
            })
        } catch (r) {
            if (K(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async linkIdentity(e) {
        return "token"in e ? this.linkIdentityIdToken(e) : this.linkIdentityOAuth(e)
    }
    async linkIdentityOAuth(e) {
        var r;
        try {
            const {data: n, error: s} = await this._useSession(async i => {
                var o, a, l, c, u;
                const {data: h, error: p} = i;
                if (p)
                    throw p;
                const f = await this._getUrlForProvider(`${this.url}/user/identities/authorize`, e.provider, {
                    redirectTo: (o = e.options) === null || o === void 0 ? void 0 : o.redirectTo,
                    scopes: (a = e.options) === null || a === void 0 ? void 0 : a.scopes,
                    queryParams: (l = e.options) === null || l === void 0 ? void 0 : l.queryParams,
                    skipBrowserRedirect: !0
                });
                return await J(this.fetch, "GET", f, {
                    headers: this.headers,
                    jwt: (u = (c = h.session) === null || c === void 0 ? void 0 : c.access_token) !== null && u !== void 0 ? u : void 0
                })
            }
            );
            if (s)
                throw s;
            return rt() && !(!((r = e.options) === null || r === void 0) && r.skipBrowserRedirect) && window.location.assign(n == null ? void 0 : n.url),
            this._returnResult({
                data: {
                    provider: e.provider,
                    url: n == null ? void 0 : n.url
                },
                error: null
            })
        } catch (n) {
            if (K(n))
                return this._returnResult({
                    data: {
                        provider: e.provider,
                        url: null
                    },
                    error: n
                });
            throw n
        }
    }
    async linkIdentityIdToken(e) {
        return await this._useSession(async r => {
            var n;
            try {
                const {error: s, data: {session: i}} = r;
                if (s)
                    throw s;
                const {options: o, provider: a, token: l, access_token: c, nonce: u} = e
                  , h = await J(this.fetch, "POST", `${this.url}/token?grant_type=id_token`, {
                    headers: this.headers,
                    jwt: (n = i == null ? void 0 : i.access_token) !== null && n !== void 0 ? n : void 0,
                    body: {
                        provider: a,
                        id_token: l,
                        access_token: c,
                        nonce: u,
                        link_identity: !0,
                        gotrue_meta_security: {
                            captcha_token: o == null ? void 0 : o.captchaToken
                        }
                    },
                    xform: lr
                })
                  , {data: p, error: f} = h;
                return f ? this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: f
                }) : !p || !p.session || !p.user ? this._returnResult({
                    data: {
                        user: null,
                        session: null
                    },
                    error: new Zs
                }) : (p.session && (await this._saveSession(p.session),
                await this._notifyAllSubscribers("USER_UPDATED", p.session)),
                this._returnResult({
                    data: p,
                    error: f
                }))
            } catch (s) {
                if (await tt(this.storage, `${this.storageKey}-code-verifier`),
                K(s))
                    return this._returnResult({
                        data: {
                            user: null,
                            session: null
                        },
                        error: s
                    });
                throw s
            }
        }
        )
    }
    async unlinkIdentity(e) {
        try {
            return await this._useSession(async r => {
                var n, s;
                const {data: i, error: o} = r;
                if (o)
                    throw o;
                return await J(this.fetch, "DELETE", `${this.url}/user/identities/${e.identity_id}`, {
                    headers: this.headers,
                    jwt: (s = (n = i.session) === null || n === void 0 ? void 0 : n.access_token) !== null && s !== void 0 ? s : void 0
                })
            }
            )
        } catch (r) {
            if (K(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async _refreshAccessToken(e) {
        const r = `#_refreshAccessToken(${e.substring(0, 5)}...)`;
        this._debug(r, "begin");
        try {
            const n = Date.now();
            return await Wj(async s => (s > 0 && await Vj(200 * Math.pow(2, s - 1)),
            this._debug(r, "refreshing attempt", s),
            await J(this.fetch, "POST", `${this.url}/token?grant_type=refresh_token`, {
                body: {
                    refresh_token: e
                },
                headers: this.headers,
                xform: lr
            })), (s, i) => {
                const o = 200 * Math.pow(2, s);
                return i && md(i) && Date.now() + o - n < ai
            }
            )
        } catch (n) {
            if (this._debug(r, "error", n),
            K(n))
                return this._returnResult({
                    data: {
                        session: null,
                        user: null
                    },
                    error: n
                });
            throw n
        } finally {
            this._debug(r, "end")
        }
    }
    _isValidSession(e) {
        return typeof e == "object" && e !== null && "access_token"in e && "refresh_token"in e && "expires_at"in e
    }
    async _handleProviderSignIn(e, r) {
        const n = await this._getUrlForProvider(`${this.url}/authorize`, e, {
            redirectTo: r.redirectTo,
            scopes: r.scopes,
            queryParams: r.queryParams
        });
        return this._debug("#_handleProviderSignIn()", "provider", e, "options", r, "url", n),
        rt() && !r.skipBrowserRedirect && window.location.assign(n),
        {
            data: {
                provider: e,
                url: n
            },
            error: null
        }
    }
    async _recoverAndRefresh() {
        var e, r;
        const n = "#_recoverAndRefresh()";
        this._debug(n, "begin");
        try {
            const s = await ls(this.storage, this.storageKey);
            if (s && this.userStorage) {
                let o = await ls(this.userStorage, this.storageKey + "-user");
                !this.storage.isServer && Object.is(this.storage, this.userStorage) && !o && (o = {
                    user: s.user
                },
                await li(this.userStorage, this.storageKey + "-user", o)),
                s.user = (e = o == null ? void 0 : o.user) !== null && e !== void 0 ? e : vd()
            } else if (s && !s.user && !s.user) {
                const o = await ls(this.storage, this.storageKey + "-user");
                o && (o != null && o.user) ? (s.user = o.user,
                await tt(this.storage, this.storageKey + "-user"),
                await li(this.storage, this.storageKey, s)) : s.user = vd()
            }
            if (this._debug(n, "session from storage", s),
            !this._isValidSession(s)) {
                this._debug(n, "session is not valid"),
                s !== null && await this._removeSession();
                return
            }
            const i = ((r = s.expires_at) !== null && r !== void 0 ? r : 1 / 0) * 1e3 - Date.now() < pd;
            if (this._debug(n, `session has${i ? "" : " not"} expired with margin of ${pd}s`),
            i) {
                if (this.autoRefreshToken && s.refresh_token) {
                    const {error: o} = await this._callRefreshToken(s.refresh_token);
                    o && (console.error(o),
                    md(o) || (this._debug(n, "refresh failed with a non-retryable error, removing the session", o),
                    await this._removeSession()))
                }
            } else if (s.user && s.user.__isUserNotAvailableProxy === !0)
                try {
                    const {data: o, error: a} = await this._getUser(s.access_token);
                    !a && (o != null && o.user) ? (s.user = o.user,
                    await this._saveSession(s),
                    await this._notifyAllSubscribers("SIGNED_IN", s)) : this._debug(n, "could not get user data, skipping SIGNED_IN notification")
                } catch (o) {
                    console.error("Error getting user data:", o),
                    this._debug(n, "error getting user data, skipping SIGNED_IN notification", o)
                }
            else
                await this._notifyAllSubscribers("SIGNED_IN", s)
        } catch (s) {
            this._debug(n, "error", s),
            console.error(s);
            return
        } finally {
            this._debug(n, "end")
        }
    }
    async _callRefreshToken(e) {
        var r, n;
        if (!e)
            throw new Nt;
        if (this.refreshingDeferred)
            return this.refreshingDeferred.promise;
        const s = `#_callRefreshToken(${e.substring(0, 5)}...)`;
        this._debug(s, "begin");
        try {
            this.refreshingDeferred = new xu;
            const {data: i, error: o} = await this._refreshAccessToken(e);
            if (o)
                throw o;
            if (!i.session)
                throw new Nt;
            await this._saveSession(i.session),
            await this._notifyAllSubscribers("TOKEN_REFRESHED", i.session);
            const a = {
                data: i.session,
                error: null
            };
            return this.refreshingDeferred.resolve(a),
            a
        } catch (i) {
            if (this._debug(s, "error", i),
            K(i)) {
                const o = {
                    data: null,
                    error: i
                };
                return md(i) || await this._removeSession(),
                (r = this.refreshingDeferred) === null || r === void 0 || r.resolve(o),
                o
            }
            throw (n = this.refreshingDeferred) === null || n === void 0 || n.reject(i),
            i
        } finally {
            this.refreshingDeferred = null,
            this._debug(s, "end")
        }
    }
    async _notifyAllSubscribers(e, r, n=!0) {
        const s = `#_notifyAllSubscribers(${e})`;
        this._debug(s, "begin", r, `broadcast = ${n}`);
        try {
            this.broadcastChannel && n && this.broadcastChannel.postMessage({
                event: e,
                session: r
            });
            const i = []
              , o = Array.from(this.stateChangeEmitters.values()).map(async a => {
                try {
                    await a.callback(e, r)
                } catch (l) {
                    i.push(l)
                }
            }
            );
            if (await Promise.all(o),
            i.length > 0) {
                for (let a = 0; a < i.length; a += 1)
                    console.error(i[a]);
                throw i[0]
            }
        } finally {
            this._debug(s, "end")
        }
    }
    async _saveSession(e) {
        this._debug("#_saveSession()", e),
        this.suppressGetSessionWarning = !0,
        await tt(this.storage, `${this.storageKey}-code-verifier`);
        const r = Object.assign({}, e)
          , n = r.user && r.user.__isUserNotAvailableProxy === !0;
        if (this.userStorage) {
            !n && r.user && await li(this.userStorage, this.storageKey + "-user", {
                user: r.user
            });
            const s = Object.assign({}, r);
            delete s.user;
            const i = fv(s);
            await li(this.storage, this.storageKey, i)
        } else {
            const s = fv(r);
            await li(this.storage, this.storageKey, s)
        }
    }
    async _removeSession() {
        this._debug("#_removeSession()"),
        this.suppressGetSessionWarning = !1,
        await tt(this.storage, this.storageKey),
        await tt(this.storage, this.storageKey + "-code-verifier"),
        await tt(this.storage, this.storageKey + "-user"),
        this.userStorage && await tt(this.userStorage, this.storageKey + "-user"),
        await this._notifyAllSubscribers("SIGNED_OUT", null)
    }
    _removeVisibilityChangedCallback() {
        this._debug("#_removeVisibilityChangedCallback()");
        const e = this.visibilityChangedCallback;
        this.visibilityChangedCallback = null;
        try {
            e && rt() && (window != null && window.removeEventListener) && window.removeEventListener("visibilitychange", e)
        } catch (r) {
            console.error("removing visibilitychange callback failed", r)
        }
    }
    async _startAutoRefresh() {
        await this._stopAutoRefresh(),
        this._debug("#_startAutoRefresh()");
        const e = setInterval( () => this._autoRefreshTokenTick(), ai);
        this.autoRefreshTicker = e,
        e && typeof e == "object" && typeof e.unref == "function" ? e.unref() : typeof Deno < "u" && typeof Deno.unrefTimer == "function" && Deno.unrefTimer(e);
        const r = setTimeout(async () => {
            await this.initializePromise,
            await this._autoRefreshTokenTick()
        }
        , 0);
        this.autoRefreshTickTimeout = r,
        r && typeof r == "object" && typeof r.unref == "function" ? r.unref() : typeof Deno < "u" && typeof Deno.unrefTimer == "function" && Deno.unrefTimer(r)
    }
    async _stopAutoRefresh() {
        this._debug("#_stopAutoRefresh()");
        const e = this.autoRefreshTicker;
        this.autoRefreshTicker = null,
        e && clearInterval(e);
        const r = this.autoRefreshTickTimeout;
        this.autoRefreshTickTimeout = null,
        r && clearTimeout(r)
    }
    async startAutoRefresh() {
        this._removeVisibilityChangedCallback(),
        await this._startAutoRefresh()
    }
    async stopAutoRefresh() {
        this._removeVisibilityChangedCallback(),
        await this._stopAutoRefresh()
    }
    async _autoRefreshTokenTick() {
        this._debug("#_autoRefreshTokenTick()", "begin");
        try {
            await this._acquireLock(0, async () => {
                try {
                    const e = Date.now();
                    try {
                        return await this._useSession(async r => {
                            const {data: {session: n}} = r;
                            if (!n || !n.refresh_token || !n.expires_at) {
                                this._debug("#_autoRefreshTokenTick()", "no session");
                                return
                            }
                            const s = Math.floor((n.expires_at * 1e3 - e) / ai);
                            this._debug("#_autoRefreshTokenTick()", `access token expires in ${s} ticks, a tick lasts ${ai}ms, refresh threshold is ${rf} ticks`),
                            s <= rf && await this._callRefreshToken(n.refresh_token)
                        }
                        )
                    } catch (r) {
                        console.error("Auto refresh tick failed with error. This is likely a transient error.", r)
                    }
                } finally {
                    this._debug("#_autoRefreshTokenTick()", "end")
                }
            }
            )
        } catch (e) {
            if (e.isAcquireTimeout || e instanceof Kb)
                this._debug("auto refresh token tick lock not available");
            else
                throw e
        }
    }
    async _handleVisibilityChange() {
        if (this._debug("#_handleVisibilityChange()"),
        !rt() || !(window != null && window.addEventListener))
            return this.autoRefreshToken && this.startAutoRefresh(),
            !1;
        try {
            this.visibilityChangedCallback = async () => await this._onVisibilityChanged(!1),
            window == null || window.addEventListener("visibilitychange", this.visibilityChangedCallback),
            await this._onVisibilityChanged(!0)
        } catch (e) {
            console.error("_handleVisibilityChange", e)
        }
    }
    async _onVisibilityChanged(e) {
        const r = `#_onVisibilityChanged(${e})`;
        this._debug(r, "visibilityState", document.visibilityState),
        document.visibilityState === "visible" ? (this.autoRefreshToken && this._startAutoRefresh(),
        e || (await this.initializePromise,
        await this._acquireLock(this.lockAcquireTimeout, async () => {
            if (document.visibilityState !== "visible") {
                this._debug(r, "acquired the lock to recover the session, but the browser visibilityState is no longer visible, aborting");
                return
            }
            await this._recoverAndRefresh()
        }
        ))) : document.visibilityState === "hidden" && this.autoRefreshToken && this._stopAutoRefresh()
    }
    async _getUrlForProvider(e, r, n) {
        const s = [`provider=${encodeURIComponent(r)}`];
        if (n != null && n.redirectTo && s.push(`redirect_to=${encodeURIComponent(n.redirectTo)}`),
        n != null && n.scopes && s.push(`scopes=${encodeURIComponent(n.scopes)}`),
        this.flowType === "pkce") {
            const [i,o] = await Ys(this.storage, this.storageKey)
              , a = new URLSearchParams({
                code_challenge: `${encodeURIComponent(i)}`,
                code_challenge_method: `${encodeURIComponent(o)}`
            });
            s.push(a.toString())
        }
        if (n != null && n.queryParams) {
            const i = new URLSearchParams(n.queryParams);
            s.push(i.toString())
        }
        return n != null && n.skipBrowserRedirect && s.push(`skip_http_redirect=${n.skipBrowserRedirect}`),
        `${e}?${s.join("&")}`
    }
    async _unenroll(e) {
        try {
            return await this._useSession(async r => {
                var n;
                const {data: s, error: i} = r;
                return i ? this._returnResult({
                    data: null,
                    error: i
                }) : await J(this.fetch, "DELETE", `${this.url}/factors/${e.factorId}`, {
                    headers: this.headers,
                    jwt: (n = s == null ? void 0 : s.session) === null || n === void 0 ? void 0 : n.access_token
                })
            }
            )
        } catch (r) {
            if (K(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async _enroll(e) {
        try {
            return await this._useSession(async r => {
                var n, s;
                const {data: i, error: o} = r;
                if (o)
                    return this._returnResult({
                        data: null,
                        error: o
                    });
                const a = Object.assign({
                    friendly_name: e.friendlyName,
                    factor_type: e.factorType
                }, e.factorType === "phone" ? {
                    phone: e.phone
                } : e.factorType === "totp" ? {
                    issuer: e.issuer
                } : {})
                  , {data: l, error: c} = await J(this.fetch, "POST", `${this.url}/factors`, {
                    body: a,
                    headers: this.headers,
                    jwt: (n = i == null ? void 0 : i.session) === null || n === void 0 ? void 0 : n.access_token
                });
                return c ? this._returnResult({
                    data: null,
                    error: c
                }) : (e.factorType === "totp" && l.type === "totp" && (!((s = l == null ? void 0 : l.totp) === null || s === void 0) && s.qr_code) && (l.totp.qr_code = `data:image/svg+xml;utf-8,${l.totp.qr_code}`),
                this._returnResult({
                    data: l,
                    error: null
                }))
            }
            )
        } catch (r) {
            if (K(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async _verify(e) {
        return this._acquireLock(this.lockAcquireTimeout, async () => {
            try {
                return await this._useSession(async r => {
                    var n;
                    const {data: s, error: i} = r;
                    if (i)
                        return this._returnResult({
                            data: null,
                            error: i
                        });
                    const o = Object.assign({
                        challenge_id: e.challengeId
                    }, "webauthn"in e ? {
                        webauthn: Object.assign(Object.assign({}, e.webauthn), {
                            credential_response: e.webauthn.type === "create" ? xO(e.webauthn.credential_response) : bO(e.webauthn.credential_response)
                        })
                    } : {
                        code: e.code
                    })
                      , {data: a, error: l} = await J(this.fetch, "POST", `${this.url}/factors/${e.factorId}/verify`, {
                        body: o,
                        headers: this.headers,
                        jwt: (n = s == null ? void 0 : s.session) === null || n === void 0 ? void 0 : n.access_token
                    });
                    return l ? this._returnResult({
                        data: null,
                        error: l
                    }) : (await this._saveSession(Object.assign({
                        expires_at: Math.round(Date.now() / 1e3) + a.expires_in
                    }, a)),
                    await this._notifyAllSubscribers("MFA_CHALLENGE_VERIFIED", a),
                    this._returnResult({
                        data: a,
                        error: l
                    }))
                }
                )
            } catch (r) {
                if (K(r))
                    return this._returnResult({
                        data: null,
                        error: r
                    });
                throw r
            }
        }
        )
    }
    async _challenge(e) {
        return this._acquireLock(this.lockAcquireTimeout, async () => {
            try {
                return await this._useSession(async r => {
                    var n;
                    const {data: s, error: i} = r;
                    if (i)
                        return this._returnResult({
                            data: null,
                            error: i
                        });
                    const o = await J(this.fetch, "POST", `${this.url}/factors/${e.factorId}/challenge`, {
                        body: e,
                        headers: this.headers,
                        jwt: (n = s == null ? void 0 : s.session) === null || n === void 0 ? void 0 : n.access_token
                    });
                    if (o.error)
                        return o;
                    const {data: a} = o;
                    if (a.type !== "webauthn")
                        return {
                            data: a,
                            error: null
                        };
                    switch (a.webauthn.type) {
                    case "create":
                        return {
                            data: Object.assign(Object.assign({}, a), {
                                webauthn: Object.assign(Object.assign({}, a.webauthn), {
                                    credential_options: Object.assign(Object.assign({}, a.webauthn.credential_options), {
                                        publicKey: yO(a.webauthn.credential_options.publicKey)
                                    })
                                })
                            }),
                            error: null
                        };
                    case "request":
                        return {
                            data: Object.assign(Object.assign({}, a), {
                                webauthn: Object.assign(Object.assign({}, a.webauthn), {
                                    credential_options: Object.assign(Object.assign({}, a.webauthn.credential_options), {
                                        publicKey: wO(a.webauthn.credential_options.publicKey)
                                    })
                                })
                            }),
                            error: null
                        }
                    }
                }
                )
            } catch (r) {
                if (K(r))
                    return this._returnResult({
                        data: null,
                        error: r
                    });
                throw r
            }
        }
        )
    }
    async _challengeAndVerify(e) {
        const {data: r, error: n} = await this._challenge({
            factorId: e.factorId
        });
        return n ? this._returnResult({
            data: null,
            error: n
        }) : await this._verify({
            factorId: e.factorId,
            challengeId: r.id,
            code: e.code
        })
    }
    async _listFactors() {
        var e;
        const {data: {user: r}, error: n} = await this.getUser();
        if (n)
            return {
                data: null,
                error: n
            };
        const s = {
            all: [],
            phone: [],
            totp: [],
            webauthn: []
        };
        for (const i of (e = r == null ? void 0 : r.factors) !== null && e !== void 0 ? e : [])
            s.all.push(i),
            i.status === "verified" && s[i.factor_type].push(i);
        return {
            data: s,
            error: null
        }
    }
    async _getAuthenticatorAssuranceLevel() {
        var e, r;
        const {data: {session: n}, error: s} = await this.getSession();
        if (s)
            return this._returnResult({
                data: null,
                error: s
            });
        if (!n)
            return {
                data: {
                    currentLevel: null,
                    nextLevel: null,
                    currentAuthenticationMethods: []
                },
                error: null
            };
        const {payload: i} = gd(n.access_token);
        let o = null;
        i.aal && (o = i.aal);
        let a = o;
        ((r = (e = n.user.factors) === null || e === void 0 ? void 0 : e.filter(u => u.status === "verified")) !== null && r !== void 0 ? r : []).length > 0 && (a = "aal2");
        const c = i.amr || [];
        return {
            data: {
                currentLevel: o,
                nextLevel: a,
                currentAuthenticationMethods: c
            },
            error: null
        }
    }
    async _getAuthorizationDetails(e) {
        try {
            return await this._useSession(async r => {
                const {data: {session: n}, error: s} = r;
                return s ? this._returnResult({
                    data: null,
                    error: s
                }) : n ? await J(this.fetch, "GET", `${this.url}/oauth/authorizations/${e}`, {
                    headers: this.headers,
                    jwt: n.access_token,
                    xform: i => ({
                        data: i,
                        error: null
                    })
                }) : this._returnResult({
                    data: null,
                    error: new Nt
                })
            }
            )
        } catch (r) {
            if (K(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async _approveAuthorization(e, r) {
        try {
            return await this._useSession(async n => {
                const {data: {session: s}, error: i} = n;
                if (i)
                    return this._returnResult({
                        data: null,
                        error: i
                    });
                if (!s)
                    return this._returnResult({
                        data: null,
                        error: new Nt
                    });
                const o = await J(this.fetch, "POST", `${this.url}/oauth/authorizations/${e}/consent`, {
                    headers: this.headers,
                    jwt: s.access_token,
                    body: {
                        action: "approve"
                    },
                    xform: a => ({
                        data: a,
                        error: null
                    })
                });
                return o.data && o.data.redirect_url && rt() && !(r != null && r.skipBrowserRedirect) && window.location.assign(o.data.redirect_url),
                o
            }
            )
        } catch (n) {
            if (K(n))
                return this._returnResult({
                    data: null,
                    error: n
                });
            throw n
        }
    }
    async _denyAuthorization(e, r) {
        try {
            return await this._useSession(async n => {
                const {data: {session: s}, error: i} = n;
                if (i)
                    return this._returnResult({
                        data: null,
                        error: i
                    });
                if (!s)
                    return this._returnResult({
                        data: null,
                        error: new Nt
                    });
                const o = await J(this.fetch, "POST", `${this.url}/oauth/authorizations/${e}/consent`, {
                    headers: this.headers,
                    jwt: s.access_token,
                    body: {
                        action: "deny"
                    },
                    xform: a => ({
                        data: a,
                        error: null
                    })
                });
                return o.data && o.data.redirect_url && rt() && !(r != null && r.skipBrowserRedirect) && window.location.assign(o.data.redirect_url),
                o
            }
            )
        } catch (n) {
            if (K(n))
                return this._returnResult({
                    data: null,
                    error: n
                });
            throw n
        }
    }
    async _listOAuthGrants() {
        try {
            return await this._useSession(async e => {
                const {data: {session: r}, error: n} = e;
                return n ? this._returnResult({
                    data: null,
                    error: n
                }) : r ? await J(this.fetch, "GET", `${this.url}/user/oauth/grants`, {
                    headers: this.headers,
                    jwt: r.access_token,
                    xform: s => ({
                        data: s,
                        error: null
                    })
                }) : this._returnResult({
                    data: null,
                    error: new Nt
                })
            }
            )
        } catch (e) {
            if (K(e))
                return this._returnResult({
                    data: null,
                    error: e
                });
            throw e
        }
    }
    async _revokeOAuthGrant(e) {
        try {
            return await this._useSession(async r => {
                const {data: {session: n}, error: s} = r;
                return s ? this._returnResult({
                    data: null,
                    error: s
                }) : n ? (await J(this.fetch, "DELETE", `${this.url}/user/oauth/grants`, {
                    headers: this.headers,
                    jwt: n.access_token,
                    query: {
                        client_id: e.clientId
                    },
                    noResolveJson: !0
                }),
                {
                    data: {},
                    error: null
                }) : this._returnResult({
                    data: null,
                    error: new Nt
                })
            }
            )
        } catch (r) {
            if (K(r))
                return this._returnResult({
                    data: null,
                    error: r
                });
            throw r
        }
    }
    async fetchJwk(e, r={
        keys: []
    }) {
        let n = r.keys.find(a => a.kid === e);
        if (n)
            return n;
        const s = Date.now();
        if (n = this.jwks.keys.find(a => a.kid === e),
        n && this.jwks_cached_at + Rj > s)
            return n;
        const {data: i, error: o} = await J(this.fetch, "GET", `${this.url}/.well-known/jwks.json`, {
            headers: this.headers
        });
        if (o)
            throw o;
        return !i.keys || i.keys.length === 0 || (this.jwks = i,
        this.jwks_cached_at = s,
        n = i.keys.find(a => a.kid === e),
        !n) ? null : n
    }
    async getClaims(e, r={}) {
        try {
            let n = e;
            if (!n) {
                const {data: f, error: b} = await this.getSession();
                if (b || !f.session)
                    return this._returnResult({
                        data: null,
                        error: b
                    });
                n = f.session.access_token
            }
            const {header: s, payload: i, signature: o, raw: {header: a, payload: l}} = gd(n);
            r != null && r.allowExpired || Zj(i.exp);
            const c = !s.alg || s.alg.startsWith("HS") || !s.kid || !("crypto"in globalThis && "subtle"in globalThis.crypto) ? null : await this.fetchJwk(s.kid, r != null && r.keys ? {
                keys: r.keys
            } : r == null ? void 0 : r.jwks);
            if (!c) {
                const {error: f} = await this.getUser(n);
                if (f)
                    throw f;
                return {
                    data: {
                        claims: i,
                        header: s,
                        signature: o
                    },
                    error: null
                }
            }
            const u = Yj(s.alg)
              , h = await crypto.subtle.importKey("jwk", c, u, !0, ["verify"]);
            if (!await crypto.subtle.verify(u, h, o, Mj(`${a}.${l}`)))
                throw new of("Invalid JWT signature");
            return {
                data: {
                    claims: i,
                    header: s,
                    signature: o
                },
                error: null
            }
        } catch (n) {
            if (K(n))
                return this._returnResult({
                    data: null,
                    error: n
                });
            throw n
        }
    }
}
Ra.nextInstanceID = {};
const PO = Ra
  , AO = "2.90.1";
let Fo = "";
typeof Deno < "u" ? Fo = "deno" : typeof document < "u" ? Fo = "web" : typeof navigator < "u" && navigator.product === "ReactNative" ? Fo = "react-native" : Fo = "node";
const jO = {
    "X-Client-Info": `supabase-js-${Fo}/${AO}`
}
  , OO = {
    headers: jO
}
  , IO = {
    schema: "public"
}
  , LO = {
    autoRefreshToken: !0,
    persistSession: !0,
    detectSessionInUrl: !0,
    flowType: "implicit"
}
  , $O = {};
function Na(t) {
    "@babel/helpers - typeof";
    return Na = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
        return typeof e
    }
    : function(e) {
        return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e
    }
    ,
    Na(t)
}
function DO(t, e) {
    if (Na(t) != "object" || !t)
        return t;
    var r = t[Symbol.toPrimitive];
    if (r !== void 0) {
        var n = r.call(t, e || "default");
        if (Na(n) != "object")
            return n;
        throw new TypeError("@@toPrimitive must return a primitive value.")
    }
    return (e === "string" ? String : Number)(t)
}
function MO(t) {
    var e = DO(t, "string");
    return Na(e) == "symbol" ? e : e + ""
}
function FO(t, e, r) {
    return (e = MO(e))in t ? Object.defineProperty(t, e, {
        value: r,
        enumerable: !0,
        configurable: !0,
        writable: !0
    }) : t[e] = r,
    t
}
function xv(t, e) {
    var r = Object.keys(t);
    if (Object.getOwnPropertySymbols) {
        var n = Object.getOwnPropertySymbols(t);
        e && (n = n.filter(function(s) {
            return Object.getOwnPropertyDescriptor(t, s).enumerable
        })),
        r.push.apply(r, n)
    }
    return r
}
function Be(t) {
    for (var e = 1; e < arguments.length; e++) {
        var r = arguments[e] != null ? arguments[e] : {};
        e % 2 ? xv(Object(r), !0).forEach(function(n) {
            FO(t, n, r[n])
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(r)) : xv(Object(r)).forEach(function(n) {
            Object.defineProperty(t, n, Object.getOwnPropertyDescriptor(r, n))
        })
    }
    return t
}
const UO = t => t ? (...e) => t(...e) : (...e) => fetch(...e)
  , BO = () => Headers
  , zO = (t, e, r) => {
    const n = UO(r)
      , s = BO();
    return async (i, o) => {
        var a;
        const l = (a = await e()) !== null && a !== void 0 ? a : t;
        let c = new s(o == null ? void 0 : o.headers);
        return c.has("apikey") || c.set("apikey", t),
        c.has("Authorization") || c.set("Authorization", `Bearer ${l}`),
        n(i, Be(Be({}, o), {}, {
            headers: c
        }))
    }
}
;
function VO(t) {
    return t.endsWith("/") ? t : t + "/"
}
function WO(t, e) {
    var r, n;
    const {db: s, auth: i, realtime: o, global: a} = t
      , {db: l, auth: c, realtime: u, global: h} = e
      , p = {
        db: Be(Be({}, l), s),
        auth: Be(Be({}, c), i),
        realtime: Be(Be({}, u), o),
        storage: {},
        global: Be(Be(Be({}, h), a), {}, {
            headers: Be(Be({}, (r = h == null ? void 0 : h.headers) !== null && r !== void 0 ? r : {}), (n = a == null ? void 0 : a.headers) !== null && n !== void 0 ? n : {})
        }),
        accessToken: async () => ""
    };
    return t.accessToken ? p.accessToken = t.accessToken : delete p.accessToken,
    p
}
function HO(t) {
    const e = t == null ? void 0 : t.trim();
    if (!e)
        throw new Error("supabaseUrl is required.");
    if (!e.match(/^https?:\/\//i))
        throw new Error("Invalid supabaseUrl: Must be a valid HTTP or HTTPS URL.");
    try {
        return new URL(VO(e))
    } catch {
        throw Error("Invalid supabaseUrl: Provided URL is malformed.")
    }
}
var KO = class extends PO {
    constructor(t) {
        super(t)
    }
}
  , qO = class {
    constructor(t, e, r) {
        var n, s;
        this.supabaseUrl = t,
        this.supabaseKey = e;
        const i = HO(t);
        if (!e)
            throw new Error("supabaseKey is required.");
        this.realtimeUrl = new URL("realtime/v1",i),
        this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace("http", "ws"),
        this.authUrl = new URL("auth/v1",i),
        this.storageUrl = new URL("storage/v1",i),
        this.functionsUrl = new URL("functions/v1",i);
        const o = `sb-${i.hostname.split(".")[0]}-auth-token`
          , a = {
            db: IO,
            realtime: $O,
            auth: Be(Be({}, LO), {}, {
                storageKey: o
            }),
            global: OO
        }
          , l = WO(r ?? {}, a);
        if (this.storageKey = (n = l.auth.storageKey) !== null && n !== void 0 ? n : "",
        this.headers = (s = l.global.headers) !== null && s !== void 0 ? s : {},
        l.accessToken)
            this.accessToken = l.accessToken,
            this.auth = new Proxy({},{
                get: (u, h) => {
                    throw new Error(`@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(h)} is not possible`)
                }
            });
        else {
            var c;
            this.auth = this._initSupabaseAuthClient((c = l.auth) !== null && c !== void 0 ? c : {}, this.headers, l.global.fetch)
        }
        this.fetch = zO(e, this._getAccessToken.bind(this), l.global.fetch),
        this.realtime = this._initRealtimeClient(Be({
            headers: this.headers,
            accessToken: this._getAccessToken.bind(this)
        }, l.realtime)),
        this.accessToken && this.accessToken().then(u => this.realtime.setAuth(u)).catch(u => console.warn("Failed to set initial Realtime auth token:", u)),
        this.rest = new CA(new URL("rest/v1",i).href,{
            headers: this.headers,
            schema: l.db.schema,
            fetch: this.fetch
        }),
        this.storage = new Sj(this.storageUrl.href,this.headers,this.fetch,r == null ? void 0 : r.storage),
        l.accessToken || this._listenForAuthEvents()
    }
    get functions() {
        return new bA(this.functionsUrl.href,{
            headers: this.headers,
            customFetch: this.fetch
        })
    }
    from(t) {
        return this.rest.from(t)
    }
    schema(t) {
        return this.rest.schema(t)
    }
    rpc(t, e={}, r={
        head: !1,
        get: !1,
        count: void 0
    }) {
        return this.rest.rpc(t, e, r)
    }
    channel(t, e={
        config: {}
    }) {
        return this.realtime.channel(t, e)
    }
    getChannels() {
        return this.realtime.getChannels()
    }
    removeChannel(t) {
        return this.realtime.removeChannel(t)
    }
    removeAllChannels() {
        return this.realtime.removeAllChannels()
    }
    async _getAccessToken() {
        var t = this, e, r;
        if (t.accessToken)
            return await t.accessToken();
        const {data: n} = await t.auth.getSession();
        return (e = (r = n.session) === null || r === void 0 ? void 0 : r.access_token) !== null && e !== void 0 ? e : t.supabaseKey
    }
    _initSupabaseAuthClient({autoRefreshToken: t, persistSession: e, detectSessionInUrl: r, storage: n, userStorage: s, storageKey: i, flowType: o, lock: a, debug: l, throwOnError: c}, u, h) {
        const p = {
            Authorization: `Bearer ${this.supabaseKey}`,
            apikey: `${this.supabaseKey}`
        };
        return new KO({
            url: this.authUrl.href,
            headers: Be(Be({}, p), u),
            storageKey: i,
            autoRefreshToken: t,
            persistSession: e,
            detectSessionInUrl: r,
            storage: n,
            userStorage: s,
            flowType: o,
            lock: a,
            debug: l,
            throwOnError: c,
            fetch: h,
            hasCustomAuthorizationHeader: Object.keys(this.headers).some(f => f.toLowerCase() === "authorization")
        })
    }
    _initRealtimeClient(t) {
        return new VA(this.realtimeUrl.href,Be(Be({}, t), {}, {
            params: Be(Be({}, {
                apikey: this.supabaseKey
            }), t == null ? void 0 : t.params)
        }))
    }
    _listenForAuthEvents() {
        return this.auth.onAuthStateChange( (t, e) => {
            this._handleTokenChanged(t, "CLIENT", e == null ? void 0 : e.access_token)
        }
        )
    }
    _handleTokenChanged(t, e, r) {
        (t === "TOKEN_REFRESHED" || t === "SIGNED_IN") && this.changedAccessToken !== r ? (this.changedAccessToken = r,
        this.realtime.setAuth(r)) : t === "SIGNED_OUT" && (this.realtime.setAuth(),
        e == "STORAGE" && this.auth.signOut(),
        this.changedAccessToken = void 0)
    }
}
;
const GO = (t, e, r) => new qO(t,e,r);
function QO() {
    if (typeof window < "u")
        return !1;
    const t = globalThis.process;
    if (!t)
        return !1;
    const e = t.version;
    if (e == null)
        return !1;
    const r = e.match(/^v(\d+)\./);
    return r ? parseInt(r[1], 10) <= 18 : !1
}
QO() && console.warn("  Node.js 18 and below are deprecated and will no longer be supported in future versions of @supabase/supabase-js. Please upgrade to Node.js 20 or later. For more information, visit: https://github.com/orgs/supabase/discussions/37217");
const JO = "https://hinrffoqrtrnyhcswrfs.supabase.co"
  , ZO = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImhpbnJmZm9xcnRybnloY3N3cmZzIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjgwMjgyMzAsImV4cCI6MjA4MzYwNDIzMH0.spNNVfGdbz46V_bHhLUALLHZS5FKDtORTxBHuS_i6JE"
  , gt = GO(JO, ZO, {
    auth: {
        storage: localStorage,
        persistSession: !0,
        autoRefreshToken: !0
    }
})
  , YO = () => Yx({
    queryKey: ["scripts"],
    queryFn: async () => {
        const {data: t, error: e} = await gt.from("scripts").select("id, game_name, game_slug, status, is_premium, price, display_order").order("display_order", {
            ascending: !0
        });
        if (e)
            throw e;
        return t
    }
})
  , XO = ({onComplete: t}) => {
    const [e,r] = y.useState("logo");
    return y.useEffect( () => {
        const n = setTimeout( () => r("text"), 600)
          , s = setTimeout( () => r("fade"), 1800)
          , i = setTimeout( () => t(), 2400);
        return () => {
            clearTimeout(n),
            clearTimeout(s),
            clearTimeout(i)
        }
    }
    , [t]),
    d.jsxs("div", {
        className: `fixed inset-0 z-50 flex flex-col items-center justify-center bg-background transition-opacity duration-500 ${e === "fade" ? "opacity-0 pointer-events-none" : "opacity-100"}`,
        children: [d.jsx("div", {
            className: "absolute inset-0 bg-[radial-gradient(ellipse_at_center,hsl(var(--primary)/0.2),transparent_60%)]"
        }), d.jsx("div", {
            className: `relative transition-all duration-700 ease-out ${e === "logo" ? "scale-100 opacity-100" : "scale-90 opacity-100"}`,
            children: d.jsxs("div", {
                className: "relative",
                children: [d.jsx("div", {
                    className: "absolute inset-0 blur-3xl bg-primary/30 rounded-full scale-150 animate-pulse"
                }), d.jsx("div", {
                    className: "relative w-24 h-24 rounded-3xl bg-primary/10 border-2 border-primary/30 flex items-center justify-center glow-primary",
                    children: d.jsx(Wa, {
                        className: "w-12 h-12 text-primary animate-pulse"
                    })
                })]
            })
        }), d.jsxs("div", {
            className: `mt-8 text-center transition-all duration-500 ${e !== "logo" ? "opacity-100 translate-y-0" : "opacity-0 translate-y-4"}`,
            children: [d.jsx("h1", {
                className: "text-4xl md:text-5xl font-heading font-bold mb-2",
                children: d.jsx("span", {
                    className: "text-gradient glow-text",
                    children: "Purge Hub"
                })
            }), d.jsx("p", {
                className: "text-lg text-muted-foreground font-medium",
                children: "Be Better"
            })]
        }), d.jsx("div", {
            className: `mt-12 w-48 h-1 bg-secondary rounded-full overflow-hidden transition-opacity duration-300 ${e !== "logo" ? "opacity-100" : "opacity-0"}`,
            children: d.jsx("div", {
                className: "h-full bg-gradient-to-r from-primary to-primary/50 rounded-full transition-all duration-1000 ease-out",
                style: {
                    width: e === "fade" ? "100%" : e === "text" ? "60%" : "0%"
                }
            })
        })]
    })
}
  , e2 = [{
    id: "arsenal",
    name: "Arsenal",
    categories: [{
        name: "Aimbot System",
        icon: "",
        features: ["Smart Targeting - Automatically locks onto closest enemy within FOV", "Aim Methods - Camera or Mouse control options", "Customizable FOV - Adjustable aim radius (50-1400px)", "Smoothness Control - Adjust aim speed for legit or rage modes", "Target Selection - Choose Head, UpperTorso, or HumanoidRootPart", "FOV Circle - Visual indicator for aim radius", "Line of Sight Check - Only targets visible enemies"]
    }, {
        name: "ESP & Visuals",
        icon: "",
        features: ["Box ESP - 3D boxes around players with outline", "Skeleton ESP - Full body skeleton rendering", "Health Bars - Real-time health display with color coding", "Info Display - Player names and distance indicators", "Team Check - Automatically filters teammates", "Visibility Colors - Different colors for visible/occluded targets", "Performance Optimized - Efficient rendering system"]
    }, {
        name: "Hitbox Expander",
        icon: "",
        features: ["Expandable Hitboxes - Make targets easier to hit", "Size Control - Adjust hitbox size (1-50 studs)", "Transparency Settings - Customize hitbox visibility", "Auto-Apply - Automatically applies to all enemies"]
    }, {
        name: "Gun Modifications",
        icon: "",
        features: ["Infinite Ammo - Never reload again", "Fast Fire - Adjustable fire rate (0.01-0.2s)", "No Recoil - Perfect accuracy every shot", "Full Auto - Convert all weapons to automatic", "No Spread - Laser-accurate shots", "Real-time Updates - Instant weapon mod application"]
    }, {
        name: "Movement Enhancements",
        icon: "",
        features: ["Fly Mode - WASD + Space/Shift controls", "Adjustable Fly Speed - 10-200 speed range", "Noclip - Walk through walls and obstacles", "Full Bright - See clearly in dark areas", "Smooth Controls - Responsive movement system"]
    }, {
        name: "Combat Features",
        icon: "",
        features: ["Kill All - Automatically eliminate all enemies (F Key)", "Auto-targeting system", "Rapid elimination mode"]
    }]
}, {
    id: "trident",
    name: "Trident Survival",
    categories: [{
        name: "Combat",
        icon: "",
        features: ["Big Head aimbot (1x-10x size)", "Head transparency control", "Hit sounds (8 options: Default, Rust, Gamesense, Magic, Firework, Lazer, Pop, Zap)", "Hit sound volume control"]
    }, {
        name: "ESP System",
        icon: "",
        features: ["Box ESP with customizable colors", "Armor ESP (shows enemy armor pieces with icons)", "FOV circle with size control", "Tracer lines to targets", "Item ESP (highlights loot)", "Corpse ESP (find dead bodies)", "Raid ESP (shows explosion locations + distance + timer)", "Airdrop ESP with distance tracking"]
    }, {
        name: "Vehicle ESP",
        icon: "",
        features: ["ATV tracker", "Trolly tracker", "Helicopter tracker", "Boat tracker"]
    }, {
        name: "Ore/Resource ESP",
        icon: "",
        features: ["Stone ESP with render distance", "Iron ESP with render distance", "Nitrate ESP with render distance", "Name tags for ores", "Box highlighting for resources", "Distance-based rendering (1000-20000 studs)"]
    }, {
        name: "Visuals",
        icon: "",
        features: ["Player Chams (highlight through walls)", "Custom fill/outline colors", "Hand Chams with material override", "Weapon Chams with material override", "Material options (Default, ForceField, Neon, Asphalt)"]
    }, {
        name: "World Modifications",
        icon: "",
        features: ["Water color customization", "Water reflectance toggle", "Water wave speed (1-100)", "Wave size control", "Cloud color + density", "Fog distance (900-10000 studs)", "Fog color customization", "Time of day slider (0-24h)", "Sky presets (Default, Magma, Water, Obsidian, Galaxy, Void)", "Shadow toggle", "Lighting effects (Brightness, Contrast, Saturation)"]
    }, {
        name: "Player Enhancements",
        icon: "",
        features: ["X-Ray vision (see through walls)", "Free Cam with speed control (1-500)", "FOV Changer (50-120)", "Zoom keybind"]
    }, {
        name: "Weapon Trails",
        icon: "",
        features: ["Arrow trail color customization", "Arrow trail lifespan (0.15-20s)", "Bullet trail system", "Trail thickness control", "Trail length (1-25)", "Trail lifetime (0.01-5s)"]
    }]
}, {
    id: "pvb",
    name: "Plants vs Brainrots",
    categories: [{
        name: "Main Options",
        icon: "",
        features: ["Auto Brainrot Invasion (auto-starts invasions)", "Auto Collect Cash (teleports to money drops)", "Customizable collect cooldown (1-60 seconds)", "Aura Hit Brainrot (faster combat, 25 stud range)", "Auto Rebirth (when available)"]
    }, {
        name: "Plant Management",
        icon: "",
        features: ["Auto Set Up Best Plants (sorts by damage)", "Plant limit selector (1-65 plants)", "Automatically distributes plants across rows", "Damage-based optimization", "Pick up all plants button"]
    }, {
        name: "Brainrot/Enemy Management",
        icon: "",
        features: ["Equip Best Brainrots button", "Sell All button", "Auto Sell When Full (at 250 capacity)", "Auto Equip + Sell When Full"]
    }, {
        name: "Fuse Machine",
        icon: "",
        features: ["Auto Fuse Machine for selected plants", "Multi-select plant fusion", "Cactus  Noobini Cactusini", "Strawberry  Orangutini Strawberrini", "Pumpkin  Svinino Pumpkinino", "Sunflower  Brr Brr Sunflowerim", "Dragon Fruit  Dragonfrutina Dolphinita", "Eggplant  Eggplantini Burbalonini", "Watermelon  Bombardilo Watermelondrilo", "Cocotank  Cocotanko Giraffanto", "Carnivorous Plant  Carnivourita Tralalerita", "Mr Carrot  Los Mr Carrotitos", "King Limone  Lemowzio"]
    }]
}, {
    id: "rivals",
    name: "Rivals",
    categories: [{
        name: "Aimbot System",
        icon: "",
        features: ["Silent Aim (spam click)", "Rage Bot (auto target + click)", "Aimbot with multiple modes (Camera/Mouse)", "One-Press or Hold aiming modes", "Customizable aim parts (Head, HumanoidRootPart)", "Random aim part selection", "Max tracking distance control", "Off after kill option", "Sensitivity control with smoothing"]
    }, {
        name: "Combat",
        icon: "",
        features: ["TriggerBot with smart mode", "One-press triggering mode", "Trigger chance control (1-100%)", "Click delay customization", "Auto target closest enemy/teammate"]
    }, {
        name: "Visuals/ESP",
        icon: "",
        features: ["Player ESP with customizable colors", "Box ESP with transparency controls", "FOV circle with customization", "Team check toggle"]
    }, {
        name: "Anti-Cheat Bypass",
        icon: "",
        features: ["Anti-Katana (blocks shots during deflect)", "Deflect sound alert", "Desync system with multiple modes", "Fake lag simulation"]
    }, {
        name: "Weapon Features",
        icon: "",
        features: ["Fast Equip (instant weapon switch)", "Instant Reload (bypass delay)", "Skin Changer with preset system", "Hand & Weapon Chams (material override)", "Custom colors for chams"]
    }, {
        name: "Player Enhancements",
        icon: "",
        features: ["Infinite Jump", "Speed Modifier with slide mechanic", "No Clip", "Flying with speed control", "FOV Changer with zoom keybind"]
    }, {
        name: "Inventory",
        icon: "",
        features: ["Inventory Viewer (shows enemy loadouts)", "Billboard display of enemy equipment"]
    }, {
        name: "World Modifications",
        icon: "",
        features: ["Resolution Changer", "Time control", "Fog customization", "Sky changer", "Shadow toggle", "Lighting effects", "Water customization", "Cloud controls"]
    }, {
        name: "Misc",
        icon: "",
        features: ["X-Ray vision toggle", "Corpse ESP", "Device spoofer", "Free cam", "Particle removal (flashbang, smoke)"]
    }]
}, {
    id: "mini-empires",
    name: "Mini Empires",
    categories: [{
        name: "Vision / Fog Removal",
        icon: "",
        features: ["Vision Boost  Turn fog of war removal on or off", "Vision Range  Adjust how far you can see (2x20x)", "Auto Refresh  Automatically re-apply vision boost every 130 seconds", "Manual Refresh  Instantly refresh vision when needed", "Status Info  Displays current vision settings and whether it's active"]
    }, {
        name: "Auto Troop System",
        icon: "",
        features: ["Team Selection  Auto, Red, or Blue", "Infantry: Builder, Scout, Gunner, Shotgunner, Sniper, Rocketeer", "Vehicles: Humvee, Light Tank, Heavy Tank, Missile Truck", "Naval: Speed Boat, Builder Boat, Barge, Destroyer, Submarine", "Auto Troop Mode  Automatically creates selected troops", "Spawn Interval  Set how often troops are created (0.55 seconds)", "Training Camps limit (15)", "Vehicle Factories limit (14)", "Harbors limit (13)", "Create Troop Now  Manually spawn a troop instantly"]
    }]
}, {
    id: "tsb",
    name: "The Strongest Battlegrounds",
    categories: [{
        name: "Combat",
        icon: "",
        features: ["Auto Whirlwind Dunk", "Auto Wall Combo", "Anti Invisibility", "Auto Block", "M1 After Block"]
    }, {
        name: "Movement",
        icon: "",
        features: ["Speed Boost (Press V)", "Jump Boost", "Auto Void", "TP Back After Void", "Noclip"]
    }, {
        name: "Visuals",
        icon: "",
        features: ["ESP Everyone (Name, Ping, Platform, Streak)", "ESP Ult Bar", "ESP Death Counter", "Rainbow Chams"]
    }, {
        name: "Misc",
        icon: "",
        features: ["Anti AFK", "Teleport to Player", "Rejoin Server"]
    }]
}, {
    id: "counterblox",
    name: "Counter Blox",
    categories: [{
        name: "Aimbot",
        icon: "",
        features: ["Enable Aimbot", "Aimbot FOV with customizable radius", "Show FOV Circle (Filled/Outline)", "FOV Opacity & Thickness controls", "FOV Color customization", "Activation Key & Mode (Hold)", "Aim Target (Head)", "Prediction & Sensitivity"]
    }, {
        name: "Visuals / ESP",
        icon: "",
        features: ["Team Check", "Box ESP with Outline", "Filled Box with Opacity controls", "Box & Outline Color customization", "Tracers", "Name ESP", "Info ESP"]
    }, {
        name: "Render",
        icon: "",
        features: ["No Scope", "No Flash", "No Smoke", "No Blood", "No Bullet Holes"]
    }, {
        name: "Hitbox",
        icon: "",
        features: ["Hitbox Expander", "Team Check", "Hitbox Size & Transparency", "Hitbox Color"]
    }, {
        name: "Bullet Tracers",
        icon: "",
        features: ["Enable Tracers", "Tracer Transparency & Lifetime", "Fade Time", "Tracer Color"]
    }, {
        name: "Gun Mods",
        icon: "",
        features: ["No Recoil", "No Spread", "Fire Rate adjustment", "Full Auto", "Wall Penetration", "Armor Penetration", "Instant Equip & Reload", "Infinite Range & Ammo"]
    }, {
        name: "Movement",
        icon: "",
        features: ["Bunny Hop", "Auto Jump", "Speed & Walk Speed", "Noclip", "Anti-Aim & Spinbot"]
    }, {
        name: "Camera",
        icon: "",
        features: ["Third Person with Distance control", "Third Person Key", "Custom FOV"]
    }, {
        name: "Checks",
        icon: "",
        features: ["Team Check", "Wall Check", "Flash Check", "Force Field Check", "Friend Check"]
    }, {
        name: "Jitter",
        icon: "",
        features: ["Enable Jitter", "Jitter Chance", "Jitter X & Y"]
    }, {
        name: "Sounds",
        icon: "",
        features: ["Hit Sound with Volume", "Kill Sound with Volume"]
    }, {
        name: "Misc",
        icon: "",
        features: ["Kill All with Debounce", "Trash Talk with Rate control", "FPS Boost", "Clear Console", "Anti Vote-Kick"]
    }]
}, {
    id: "blindshot",
    name: "Blindshot",
    categories: [{
        name: "Main / Game",
        icon: "",
        features: ["See Players (Anti-Invis)", "Anti-Hit", "Auto Trophy Money"]
    }, {
        name: "Movement",
        icon: "",
        features: ["Noclip", "Fly"]
    }]
}, {
    id: "bloxfruits",
    name: "Blox Fruits",
    categories: [{
        name: "Farm Settings",
        icon: "",
        features: ["Weapon: Melee", "Anti Fall", "Noclip", "Bring Mob", "Auto Farm", "Auto Farm Level", "Auto Redeem Codes"]
    }, {
        name: "Auto Farms - Sea 2",
        icon: "",
        features: ["Auto Ectoplasm", "Auto Factory", "Auto Sea Beast"]
    }, {
        name: "Auto Farms - Sea 3",
        icon: "",
        features: ["Auto Elite Hunter", "Elite Hunter Hop", "Hop Delay", "Auto Sea Beast"]
    }, {
        name: "Bone Farm (Sea 3)",
        icon: "",
        features: ["Auto Bone", "Auto Random Surprise"]
    }, {
        name: "Cake Farm (Sea 3)",
        icon: "",
        features: ["Dough Prince Progress", "Auto Cake NPCs", "Auto Cake Prince", "Summon Cake Prince"]
    }, {
        name: "Race Awakening",
        icon: "",
        features: ["Select Host", "Refresh Players", "Auto Complete Trial", "Tween to Race Door", "Reset After Trial", "Kill Players Trial", "Auto Buy Gears"]
    }, {
        name: "Lever & Mirage",
        icon: "",
        features: ["Lever / Mirage Status", "Look at Moon"]
    }, {
        name: "Stats (Premium)",
        icon: "",
        features: ["Account Info", "Player Stats", "Auto Stats", "Select Stat", "Enable Auto Stats", "Priority Stat"]
    }, {
        name: "Swords / Guns",
        icon: "",
        features: ["Auto Get Weapons", "Auto Saber", "Auto Saber (Legendary)", "Auto Pole V2", "Auto Pole (Legendary)", "Auto Tushita"]
    }, {
        name: "Melee (Auto Farm)",
        icon: "",
        features: ["Auto Superhuman", "Auto Death Step", "Auto Sharkman Karate", "Auto Electric Claw", "Auto Dragon Talon", "Auto Godhuman", "Buy Melee selector"]
    }, {
        name: "Abilities / Colors",
        icon: "",
        features: ["Buy Abilities"]
    }, {
        name: "Local Status",
        icon: "",
        features: ["Race Status", "Moon Status", "Auto Race Quests", "Auto Bartilo Quest", "Auto Race V2 Quest", "Auto Race V3 Quest"]
    }, {
        name: "Travel",
        icon: "",
        features: ["Select Island", "Start Travel (Safe)"]
    }, {
        name: "Devil Fruits",
        icon: "",
        features: ["Auto Random Fruit", "Auto Store Fruit"]
    }, {
        name: "Dungeons",
        icon: "",
        features: ["Select Chip", "Auto Dungeon", "Auto A/Z Dungeon"]
    }, {
        name: "ESP",
        icon: "",
        features: ["Player ESP", "Chest ESP"]
    }]
}, {
    id: "entrenched",
    name: "Entrenched",
    categories: [{
        name: "Aimbot",
        icon: "",
        features: ["Customizable FOV (50-500px)", "Smoothness Control (1-100%)", "Target Hitbox Selection (Head/Torso)", "Velocity Prediction with adjustable strength", "Sticky Aim", "Aim Assist", "Team Check", "Visibility Check", "Rage Mode (400 FOV)"]
    }, {
        name: "Triggerbot",
        icon: "",
        features: ["Auto-Fire when on target", "Adjustable FOV (5-50px)", "Fire Delay Control (50-500ms)", "Team Check", "Visibility Check", "Head Only Mode"]
    }, {
        name: "ESP & Visuals",
        icon: "",
        features: ["Box ESP", "Name ESP", "Health Bars", "Distance Display", "Weapon ESP", "Snaplines", "Grenade ESP", "Chams (Wallhack)", "Max Distance Control (200-2000m)"]
    }, {
        name: "Visual Enhancements",
        icon: "",
        features: ["No Smoke", "No Weather", "No Camera Shake", "Custom Crosshair", "Auto Spot Enemies", "Mini Radar with adjustable size & range"]
    }, {
        name: "Movement",
        icon: "",
        features: ["Blink Speed (Teleport movement)", "Adjustable Distance & Delay", "Position Sync"]
    }, {
        name: "Miscellaneous",
        icon: "",
        features: ["Rearview Mirror", "Config Save/Load System", "Mobile Support"]
    }]
}]
  , bv = "https://discord.gg/perplexhub"
  , _v = 'loadstring(game:HttpGet("https://perplexhub.online/api/loader"))()'
  , t2 = [{
    label: "Weekly Injections",
    value: "10,000+",
    icon: wc
}, {
    label: "Script Technology",
    value: "Advanced",
    icon: aC
}, {
    label: "Script Hub",
    value: "Premium",
    icon: _i
}, {
    label: "Security",
    value: "Enterprise-Grade",
    icon: Ai
}]
  , r2 = ({status: t}) => {
    const e = {
        operational: "bg-[hsl(var(--status-operational))]",
        degraded: "bg-[hsl(var(--status-degraded))]",
        maintenance: "bg-[hsl(var(--status-maintenance))]"
    };
    return d.jsx("span", {
        className: `inline-block w-2.5 h-2.5 rounded-full ${e[t]}`
    })
}
  , n2 = () => {
    const {data: t, isLoading: e} = YO()
      , [r,n] = y.useState(!1)
      , [s,i] = y.useState(!0)
      , o = Ga();
    y.useEffect( () => {
        sessionStorage.getItem("perplex-visited") && i(!1)
    }
    , []);
    const a = () => {
        sessionStorage.setItem("perplex-visited", "true"),
        i(!1)
    }
      , l = () => {
        navigator.clipboard.writeText(_v),
        n(!0),
        setTimeout( () => n(!1), 2e3)
    }
    ;
    return d.jsxs(d.Fragment, {
        children: [s && d.jsx(XO, {
            onComplete: a
        }), d.jsxs("div", {
            className: `min-h-screen bg-background transition-opacity duration-500 ${s ? "opacity-0" : "opacity-100"}`,
            children: [d.jsxs("section", {
                className: "relative overflow-hidden",
                children: [d.jsx("div", {
                    className: "absolute inset-0 bg-[radial-gradient(ellipse_at_top,hsl(var(--primary)/0.15),transparent_50%)]"
                }), d.jsx("div", {
                    className: "absolute top-0 left-1/2 -translate-x-1/2 w-[800px] h-[400px] bg-[radial-gradient(ellipse,hsl(var(--primary)/0.1),transparent_70%)] blur-3xl"
                }), d.jsxs("div", {
                    className: "container relative z-10 px-4 py-20 mx-auto text-center",
                    children: [d.jsx("div", {
                        className: "mb-8 animate-fade-in-up",
                        children: d.jsx("div", {
                            className: "inline-flex items-center justify-center w-20 h-20 rounded-2xl bg-primary/10 border border-primary/20 mb-6 glow-primary",
                            children: d.jsx(Wa, {
                                className: "w-10 h-10 text-primary"
                            })
                        })
                    }), d.jsx("h1", {
                        className: "text-5xl md:text-7xl font-heading font-bold mb-4 animate-fade-in-up",
                        children: d.jsx("span", {
                            className: "text-gradient glow-text",
                            children: "Purge Hub"
                        })
                    }), d.jsx("p", {
                        className: "text-xl md:text-2xl text-muted-foreground font-medium mb-8 animate-fade-in-up animation-delay-200",
                        children: "Be Better"
                    }), d.jsx("div", {
                        className: "flex flex-col sm:flex-row gap-4 justify-center animate-fade-in-up animation-delay-400",
                        children: d.jsxs(Ye, {
                            variant: "glow",
                            size: "lg",
                            className: "text-lg px-8 py-6",
                            onClick: () => window.open(bv, "_blank"),
                            children: [d.jsx(Do, {
                                className: "w-5 h-5 mr-2"
                            }), "Join Discord"]
                        })
                    })]
                })]
            }), d.jsx("section", {
                className: "py-16 border-y border-border/50",
                children: d.jsx("div", {
                    className: "container px-4 mx-auto",
                    children: d.jsx("div", {
                        className: "grid grid-cols-2 md:grid-cols-4 gap-6",
                        children: t2.map( (c, u) => d.jsxs("div", {
                            className: "text-center p-6 rounded-xl bg-card/50 border border-border/50 animate-fade-in-up",
                            style: {
                                animationDelay: `${u * 100}ms`
                            },
                            children: [d.jsx(c.icon, {
                                className: "w-8 h-8 text-primary mx-auto mb-3"
                            }), d.jsx("p", {
                                className: "text-2xl md:text-3xl font-heading font-bold text-foreground mb-1",
                                children: c.value
                            }), d.jsx("p", {
                                className: "text-sm text-muted-foreground",
                                children: c.label
                            })]
                        }, c.label))
                    })
                })
            }), d.jsx("section", {
                className: "py-20",
                children: d.jsx("div", {
                    className: "container px-4 mx-auto",
                    children: d.jsxs("div", {
                        className: "grid md:grid-cols-2 lg:grid-cols-3 gap-6",
                        children: [d.jsxs(jt, {
                            className: "glass hover-glow lg:col-span-2",
                            children: [d.jsx(Jt, {
                                children: d.jsxs(Zt, {
                                    className: "flex items-center gap-3 text-foreground",
                                    children: [d.jsx("div", {
                                        className: "p-2 rounded-lg bg-primary/10",
                                        children: d.jsx(wc, {
                                            className: "w-5 h-5 text-primary"
                                        })
                                    }), "Script Loader"]
                                })
                            }), d.jsxs(Ot, {
                                children: [d.jsx("p", {
                                    className: "text-muted-foreground mb-4",
                                    children: "Copy the loadstring below to access Purge Hub scripts."
                                }), d.jsxs("div", {
                                    className: "relative",
                                    children: [d.jsx("div", {
                                        className: "bg-secondary/50 rounded-lg p-4 font-mono text-sm text-foreground break-all border border-border/50",
                                        children: _v
                                    }), d.jsx(Ye, {
                                        variant: "glass",
                                        size: "sm",
                                        className: "absolute top-2 right-2",
                                        onClick: l,
                                        children: r ? d.jsx(kh, {
                                            className: "w-4 h-4 text-[hsl(var(--status-operational))]"
                                        }) : d.jsx(XE, {
                                            className: "w-4 h-4"
                                        })
                                    })]
                                })]
                            })]
                        }), d.jsxs(jt, {
                            className: "glass hover-glow",
                            children: [d.jsx(Jt, {
                                children: d.jsxs(Zt, {
                                    className: "flex items-center gap-3 text-foreground",
                                    children: [d.jsx("div", {
                                        className: "p-2 rounded-lg bg-primary/10",
                                        children: d.jsx(rC, {
                                            className: "w-5 h-5 text-primary"
                                        })
                                    }), "Daily Key"]
                                })
                            }), d.jsxs(Ot, {
                                children: [d.jsx("p", {
                                    className: "text-muted-foreground mb-4",
                                    children: "Retrieve your daily access key from our Discord server."
                                }), d.jsxs(Ye, {
                                    variant: "glass",
                                    className: "w-full",
                                    onClick: () => window.open(bv, "_blank"),
                                    children: ["Get Key", d.jsx(eC, {
                                        className: "w-4 h-4 ml-2"
                                    })]
                                })]
                            })]
                        }), d.jsxs(jt, {
                            className: "glass hover-glow lg:col-span-2",
                            children: [d.jsx(Jt, {
                                children: d.jsxs(Zt, {
                                    className: "flex items-center gap-3 text-foreground",
                                    children: [d.jsx("div", {
                                        className: "p-2 rounded-lg bg-primary/10",
                                        children: d.jsx(Zw, {
                                            className: "w-5 h-5 text-primary"
                                        })
                                    }), "Script Status & Support"]
                                })
                            }), d.jsxs(Ot, {
                                children: [e ? d.jsx("div", {
                                    className: "grid sm:grid-cols-2 gap-2",
                                    children: Array.from({
                                        length: 9
                                    }).map( (c, u) => d.jsx("div", {
                                        className: "h-12 bg-secondary/30 rounded-lg animate-pulse"
                                    }, u))
                                }) : d.jsx("div", {
                                    className: "grid sm:grid-cols-2 gap-2",
                                    children: t == null ? void 0 : t.map(c => d.jsxs("div", {
                                        className: "flex items-center justify-between py-3 px-4 rounded-lg bg-secondary/30 border border-border/30",
                                        children: [d.jsxs("div", {
                                            className: "flex items-center gap-3",
                                            children: [d.jsx(r2, {
                                                status: c.status
                                            }), d.jsx("span", {
                                                className: "text-sm text-foreground",
                                                children: c.game_name
                                            })]
                                        }), c.is_premium && d.jsxs("span", {
                                            className: "text-xs font-medium px-2 py-1 rounded-full bg-primary/20 text-primary",
                                            children: ["$", c.price]
                                        })]
                                    }, c.id))
                                }), d.jsxs("div", {
                                    className: "flex justify-center gap-6 mt-4 pt-4 border-t border-border/30",
                                    children: [d.jsxs("div", {
                                        className: "flex items-center gap-2 text-xs text-muted-foreground",
                                        children: [d.jsx("span", {
                                            className: "w-2 h-2 rounded-full bg-[hsl(var(--status-operational))]"
                                        }), " Operational"]
                                    }), d.jsxs("div", {
                                        className: "flex items-center gap-2 text-xs text-muted-foreground",
                                        children: [d.jsx("span", {
                                            className: "w-2 h-2 rounded-full bg-[hsl(var(--status-degraded))]"
                                        }), " Degraded"]
                                    }), d.jsxs("div", {
                                        className: "flex items-center gap-2 text-xs text-muted-foreground",
                                        children: [d.jsx("span", {
                                            className: "w-2 h-2 rounded-full bg-[hsl(var(--status-maintenance))]"
                                        }), " Maintenance"]
                                    })]
                                })]
                            })]
                        }), d.jsxs(jt, {
                            className: "glass hover-glow border-primary/30",
                            children: [d.jsx(Jt, {
                                children: d.jsxs(Zt, {
                                    className: "flex items-center gap-3 text-foreground",
                                    children: [d.jsx("div", {
                                        className: "p-2 rounded-lg bg-primary/20",
                                        children: d.jsx(_i, {
                                            className: "w-5 h-5 text-primary"
                                        })
                                    }), "Premium"]
                                })
                            }), d.jsxs(Ot, {
                                children: [d.jsxs("div", {
                                    className: "mb-4",
                                    children: [d.jsx("p", {
                                        className: "text-3xl font-heading font-bold text-primary mb-1",
                                        children: "$4"
                                    }), d.jsx("p", {
                                        className: "text-sm text-muted-foreground",
                                        children: "Mini Empires Premium"
                                    })]
                                }), d.jsxs("ul", {
                                    className: "space-y-2 text-sm text-muted-foreground mb-4",
                                    children: [d.jsxs("li", {
                                        className: "flex items-center gap-2",
                                        children: [d.jsx("span", {
                                            className: "text-primary",
                                            children: ""
                                        }), " Exclusive features"]
                                    }), d.jsxs("li", {
                                        className: "flex items-center gap-2",
                                        children: [d.jsx("span", {
                                            className: "text-primary",
                                            children: ""
                                        }), " Priority support"]
                                    }), d.jsxs("li", {
                                        className: "flex items-center gap-2",
                                        children: [d.jsx("span", {
                                            className: "text-primary",
                                            children: ""
                                        }), " Early access updates"]
                                    })]
                                }), d.jsx(Ye, {
                                    variant: "glow",
                                    className: "w-full",
                                    onClick: () => o("/premium"),
                                    children: "Get Premium"
                                })]
                            })]
                        })]
                    })
                })
            }), d.jsx("section", {
                className: "py-20 border-t border-border/50",
                children: d.jsxs("div", {
                    className: "container px-4 mx-auto",
                    children: [d.jsxs("div", {
                        className: "text-center mb-12",
                        children: [d.jsx("div", {
                            className: "inline-flex items-center justify-center w-14 h-14 rounded-2xl bg-primary/10 border border-primary/20 mb-6",
                            children: d.jsx(nC, {
                                className: "w-7 h-7 text-primary"
                            })
                        }), d.jsx("h2", {
                            className: "text-3xl md:text-4xl font-heading font-bold text-foreground mb-4",
                            children: "Script Features"
                        }), d.jsx("p", {
                            className: "text-muted-foreground max-w-2xl mx-auto",
                            children: "Explore the powerful features available in each of our supported games"
                        })]
                    }), d.jsx("div", {
                        className: "max-w-4xl mx-auto",
                        children: d.jsx(gA, {
                            type: "single",
                            collapsible: !0,
                            className: "space-y-4",
                            children: e2.map(c => d.jsxs(Nb, {
                                value: c.id,
                                className: "glass rounded-xl border border-border/50 overflow-hidden px-0",
                                children: [d.jsx(Pb, {
                                    className: "px-6 py-4 hover:no-underline hover:bg-primary/5 transition-colors [&[data-state=open]]:bg-primary/5",
                                    children: d.jsxs("div", {
                                        className: "flex items-center gap-3",
                                        children: [d.jsx("div", {
                                            className: "p-2 rounded-lg bg-primary/10",
                                            children: d.jsx(tC, {
                                                className: "w-5 h-5 text-primary"
                                            })
                                        }), d.jsx("span", {
                                            className: "font-heading font-semibold text-foreground text-left",
                                            children: c.name
                                        }), d.jsxs("span", {
                                            className: "text-xs text-muted-foreground ml-2",
                                            children: [c.categories.reduce( (u, h) => u + h.features.length, 0), " features"]
                                        })]
                                    })
                                }), d.jsx(Ab, {
                                    className: "px-6 pb-6",
                                    children: d.jsx("div", {
                                        className: "grid gap-4 pt-2",
                                        children: c.categories.map( (u, h) => d.jsxs("div", {
                                            className: "rounded-lg bg-secondary/30 border border-border/30 p-4",
                                            children: [d.jsxs("h4", {
                                                className: "flex items-center gap-2 font-medium text-foreground mb-3",
                                                children: [d.jsx("span", {
                                                    children: u.icon
                                                }), u.name]
                                            }), d.jsx("ul", {
                                                className: "grid sm:grid-cols-2 gap-2",
                                                children: u.features.map( (p, f) => d.jsxs("li", {
                                                    className: "flex items-start gap-2 text-sm text-muted-foreground",
                                                    children: [d.jsx(kh, {
                                                        className: "w-4 h-4 text-primary flex-shrink-0 mt-0.5"
                                                    }), d.jsx("span", {
                                                        children: p
                                                    })]
                                                }, f))
                                            })]
                                        }, h))
                                    })
                                })]
                            }, c.id))
                        })
                    })]
                })
            }), d.jsx("footer", {
                className: "py-8 border-t border-border/50",
                children: d.jsx("div", {
                    className: "container px-4 mx-auto text-center",
                    children: d.jsxs("p", {
                        className: "text-sm text-muted-foreground",
                        children: [" ", new Date().getFullYear(), " Purge Hub. Be Better."]
                    })
                })
            })]
        })]
    })
}
  , ki = y.forwardRef( ({className: t, type: e, ...r}, n) => d.jsx("input", {
    type: e,
    className: me("flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm", t),
    ref: n,
    ...r
}));
ki.displayName = "Input";
var s2 = "Label"
  , Qb = y.forwardRef( (t, e) => d.jsx(le.label, {
    ...t,
    ref: e,
    onMouseDown: r => {
        var s;
        r.target.closest("button, input, select, textarea") || ((s = t.onMouseDown) == null || s.call(t, r),
        !r.defaultPrevented && r.detail > 1 && r.preventDefault())
    }
}));
Qb.displayName = s2;
var Jb = Qb;
const i2 = iu("text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70")
  , Hr = y.forwardRef( ({className: t, ...e}, r) => d.jsx(Jb, {
    ref: r,
    className: me(i2(), t),
    ...e
}));
Hr.displayName = Jb.displayName;
var wd = "rovingFocusGroup.onEntryFocus"
  , o2 = {
    bubbles: !1,
    cancelable: !0
}
  , Ja = "RovingFocusGroup"
  , [af,Zb,a2] = tu(Ja)
  , [l2,Yb] = tn(Ja, [a2])
  , [c2,u2] = l2(Ja)
  , Xb = y.forwardRef( (t, e) => d.jsx(af.Provider, {
    scope: t.__scopeRovingFocusGroup,
    children: d.jsx(af.Slot, {
        scope: t.__scopeRovingFocusGroup,
        children: d.jsx(d2, {
            ...t,
            ref: e
        })
    })
}));
Xb.displayName = Ja;
var d2 = y.forwardRef( (t, e) => {
    const {__scopeRovingFocusGroup: r, orientation: n, loop: s=!1, dir: i, currentTabStopId: o, defaultCurrentTabStopId: a, onCurrentTabStopIdChange: l, onEntryFocus: c, preventScrollOnEntryFocus: u=!1, ...h} = t
      , p = y.useRef(null)
      , f = Ae(e, p)
      , b = gu(i)
      , [m,x] = Kn({
        prop: o,
        defaultProp: a ?? null,
        onChange: l,
        caller: Ja
    })
      , [w,g] = y.useState(!1)
      , v = tr(c)
      , _ = Zb(r)
      , S = y.useRef(!1)
      , [k,C] = y.useState(0);
    return y.useEffect( () => {
        const T = p.current;
        if (T)
            return T.addEventListener(wd, v),
            () => T.removeEventListener(wd, v)
    }
    , [v]),
    d.jsx(c2, {
        scope: r,
        orientation: n,
        dir: b,
        loop: s,
        currentTabStopId: m,
        onItemFocus: y.useCallback(T => x(T), [x]),
        onItemShiftTab: y.useCallback( () => g(!0), []),
        onFocusableItemAdd: y.useCallback( () => C(T => T + 1), []),
        onFocusableItemRemove: y.useCallback( () => C(T => T - 1), []),
        children: d.jsx(le.div, {
            tabIndex: w || k === 0 ? -1 : 0,
            "data-orientation": n,
            ...h,
            ref: f,
            style: {
                outline: "none",
                ...t.style
            },
            onMouseDown: te(t.onMouseDown, () => {
                S.current = !0
            }
            ),
            onFocus: te(t.onFocus, T => {
                const A = !S.current;
                if (T.target === T.currentTarget && A && !w) {
                    const P = new CustomEvent(wd,o2);
                    if (T.currentTarget.dispatchEvent(P),
                    !P.defaultPrevented) {
                        const B = _().filter(U => U.focusable)
                          , L = B.find(U => U.active)
                          , G = B.find(U => U.id === m)
                          , Y = [L, G, ...B].filter(Boolean).map(U => U.ref.current);
                        r_(Y, u)
                    }
                }
                S.current = !1
            }
            ),
            onBlur: te(t.onBlur, () => g(!1))
        })
    })
}
)
  , e_ = "RovingFocusGroupItem"
  , t_ = y.forwardRef( (t, e) => {
    const {__scopeRovingFocusGroup: r, focusable: n=!0, active: s=!1, tabStopId: i, children: o, ...a} = t
      , l = zs()
      , c = i || l
      , u = u2(e_, r)
      , h = u.currentTabStopId === c
      , p = Zb(r)
      , {onFocusableItemAdd: f, onFocusableItemRemove: b, currentTabStopId: m} = u;
    return y.useEffect( () => {
        if (n)
            return f(),
            () => b()
    }
    , [n, f, b]),
    d.jsx(af.ItemSlot, {
        scope: r,
        id: c,
        focusable: n,
        active: s,
        children: d.jsx(le.span, {
            tabIndex: h ? 0 : -1,
            "data-orientation": u.orientation,
            ...a,
            ref: e,
            onMouseDown: te(t.onMouseDown, x => {
                n ? u.onItemFocus(c) : x.preventDefault()
            }
            ),
            onFocus: te(t.onFocus, () => u.onItemFocus(c)),
            onKeyDown: te(t.onKeyDown, x => {
                if (x.key === "Tab" && x.shiftKey) {
                    u.onItemShiftTab();
                    return
                }
                if (x.target !== x.currentTarget)
                    return;
                const w = p2(x, u.orientation, u.dir);
                if (w !== void 0) {
                    if (x.metaKey || x.ctrlKey || x.altKey || x.shiftKey)
                        return;
                    x.preventDefault();
                    let v = p().filter(_ => _.focusable).map(_ => _.ref.current);
                    if (w === "last")
                        v.reverse();
                    else if (w === "prev" || w === "next") {
                        w === "prev" && v.reverse();
                        const _ = v.indexOf(x.currentTarget);
                        v = u.loop ? m2(v, _ + 1) : v.slice(_ + 1)
                    }
                    setTimeout( () => r_(v))
                }
            }
            ),
            children: typeof o == "function" ? o({
                isCurrentTabStop: h,
                hasTabStop: m != null
            }) : o
        })
    })
}
);
t_.displayName = e_;
var h2 = {
    ArrowLeft: "prev",
    ArrowUp: "prev",
    ArrowRight: "next",
    ArrowDown: "next",
    PageUp: "first",
    Home: "first",
    PageDown: "last",
    End: "last"
};
function f2(t, e) {
    return e !== "rtl" ? t : t === "ArrowLeft" ? "ArrowRight" : t === "ArrowRight" ? "ArrowLeft" : t
}
function p2(t, e, r) {
    const n = f2(t.key, r);
    if (!(e === "vertical" && ["ArrowLeft", "ArrowRight"].includes(n)) && !(e === "horizontal" && ["ArrowUp", "ArrowDown"].includes(n)))
        return h2[n]
}
function r_(t, e=!1) {
    const r = document.activeElement;
    for (const n of t)
        if (n === r || (n.focus({
            preventScroll: e
        }),
        document.activeElement !== r))
            return
}
function m2(t, e) {
    return t.map( (r, n) => t[(e + n) % t.length])
}
var g2 = Xb
  , v2 = t_
  , bu = "Tabs"
  , [y2,$L] = tn(bu, [Yb])
  , n_ = Yb()
  , [w2,qp] = y2(bu)
  , s_ = y.forwardRef( (t, e) => {
    const {__scopeTabs: r, value: n, onValueChange: s, defaultValue: i, orientation: o="horizontal", dir: a, activationMode: l="automatic", ...c} = t
      , u = gu(a)
      , [h,p] = Kn({
        prop: n,
        onChange: s,
        defaultProp: i ?? "",
        caller: bu
    });
    return d.jsx(w2, {
        scope: r,
        baseId: zs(),
        value: h,
        onValueChange: p,
        orientation: o,
        dir: u,
        activationMode: l,
        children: d.jsx(le.div, {
            dir: u,
            "data-orientation": o,
            ...c,
            ref: e
        })
    })
}
);
s_.displayName = bu;
var i_ = "TabsList"
  , o_ = y.forwardRef( (t, e) => {
    const {__scopeTabs: r, loop: n=!0, ...s} = t
      , i = qp(i_, r)
      , o = n_(r);
    return d.jsx(g2, {
        asChild: !0,
        ...o,
        orientation: i.orientation,
        dir: i.dir,
        loop: n,
        children: d.jsx(le.div, {
            role: "tablist",
            "aria-orientation": i.orientation,
            ...s,
            ref: e
        })
    })
}
);
o_.displayName = i_;
var a_ = "TabsTrigger"
  , l_ = y.forwardRef( (t, e) => {
    const {__scopeTabs: r, value: n, disabled: s=!1, ...i} = t
      , o = qp(a_, r)
      , a = n_(r)
      , l = d_(o.baseId, n)
      , c = h_(o.baseId, n)
      , u = n === o.value;
    return d.jsx(v2, {
        asChild: !0,
        ...a,
        focusable: !s,
        active: u,
        children: d.jsx(le.button, {
            type: "button",
            role: "tab",
            "aria-selected": u,
            "aria-controls": c,
            "data-state": u ? "active" : "inactive",
            "data-disabled": s ? "" : void 0,
            disabled: s,
            id: l,
            ...i,
            ref: e,
            onMouseDown: te(t.onMouseDown, h => {
                !s && h.button === 0 && h.ctrlKey === !1 ? o.onValueChange(n) : h.preventDefault()
            }
            ),
            onKeyDown: te(t.onKeyDown, h => {
                [" ", "Enter"].includes(h.key) && o.onValueChange(n)
            }
            ),
            onFocus: te(t.onFocus, () => {
                const h = o.activationMode !== "manual";
                !u && !s && h && o.onValueChange(n)
            }
            )
        })
    })
}
);
l_.displayName = a_;
var c_ = "TabsContent"
  , u_ = y.forwardRef( (t, e) => {
    const {__scopeTabs: r, value: n, forceMount: s, children: i, ...o} = t
      , a = qp(c_, r)
      , l = d_(a.baseId, n)
      , c = h_(a.baseId, n)
      , u = n === a.value
      , h = y.useRef(u);
    return y.useEffect( () => {
        const p = requestAnimationFrame( () => h.current = !1);
        return () => cancelAnimationFrame(p)
    }
    , []),
    d.jsx(za, {
        present: s || u,
        children: ({present: p}) => d.jsx(le.div, {
            "data-state": u ? "active" : "inactive",
            "data-orientation": a.orientation,
            role: "tabpanel",
            "aria-labelledby": l,
            hidden: !p,
            id: c,
            tabIndex: 0,
            ...o,
            ref: e,
            style: {
                ...t.style,
                animationDuration: h.current ? "0s" : void 0
            },
            children: p && i
        })
    })
}
);
u_.displayName = c_;
function d_(t, e) {
    return `${t}-trigger-${e}`
}
function h_(t, e) {
    return `${t}-content-${e}`
}
var x2 = s_
  , f_ = o_
  , p_ = l_
  , m_ = u_;
const g_ = x2
  , Gp = y.forwardRef( ({className: t, ...e}, r) => d.jsx(f_, {
    ref: r,
    className: me("inline-flex h-10 items-center justify-center rounded-md bg-muted p-1 text-muted-foreground", t),
    ...e
}));
Gp.displayName = f_.displayName;
const Li = y.forwardRef( ({className: t, ...e}, r) => d.jsx(p_, {
    ref: r,
    className: me("inline-flex items-center justify-center whitespace-nowrap rounded-sm px-3 py-1.5 text-sm font-medium ring-offset-background transition-all data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow-sm focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50", t),
    ...e
}));
Li.displayName = p_.displayName;
const $i = y.forwardRef( ({className: t, ...e}, r) => d.jsx(m_, {
    ref: r,
    className: me("mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2", t),
    ...e
}));
$i.displayName = m_.displayName;
var ye;
(function(t) {
    t.assertEqual = s => {}
    ;
    function e(s) {}
    t.assertIs = e;
    function r(s) {
        throw new Error
    }
    t.assertNever = r,
    t.arrayToEnum = s => {
        const i = {};
        for (const o of s)
            i[o] = o;
        return i
    }
    ,
    t.getValidEnumValues = s => {
        const i = t.objectKeys(s).filter(a => typeof s[s[a]] != "number")
          , o = {};
        for (const a of i)
            o[a] = s[a];
        return t.objectValues(o)
    }
    ,
    t.objectValues = s => t.objectKeys(s).map(function(i) {
        return s[i]
    }),
    t.objectKeys = typeof Object.keys == "function" ? s => Object.keys(s) : s => {
        const i = [];
        for (const o in s)
            Object.prototype.hasOwnProperty.call(s, o) && i.push(o);
        return i
    }
    ,
    t.find = (s, i) => {
        for (const o of s)
            if (i(o))
                return o
    }
    ,
    t.isInteger = typeof Number.isInteger == "function" ? s => Number.isInteger(s) : s => typeof s == "number" && Number.isFinite(s) && Math.floor(s) === s;
    function n(s, i=" | ") {
        return s.map(o => typeof o == "string" ? `'${o}'` : o).join(i)
    }
    t.joinValues = n,
    t.jsonStringifyReplacer = (s, i) => typeof i == "bigint" ? i.toString() : i
}
)(ye || (ye = {}));
var Sv;
(function(t) {
    t.mergeShapes = (e, r) => ({
        ...e,
        ...r
    })
}
)(Sv || (Sv = {}));
const W = ye.arrayToEnum(["string", "nan", "number", "integer", "float", "boolean", "date", "bigint", "symbol", "function", "undefined", "null", "array", "object", "unknown", "promise", "void", "never", "map", "set"])
  , gn = t => {
    switch (typeof t) {
    case "undefined":
        return W.undefined;
    case "string":
        return W.string;
    case "number":
        return Number.isNaN(t) ? W.nan : W.number;
    case "boolean":
        return W.boolean;
    case "function":
        return W.function;
    case "bigint":
        return W.bigint;
    case "symbol":
        return W.symbol;
    case "object":
        return Array.isArray(t) ? W.array : t === null ? W.null : t.then && typeof t.then == "function" && t.catch && typeof t.catch == "function" ? W.promise : typeof Map < "u" && t instanceof Map ? W.map : typeof Set < "u" && t instanceof Set ? W.set : typeof Date < "u" && t instanceof Date ? W.date : W.object;
    default:
        return W.unknown
    }
}
  , I = ye.arrayToEnum(["invalid_type", "invalid_literal", "custom", "invalid_union", "invalid_union_discriminator", "invalid_enum_value", "unrecognized_keys", "invalid_arguments", "invalid_return_type", "invalid_date", "invalid_string", "too_small", "too_big", "invalid_intersection_types", "not_multiple_of", "not_finite"]);
class Xr extends Error {
    get errors() {
        return this.issues
    }
    constructor(e) {
        super(),
        this.issues = [],
        this.addIssue = n => {
            this.issues = [...this.issues, n]
        }
        ,
        this.addIssues = (n=[]) => {
            this.issues = [...this.issues, ...n]
        }
        ;
        const r = new.target.prototype;
        Object.setPrototypeOf ? Object.setPrototypeOf(this, r) : this.__proto__ = r,
        this.name = "ZodError",
        this.issues = e
    }
    format(e) {
        const r = e || function(i) {
            return i.message
        }
          , n = {
            _errors: []
        }
          , s = i => {
            for (const o of i.issues)
                if (o.code === "invalid_union")
                    o.unionErrors.map(s);
                else if (o.code === "invalid_return_type")
                    s(o.returnTypeError);
                else if (o.code === "invalid_arguments")
                    s(o.argumentsError);
                else if (o.path.length === 0)
                    n._errors.push(r(o));
                else {
                    let a = n
                      , l = 0;
                    for (; l < o.path.length; ) {
                        const c = o.path[l];
                        l === o.path.length - 1 ? (a[c] = a[c] || {
                            _errors: []
                        },
                        a[c]._errors.push(r(o))) : a[c] = a[c] || {
                            _errors: []
                        },
                        a = a[c],
                        l++
                    }
                }
        }
        ;
        return s(this),
        n
    }
    static assert(e) {
        if (!(e instanceof Xr))
            throw new Error(`Not a ZodError: ${e}`)
    }
    toString() {
        return this.message
    }
    get message() {
        return JSON.stringify(this.issues, ye.jsonStringifyReplacer, 2)
    }
    get isEmpty() {
        return this.issues.length === 0
    }
    flatten(e=r => r.message) {
        const r = {}
          , n = [];
        for (const s of this.issues)
            if (s.path.length > 0) {
                const i = s.path[0];
                r[i] = r[i] || [],
                r[i].push(e(s))
            } else
                n.push(e(s));
        return {
            formErrors: n,
            fieldErrors: r
        }
    }
    get formErrors() {
        return this.flatten()
    }
}
Xr.create = t => new Xr(t);
const lf = (t, e) => {
    let r;
    switch (t.code) {
    case I.invalid_type:
        t.received === W.undefined ? r = "Required" : r = `Expected ${t.expected}, received ${t.received}`;
        break;
    case I.invalid_literal:
        r = `Invalid literal value, expected ${JSON.stringify(t.expected, ye.jsonStringifyReplacer)}`;
        break;
    case I.unrecognized_keys:
        r = `Unrecognized key(s) in object: ${ye.joinValues(t.keys, ", ")}`;
        break;
    case I.invalid_union:
        r = "Invalid input";
        break;
    case I.invalid_union_discriminator:
        r = `Invalid discriminator value. Expected ${ye.joinValues(t.options)}`;
        break;
    case I.invalid_enum_value:
        r = `Invalid enum value. Expected ${ye.joinValues(t.options)}, received '${t.received}'`;
        break;
    case I.invalid_arguments:
        r = "Invalid function arguments";
        break;
    case I.invalid_return_type:
        r = "Invalid function return type";
        break;
    case I.invalid_date:
        r = "Invalid date";
        break;
    case I.invalid_string:
        typeof t.validation == "object" ? "includes"in t.validation ? (r = `Invalid input: must include "${t.validation.includes}"`,
        typeof t.validation.position == "number" && (r = `${r} at one or more positions greater than or equal to ${t.validation.position}`)) : "startsWith"in t.validation ? r = `Invalid input: must start with "${t.validation.startsWith}"` : "endsWith"in t.validation ? r = `Invalid input: must end with "${t.validation.endsWith}"` : ye.assertNever(t.validation) : t.validation !== "regex" ? r = `Invalid ${t.validation}` : r = "Invalid";
        break;
    case I.too_small:
        t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "more than"} ${t.minimum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at least" : "over"} ${t.minimum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "bigint" ? r = `Number must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${t.minimum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly equal to " : t.inclusive ? "greater than or equal to " : "greater than "}${new Date(Number(t.minimum))}` : r = "Invalid input";
        break;
    case I.too_big:
        t.type === "array" ? r = `Array must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "less than"} ${t.maximum} element(s)` : t.type === "string" ? r = `String must contain ${t.exact ? "exactly" : t.inclusive ? "at most" : "under"} ${t.maximum} character(s)` : t.type === "number" ? r = `Number must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "bigint" ? r = `BigInt must be ${t.exact ? "exactly" : t.inclusive ? "less than or equal to" : "less than"} ${t.maximum}` : t.type === "date" ? r = `Date must be ${t.exact ? "exactly" : t.inclusive ? "smaller than or equal to" : "smaller than"} ${new Date(Number(t.maximum))}` : r = "Invalid input";
        break;
    case I.custom:
        r = "Invalid input";
        break;
    case I.invalid_intersection_types:
        r = "Intersection results could not be merged";
        break;
    case I.not_multiple_of:
        r = `Number must be a multiple of ${t.multipleOf}`;
        break;
    case I.not_finite:
        r = "Number must be finite";
        break;
    default:
        r = e.defaultError,
        ye.assertNever(t)
    }
    return {
        message: r
    }
}
;
let b2 = lf;
function _2() {
    return b2
}
const S2 = t => {
    const {data: e, path: r, errorMaps: n, issueData: s} = t
      , i = [...r, ...s.path || []]
      , o = {
        ...s,
        path: i
    };
    if (s.message !== void 0)
        return {
            ...s,
            path: i,
            message: s.message
        };
    let a = "";
    const l = n.filter(c => !!c).slice().reverse();
    for (const c of l)
        a = c(o, {
            data: e,
            defaultError: a
        }).message;
    return {
        ...s,
        path: i,
        message: a
    }
}
;
function F(t, e) {
    const r = _2()
      , n = S2({
        issueData: e,
        data: t.data,
        path: t.path,
        errorMaps: [t.common.contextualErrorMap, t.schemaErrorMap, r, r === lf ? void 0 : lf].filter(s => !!s)
    });
    t.common.issues.push(n)
}
class Ut {
    constructor() {
        this.value = "valid"
    }
    dirty() {
        this.value === "valid" && (this.value = "dirty")
    }
    abort() {
        this.value !== "aborted" && (this.value = "aborted")
    }
    static mergeArray(e, r) {
        const n = [];
        for (const s of r) {
            if (s.status === "aborted")
                return re;
            s.status === "dirty" && e.dirty(),
            n.push(s.value)
        }
        return {
            status: e.value,
            value: n
        }
    }
    static async mergeObjectAsync(e, r) {
        const n = [];
        for (const s of r) {
            const i = await s.key
              , o = await s.value;
            n.push({
                key: i,
                value: o
            })
        }
        return Ut.mergeObjectSync(e, n)
    }
    static mergeObjectSync(e, r) {
        const n = {};
        for (const s of r) {
            const {key: i, value: o} = s;
            if (i.status === "aborted" || o.status === "aborted")
                return re;
            i.status === "dirty" && e.dirty(),
            o.status === "dirty" && e.dirty(),
            i.value !== "__proto__" && (typeof o.value < "u" || s.alwaysSet) && (n[i.value] = o.value)
        }
        return {
            status: e.value,
            value: n
        }
    }
}
const re = Object.freeze({
    status: "aborted"
})
  , Uo = t => ({
    status: "dirty",
    value: t
})
  , rr = t => ({
    status: "valid",
    value: t
})
  , kv = t => t.status === "aborted"
  , Ev = t => t.status === "dirty"
  , ao = t => t.status === "valid"
  , Oc = t => typeof Promise < "u" && t instanceof Promise;
var H;
(function(t) {
    t.errToObj = e => typeof e == "string" ? {
        message: e
    } : e || {},
    t.toString = e => typeof e == "string" ? e : e == null ? void 0 : e.message
}
)(H || (H = {}));
class Qn {
    constructor(e, r, n, s) {
        this._cachedPath = [],
        this.parent = e,
        this.data = r,
        this._path = n,
        this._key = s
    }
    get path() {
        return this._cachedPath.length || (Array.isArray(this._key) ? this._cachedPath.push(...this._path, ...this._key) : this._cachedPath.push(...this._path, this._key)),
        this._cachedPath
    }
}
const Cv = (t, e) => {
    if (ao(e))
        return {
            success: !0,
            data: e.value
        };
    if (!t.common.issues.length)
        throw new Error("Validation failed but no issues detected.");
    return {
        success: !1,
        get error() {
            if (this._error)
                return this._error;
            const r = new Xr(t.common.issues);
            return this._error = r,
            this._error
        }
    }
}
;
function ce(t) {
    if (!t)
        return {};
    const {errorMap: e, invalid_type_error: r, required_error: n, description: s} = t;
    if (e && (r || n))
        throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
    return e ? {
        errorMap: e,
        description: s
    } : {
        errorMap: (o, a) => {
            const {message: l} = t;
            return o.code === "invalid_enum_value" ? {
                message: l ?? a.defaultError
            } : typeof a.data > "u" ? {
                message: l ?? n ?? a.defaultError
            } : o.code !== "invalid_type" ? {
                message: a.defaultError
            } : {
                message: l ?? r ?? a.defaultError
            }
        }
        ,
        description: s
    }
}
class ge {
    get description() {
        return this._def.description
    }
    _getType(e) {
        return gn(e.data)
    }
    _getOrReturnCtx(e, r) {
        return r || {
            common: e.parent.common,
            data: e.data,
            parsedType: gn(e.data),
            schemaErrorMap: this._def.errorMap,
            path: e.path,
            parent: e.parent
        }
    }
    _processInputParams(e) {
        return {
            status: new Ut,
            ctx: {
                common: e.parent.common,
                data: e.data,
                parsedType: gn(e.data),
                schemaErrorMap: this._def.errorMap,
                path: e.path,
                parent: e.parent
            }
        }
    }
    _parseSync(e) {
        const r = this._parse(e);
        if (Oc(r))
            throw new Error("Synchronous parse encountered promise.");
        return r
    }
    _parseAsync(e) {
        const r = this._parse(e);
        return Promise.resolve(r)
    }
    parse(e, r) {
        const n = this.safeParse(e, r);
        if (n.success)
            return n.data;
        throw n.error
    }
    safeParse(e, r) {
        const n = {
            common: {
                issues: [],
                async: (r == null ? void 0 : r.async) ?? !1,
                contextualErrorMap: r == null ? void 0 : r.errorMap
            },
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: gn(e)
        }
          , s = this._parseSync({
            data: e,
            path: n.path,
            parent: n
        });
        return Cv(n, s)
    }
    "~validate"(e) {
        var n, s;
        const r = {
            common: {
                issues: [],
                async: !!this["~standard"].async
            },
            path: [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: gn(e)
        };
        if (!this["~standard"].async)
            try {
                const i = this._parseSync({
                    data: e,
                    path: [],
                    parent: r
                });
                return ao(i) ? {
                    value: i.value
                } : {
                    issues: r.common.issues
                }
            } catch (i) {
                (s = (n = i == null ? void 0 : i.message) == null ? void 0 : n.toLowerCase()) != null && s.includes("encountered") && (this["~standard"].async = !0),
                r.common = {
                    issues: [],
                    async: !0
                }
            }
        return this._parseAsync({
            data: e,
            path: [],
            parent: r
        }).then(i => ao(i) ? {
            value: i.value
        } : {
            issues: r.common.issues
        })
    }
    async parseAsync(e, r) {
        const n = await this.safeParseAsync(e, r);
        if (n.success)
            return n.data;
        throw n.error
    }
    async safeParseAsync(e, r) {
        const n = {
            common: {
                issues: [],
                contextualErrorMap: r == null ? void 0 : r.errorMap,
                async: !0
            },
            path: (r == null ? void 0 : r.path) || [],
            schemaErrorMap: this._def.errorMap,
            parent: null,
            data: e,
            parsedType: gn(e)
        }
          , s = this._parse({
            data: e,
            path: n.path,
            parent: n
        })
          , i = await (Oc(s) ? s : Promise.resolve(s));
        return Cv(n, i)
    }
    refine(e, r) {
        const n = s => typeof r == "string" || typeof r > "u" ? {
            message: r
        } : typeof r == "function" ? r(s) : r;
        return this._refinement( (s, i) => {
            const o = e(s)
              , a = () => i.addIssue({
                code: I.custom,
                ...n(s)
            });
            return typeof Promise < "u" && o instanceof Promise ? o.then(l => l ? !0 : (a(),
            !1)) : o ? !0 : (a(),
            !1)
        }
        )
    }
    refinement(e, r) {
        return this._refinement( (n, s) => e(n) ? !0 : (s.addIssue(typeof r == "function" ? r(n, s) : r),
        !1))
    }
    _refinement(e) {
        return new co({
            schema: this,
            typeName: ne.ZodEffects,
            effect: {
                type: "refinement",
                refinement: e
            }
        })
    }
    superRefine(e) {
        return this._refinement(e)
    }
    constructor(e) {
        this.spa = this.safeParseAsync,
        this._def = e,
        this.parse = this.parse.bind(this),
        this.safeParse = this.safeParse.bind(this),
        this.parseAsync = this.parseAsync.bind(this),
        this.safeParseAsync = this.safeParseAsync.bind(this),
        this.spa = this.spa.bind(this),
        this.refine = this.refine.bind(this),
        this.refinement = this.refinement.bind(this),
        this.superRefine = this.superRefine.bind(this),
        this.optional = this.optional.bind(this),
        this.nullable = this.nullable.bind(this),
        this.nullish = this.nullish.bind(this),
        this.array = this.array.bind(this),
        this.promise = this.promise.bind(this),
        this.or = this.or.bind(this),
        this.and = this.and.bind(this),
        this.transform = this.transform.bind(this),
        this.brand = this.brand.bind(this),
        this.default = this.default.bind(this),
        this.catch = this.catch.bind(this),
        this.describe = this.describe.bind(this),
        this.pipe = this.pipe.bind(this),
        this.readonly = this.readonly.bind(this),
        this.isNullable = this.isNullable.bind(this),
        this.isOptional = this.isOptional.bind(this),
        this["~standard"] = {
            version: 1,
            vendor: "zod",
            validate: r => this["~validate"](r)
        }
    }
    optional() {
        return Vn.create(this, this._def)
    }
    nullable() {
        return uo.create(this, this._def)
    }
    nullish() {
        return this.nullable().optional()
    }
    array() {
        return Ir.create(this)
    }
    promise() {
        return Dc.create(this, this._def)
    }
    or(e) {
        return Lc.create([this, e], this._def)
    }
    and(e) {
        return $c.create(this, e, this._def)
    }
    transform(e) {
        return new co({
            ...ce(this._def),
            schema: this,
            typeName: ne.ZodEffects,
            effect: {
                type: "transform",
                transform: e
            }
        })
    }
    default(e) {
        const r = typeof e == "function" ? e : () => e;
        return new uf({
            ...ce(this._def),
            innerType: this,
            defaultValue: r,
            typeName: ne.ZodDefault
        })
    }
    brand() {
        return new K2({
            typeName: ne.ZodBranded,
            type: this,
            ...ce(this._def)
        })
    }
    catch(e) {
        const r = typeof e == "function" ? e : () => e;
        return new df({
            ...ce(this._def),
            innerType: this,
            catchValue: r,
            typeName: ne.ZodCatch
        })
    }
    describe(e) {
        const r = this.constructor;
        return new r({
            ...this._def,
            description: e
        })
    }
    pipe(e) {
        return Qp.create(this, e)
    }
    readonly() {
        return hf.create(this)
    }
    isOptional() {
        return this.safeParse(void 0).success
    }
    isNullable() {
        return this.safeParse(null).success
    }
}
const k2 = /^c[^\s-]{8,}$/i
  , E2 = /^[0-9a-z]+$/
  , C2 = /^[0-9A-HJKMNP-TV-Z]{26}$/i
  , T2 = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i
  , R2 = /^[a-z0-9_-]{21}$/i
  , N2 = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/
  , P2 = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/
  , A2 = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i
  , j2 = "^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$";
let xd;
const O2 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/
  , I2 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/
  , L2 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/
  , $2 = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/
  , D2 = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/
  , M2 = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/
  , v_ = "((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))"
  , F2 = new RegExp(`^${v_}$`);
function y_(t) {
    let e = "[0-5]\\d";
    t.precision ? e = `${e}\\.\\d{${t.precision}}` : t.precision == null && (e = `${e}(\\.\\d+)?`);
    const r = t.precision ? "+" : "?";
    return `([01]\\d|2[0-3]):[0-5]\\d(:${e})${r}`
}
function U2(t) {
    return new RegExp(`^${y_(t)}$`)
}
function B2(t) {
    let e = `${v_}T${y_(t)}`;
    const r = [];
    return r.push(t.local ? "Z?" : "Z"),
    t.offset && r.push("([+-]\\d{2}:?\\d{2})"),
    e = `${e}(${r.join("|")})`,
    new RegExp(`^${e}$`)
}
function z2(t, e) {
    return !!((e === "v4" || !e) && O2.test(t) || (e === "v6" || !e) && L2.test(t))
}
function V2(t, e) {
    if (!N2.test(t))
        return !1;
    try {
        const [r] = t.split(".");
        if (!r)
            return !1;
        const n = r.replace(/-/g, "+").replace(/_/g, "/").padEnd(r.length + (4 - r.length % 4) % 4, "=")
          , s = JSON.parse(atob(n));
        return !(typeof s != "object" || s === null || "typ"in s && (s == null ? void 0 : s.typ) !== "JWT" || !s.alg || e && s.alg !== e)
    } catch {
        return !1
    }
}
function W2(t, e) {
    return !!((e === "v4" || !e) && I2.test(t) || (e === "v6" || !e) && $2.test(t))
}
class An extends ge {
    _parse(e) {
        if (this._def.coerce && (e.data = String(e.data)),
        this._getType(e) !== W.string) {
            const i = this._getOrReturnCtx(e);
            return F(i, {
                code: I.invalid_type,
                expected: W.string,
                received: i.parsedType
            }),
            re
        }
        const n = new Ut;
        let s;
        for (const i of this._def.checks)
            if (i.kind === "min")
                e.data.length < i.value && (s = this._getOrReturnCtx(e, s),
                F(s, {
                    code: I.too_small,
                    minimum: i.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "max")
                e.data.length > i.value && (s = this._getOrReturnCtx(e, s),
                F(s, {
                    code: I.too_big,
                    maximum: i.value,
                    type: "string",
                    inclusive: !0,
                    exact: !1,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "length") {
                const o = e.data.length > i.value
                  , a = e.data.length < i.value;
                (o || a) && (s = this._getOrReturnCtx(e, s),
                o ? F(s, {
                    code: I.too_big,
                    maximum: i.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: i.message
                }) : a && F(s, {
                    code: I.too_small,
                    minimum: i.value,
                    type: "string",
                    inclusive: !0,
                    exact: !0,
                    message: i.message
                }),
                n.dirty())
            } else if (i.kind === "email")
                A2.test(e.data) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    validation: "email",
                    code: I.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "emoji")
                xd || (xd = new RegExp(j2,"u")),
                xd.test(e.data) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    validation: "emoji",
                    code: I.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "uuid")
                T2.test(e.data) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    validation: "uuid",
                    code: I.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "nanoid")
                R2.test(e.data) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    validation: "nanoid",
                    code: I.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "cuid")
                k2.test(e.data) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    validation: "cuid",
                    code: I.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "cuid2")
                E2.test(e.data) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    validation: "cuid2",
                    code: I.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "ulid")
                C2.test(e.data) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    validation: "ulid",
                    code: I.invalid_string,
                    message: i.message
                }),
                n.dirty());
            else if (i.kind === "url")
                try {
                    new URL(e.data)
                } catch {
                    s = this._getOrReturnCtx(e, s),
                    F(s, {
                        validation: "url",
                        code: I.invalid_string,
                        message: i.message
                    }),
                    n.dirty()
                }
            else
                i.kind === "regex" ? (i.regex.lastIndex = 0,
                i.regex.test(e.data) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    validation: "regex",
                    code: I.invalid_string,
                    message: i.message
                }),
                n.dirty())) : i.kind === "trim" ? e.data = e.data.trim() : i.kind === "includes" ? e.data.includes(i.value, i.position) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    code: I.invalid_string,
                    validation: {
                        includes: i.value,
                        position: i.position
                    },
                    message: i.message
                }),
                n.dirty()) : i.kind === "toLowerCase" ? e.data = e.data.toLowerCase() : i.kind === "toUpperCase" ? e.data = e.data.toUpperCase() : i.kind === "startsWith" ? e.data.startsWith(i.value) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    code: I.invalid_string,
                    validation: {
                        startsWith: i.value
                    },
                    message: i.message
                }),
                n.dirty()) : i.kind === "endsWith" ? e.data.endsWith(i.value) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    code: I.invalid_string,
                    validation: {
                        endsWith: i.value
                    },
                    message: i.message
                }),
                n.dirty()) : i.kind === "datetime" ? B2(i).test(e.data) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    code: I.invalid_string,
                    validation: "datetime",
                    message: i.message
                }),
                n.dirty()) : i.kind === "date" ? F2.test(e.data) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    code: I.invalid_string,
                    validation: "date",
                    message: i.message
                }),
                n.dirty()) : i.kind === "time" ? U2(i).test(e.data) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    code: I.invalid_string,
                    validation: "time",
                    message: i.message
                }),
                n.dirty()) : i.kind === "duration" ? P2.test(e.data) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    validation: "duration",
                    code: I.invalid_string,
                    message: i.message
                }),
                n.dirty()) : i.kind === "ip" ? z2(e.data, i.version) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    validation: "ip",
                    code: I.invalid_string,
                    message: i.message
                }),
                n.dirty()) : i.kind === "jwt" ? V2(e.data, i.alg) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    validation: "jwt",
                    code: I.invalid_string,
                    message: i.message
                }),
                n.dirty()) : i.kind === "cidr" ? W2(e.data, i.version) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    validation: "cidr",
                    code: I.invalid_string,
                    message: i.message
                }),
                n.dirty()) : i.kind === "base64" ? D2.test(e.data) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    validation: "base64",
                    code: I.invalid_string,
                    message: i.message
                }),
                n.dirty()) : i.kind === "base64url" ? M2.test(e.data) || (s = this._getOrReturnCtx(e, s),
                F(s, {
                    validation: "base64url",
                    code: I.invalid_string,
                    message: i.message
                }),
                n.dirty()) : ye.assertNever(i);
        return {
            status: n.value,
            value: e.data
        }
    }
    _regex(e, r, n) {
        return this.refinement(s => e.test(s), {
            validation: r,
            code: I.invalid_string,
            ...H.errToObj(n)
        })
    }
    _addCheck(e) {
        return new An({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    email(e) {
        return this._addCheck({
            kind: "email",
            ...H.errToObj(e)
        })
    }
    url(e) {
        return this._addCheck({
            kind: "url",
            ...H.errToObj(e)
        })
    }
    emoji(e) {
        return this._addCheck({
            kind: "emoji",
            ...H.errToObj(e)
        })
    }
    uuid(e) {
        return this._addCheck({
            kind: "uuid",
            ...H.errToObj(e)
        })
    }
    nanoid(e) {
        return this._addCheck({
            kind: "nanoid",
            ...H.errToObj(e)
        })
    }
    cuid(e) {
        return this._addCheck({
            kind: "cuid",
            ...H.errToObj(e)
        })
    }
    cuid2(e) {
        return this._addCheck({
            kind: "cuid2",
            ...H.errToObj(e)
        })
    }
    ulid(e) {
        return this._addCheck({
            kind: "ulid",
            ...H.errToObj(e)
        })
    }
    base64(e) {
        return this._addCheck({
            kind: "base64",
            ...H.errToObj(e)
        })
    }
    base64url(e) {
        return this._addCheck({
            kind: "base64url",
            ...H.errToObj(e)
        })
    }
    jwt(e) {
        return this._addCheck({
            kind: "jwt",
            ...H.errToObj(e)
        })
    }
    ip(e) {
        return this._addCheck({
            kind: "ip",
            ...H.errToObj(e)
        })
    }
    cidr(e) {
        return this._addCheck({
            kind: "cidr",
            ...H.errToObj(e)
        })
    }
    datetime(e) {
        return typeof e == "string" ? this._addCheck({
            kind: "datetime",
            precision: null,
            offset: !1,
            local: !1,
            message: e
        }) : this._addCheck({
            kind: "datetime",
            precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
            offset: (e == null ? void 0 : e.offset) ?? !1,
            local: (e == null ? void 0 : e.local) ?? !1,
            ...H.errToObj(e == null ? void 0 : e.message)
        })
    }
    date(e) {
        return this._addCheck({
            kind: "date",
            message: e
        })
    }
    time(e) {
        return typeof e == "string" ? this._addCheck({
            kind: "time",
            precision: null,
            message: e
        }) : this._addCheck({
            kind: "time",
            precision: typeof (e == null ? void 0 : e.precision) > "u" ? null : e == null ? void 0 : e.precision,
            ...H.errToObj(e == null ? void 0 : e.message)
        })
    }
    duration(e) {
        return this._addCheck({
            kind: "duration",
            ...H.errToObj(e)
        })
    }
    regex(e, r) {
        return this._addCheck({
            kind: "regex",
            regex: e,
            ...H.errToObj(r)
        })
    }
    includes(e, r) {
        return this._addCheck({
            kind: "includes",
            value: e,
            position: r == null ? void 0 : r.position,
            ...H.errToObj(r == null ? void 0 : r.message)
        })
    }
    startsWith(e, r) {
        return this._addCheck({
            kind: "startsWith",
            value: e,
            ...H.errToObj(r)
        })
    }
    endsWith(e, r) {
        return this._addCheck({
            kind: "endsWith",
            value: e,
            ...H.errToObj(r)
        })
    }
    min(e, r) {
        return this._addCheck({
            kind: "min",
            value: e,
            ...H.errToObj(r)
        })
    }
    max(e, r) {
        return this._addCheck({
            kind: "max",
            value: e,
            ...H.errToObj(r)
        })
    }
    length(e, r) {
        return this._addCheck({
            kind: "length",
            value: e,
            ...H.errToObj(r)
        })
    }
    nonempty(e) {
        return this.min(1, H.errToObj(e))
    }
    trim() {
        return new An({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "trim"
            }]
        })
    }
    toLowerCase() {
        return new An({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toLowerCase"
            }]
        })
    }
    toUpperCase() {
        return new An({
            ...this._def,
            checks: [...this._def.checks, {
                kind: "toUpperCase"
            }]
        })
    }
    get isDatetime() {
        return !!this._def.checks.find(e => e.kind === "datetime")
    }
    get isDate() {
        return !!this._def.checks.find(e => e.kind === "date")
    }
    get isTime() {
        return !!this._def.checks.find(e => e.kind === "time")
    }
    get isDuration() {
        return !!this._def.checks.find(e => e.kind === "duration")
    }
    get isEmail() {
        return !!this._def.checks.find(e => e.kind === "email")
    }
    get isURL() {
        return !!this._def.checks.find(e => e.kind === "url")
    }
    get isEmoji() {
        return !!this._def.checks.find(e => e.kind === "emoji")
    }
    get isUUID() {
        return !!this._def.checks.find(e => e.kind === "uuid")
    }
    get isNANOID() {
        return !!this._def.checks.find(e => e.kind === "nanoid")
    }
    get isCUID() {
        return !!this._def.checks.find(e => e.kind === "cuid")
    }
    get isCUID2() {
        return !!this._def.checks.find(e => e.kind === "cuid2")
    }
    get isULID() {
        return !!this._def.checks.find(e => e.kind === "ulid")
    }
    get isIP() {
        return !!this._def.checks.find(e => e.kind === "ip")
    }
    get isCIDR() {
        return !!this._def.checks.find(e => e.kind === "cidr")
    }
    get isBase64() {
        return !!this._def.checks.find(e => e.kind === "base64")
    }
    get isBase64url() {
        return !!this._def.checks.find(e => e.kind === "base64url")
    }
    get minLength() {
        let e = null;
        for (const r of this._def.checks)
            r.kind === "min" && (e === null || r.value > e) && (e = r.value);
        return e
    }
    get maxLength() {
        let e = null;
        for (const r of this._def.checks)
            r.kind === "max" && (e === null || r.value < e) && (e = r.value);
        return e
    }
}
An.create = t => new An({
    checks: [],
    typeName: ne.ZodString,
    coerce: (t == null ? void 0 : t.coerce) ?? !1,
    ...ce(t)
});
function H2(t, e) {
    const r = (t.toString().split(".")[1] || "").length
      , n = (e.toString().split(".")[1] || "").length
      , s = r > n ? r : n
      , i = Number.parseInt(t.toFixed(s).replace(".", ""))
      , o = Number.parseInt(e.toFixed(s).replace(".", ""));
    return i % o / 10 ** s
}
class Pa extends ge {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte,
        this.step = this.multipleOf
    }
    _parse(e) {
        if (this._def.coerce && (e.data = Number(e.data)),
        this._getType(e) !== W.number) {
            const i = this._getOrReturnCtx(e);
            return F(i, {
                code: I.invalid_type,
                expected: W.number,
                received: i.parsedType
            }),
            re
        }
        let n;
        const s = new Ut;
        for (const i of this._def.checks)
            i.kind === "int" ? ye.isInteger(e.data) || (n = this._getOrReturnCtx(e, n),
            F(n, {
                code: I.invalid_type,
                expected: "integer",
                received: "float",
                message: i.message
            }),
            s.dirty()) : i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (n = this._getOrReturnCtx(e, n),
            F(n, {
                code: I.too_small,
                minimum: i.value,
                type: "number",
                inclusive: i.inclusive,
                exact: !1,
                message: i.message
            }),
            s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (n = this._getOrReturnCtx(e, n),
            F(n, {
                code: I.too_big,
                maximum: i.value,
                type: "number",
                inclusive: i.inclusive,
                exact: !1,
                message: i.message
            }),
            s.dirty()) : i.kind === "multipleOf" ? H2(e.data, i.value) !== 0 && (n = this._getOrReturnCtx(e, n),
            F(n, {
                code: I.not_multiple_of,
                multipleOf: i.value,
                message: i.message
            }),
            s.dirty()) : i.kind === "finite" ? Number.isFinite(e.data) || (n = this._getOrReturnCtx(e, n),
            F(n, {
                code: I.not_finite,
                message: i.message
            }),
            s.dirty()) : ye.assertNever(i);
        return {
            status: s.value,
            value: e.data
        }
    }
    gte(e, r) {
        return this.setLimit("min", e, !0, H.toString(r))
    }
    gt(e, r) {
        return this.setLimit("min", e, !1, H.toString(r))
    }
    lte(e, r) {
        return this.setLimit("max", e, !0, H.toString(r))
    }
    lt(e, r) {
        return this.setLimit("max", e, !1, H.toString(r))
    }
    setLimit(e, r, n, s) {
        return new Pa({
            ...this._def,
            checks: [...this._def.checks, {
                kind: e,
                value: r,
                inclusive: n,
                message: H.toString(s)
            }]
        })
    }
    _addCheck(e) {
        return new Pa({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    int(e) {
        return this._addCheck({
            kind: "int",
            message: H.toString(e)
        })
    }
    positive(e) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !1,
            message: H.toString(e)
        })
    }
    negative(e) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !1,
            message: H.toString(e)
        })
    }
    nonpositive(e) {
        return this._addCheck({
            kind: "max",
            value: 0,
            inclusive: !0,
            message: H.toString(e)
        })
    }
    nonnegative(e) {
        return this._addCheck({
            kind: "min",
            value: 0,
            inclusive: !0,
            message: H.toString(e)
        })
    }
    multipleOf(e, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: H.toString(r)
        })
    }
    finite(e) {
        return this._addCheck({
            kind: "finite",
            message: H.toString(e)
        })
    }
    safe(e) {
        return this._addCheck({
            kind: "min",
            inclusive: !0,
            value: Number.MIN_SAFE_INTEGER,
            message: H.toString(e)
        })._addCheck({
            kind: "max",
            inclusive: !0,
            value: Number.MAX_SAFE_INTEGER,
            message: H.toString(e)
        })
    }
    get minValue() {
        let e = null;
        for (const r of this._def.checks)
            r.kind === "min" && (e === null || r.value > e) && (e = r.value);
        return e
    }
    get maxValue() {
        let e = null;
        for (const r of this._def.checks)
            r.kind === "max" && (e === null || r.value < e) && (e = r.value);
        return e
    }
    get isInt() {
        return !!this._def.checks.find(e => e.kind === "int" || e.kind === "multipleOf" && ye.isInteger(e.value))
    }
    get isFinite() {
        let e = null
          , r = null;
        for (const n of this._def.checks) {
            if (n.kind === "finite" || n.kind === "int" || n.kind === "multipleOf")
                return !0;
            n.kind === "min" ? (r === null || n.value > r) && (r = n.value) : n.kind === "max" && (e === null || n.value < e) && (e = n.value)
        }
        return Number.isFinite(r) && Number.isFinite(e)
    }
}
Pa.create = t => new Pa({
    checks: [],
    typeName: ne.ZodNumber,
    coerce: (t == null ? void 0 : t.coerce) || !1,
    ...ce(t)
});
class Aa extends ge {
    constructor() {
        super(...arguments),
        this.min = this.gte,
        this.max = this.lte
    }
    _parse(e) {
        if (this._def.coerce)
            try {
                e.data = BigInt(e.data)
            } catch {
                return this._getInvalidInput(e)
            }
        if (this._getType(e) !== W.bigint)
            return this._getInvalidInput(e);
        let n;
        const s = new Ut;
        for (const i of this._def.checks)
            i.kind === "min" ? (i.inclusive ? e.data < i.value : e.data <= i.value) && (n = this._getOrReturnCtx(e, n),
            F(n, {
                code: I.too_small,
                type: "bigint",
                minimum: i.value,
                inclusive: i.inclusive,
                message: i.message
            }),
            s.dirty()) : i.kind === "max" ? (i.inclusive ? e.data > i.value : e.data >= i.value) && (n = this._getOrReturnCtx(e, n),
            F(n, {
                code: I.too_big,
                type: "bigint",
                maximum: i.value,
                inclusive: i.inclusive,
                message: i.message
            }),
            s.dirty()) : i.kind === "multipleOf" ? e.data % i.value !== BigInt(0) && (n = this._getOrReturnCtx(e, n),
            F(n, {
                code: I.not_multiple_of,
                multipleOf: i.value,
                message: i.message
            }),
            s.dirty()) : ye.assertNever(i);
        return {
            status: s.value,
            value: e.data
        }
    }
    _getInvalidInput(e) {
        const r = this._getOrReturnCtx(e);
        return F(r, {
            code: I.invalid_type,
            expected: W.bigint,
            received: r.parsedType
        }),
        re
    }
    gte(e, r) {
        return this.setLimit("min", e, !0, H.toString(r))
    }
    gt(e, r) {
        return this.setLimit("min", e, !1, H.toString(r))
    }
    lte(e, r) {
        return this.setLimit("max", e, !0, H.toString(r))
    }
    lt(e, r) {
        return this.setLimit("max", e, !1, H.toString(r))
    }
    setLimit(e, r, n, s) {
        return new Aa({
            ...this._def,
            checks: [...this._def.checks, {
                kind: e,
                value: r,
                inclusive: n,
                message: H.toString(s)
            }]
        })
    }
    _addCheck(e) {
        return new Aa({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    positive(e) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !1,
            message: H.toString(e)
        })
    }
    negative(e) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !1,
            message: H.toString(e)
        })
    }
    nonpositive(e) {
        return this._addCheck({
            kind: "max",
            value: BigInt(0),
            inclusive: !0,
            message: H.toString(e)
        })
    }
    nonnegative(e) {
        return this._addCheck({
            kind: "min",
            value: BigInt(0),
            inclusive: !0,
            message: H.toString(e)
        })
    }
    multipleOf(e, r) {
        return this._addCheck({
            kind: "multipleOf",
            value: e,
            message: H.toString(r)
        })
    }
    get minValue() {
        let e = null;
        for (const r of this._def.checks)
            r.kind === "min" && (e === null || r.value > e) && (e = r.value);
        return e
    }
    get maxValue() {
        let e = null;
        for (const r of this._def.checks)
            r.kind === "max" && (e === null || r.value < e) && (e = r.value);
        return e
    }
}
Aa.create = t => new Aa({
    checks: [],
    typeName: ne.ZodBigInt,
    coerce: (t == null ? void 0 : t.coerce) ?? !1,
    ...ce(t)
});
class Tv extends ge {
    _parse(e) {
        if (this._def.coerce && (e.data = !!e.data),
        this._getType(e) !== W.boolean) {
            const n = this._getOrReturnCtx(e);
            return F(n, {
                code: I.invalid_type,
                expected: W.boolean,
                received: n.parsedType
            }),
            re
        }
        return rr(e.data)
    }
}
Tv.create = t => new Tv({
    typeName: ne.ZodBoolean,
    coerce: (t == null ? void 0 : t.coerce) || !1,
    ...ce(t)
});
class Ic extends ge {
    _parse(e) {
        if (this._def.coerce && (e.data = new Date(e.data)),
        this._getType(e) !== W.date) {
            const i = this._getOrReturnCtx(e);
            return F(i, {
                code: I.invalid_type,
                expected: W.date,
                received: i.parsedType
            }),
            re
        }
        if (Number.isNaN(e.data.getTime())) {
            const i = this._getOrReturnCtx(e);
            return F(i, {
                code: I.invalid_date
            }),
            re
        }
        const n = new Ut;
        let s;
        for (const i of this._def.checks)
            i.kind === "min" ? e.data.getTime() < i.value && (s = this._getOrReturnCtx(e, s),
            F(s, {
                code: I.too_small,
                message: i.message,
                inclusive: !0,
                exact: !1,
                minimum: i.value,
                type: "date"
            }),
            n.dirty()) : i.kind === "max" ? e.data.getTime() > i.value && (s = this._getOrReturnCtx(e, s),
            F(s, {
                code: I.too_big,
                message: i.message,
                inclusive: !0,
                exact: !1,
                maximum: i.value,
                type: "date"
            }),
            n.dirty()) : ye.assertNever(i);
        return {
            status: n.value,
            value: new Date(e.data.getTime())
        }
    }
    _addCheck(e) {
        return new Ic({
            ...this._def,
            checks: [...this._def.checks, e]
        })
    }
    min(e, r) {
        return this._addCheck({
            kind: "min",
            value: e.getTime(),
            message: H.toString(r)
        })
    }
    max(e, r) {
        return this._addCheck({
            kind: "max",
            value: e.getTime(),
            message: H.toString(r)
        })
    }
    get minDate() {
        let e = null;
        for (const r of this._def.checks)
            r.kind === "min" && (e === null || r.value > e) && (e = r.value);
        return e != null ? new Date(e) : null
    }
    get maxDate() {
        let e = null;
        for (const r of this._def.checks)
            r.kind === "max" && (e === null || r.value < e) && (e = r.value);
        return e != null ? new Date(e) : null
    }
}
Ic.create = t => new Ic({
    checks: [],
    coerce: (t == null ? void 0 : t.coerce) || !1,
    typeName: ne.ZodDate,
    ...ce(t)
});
class Rv extends ge {
    _parse(e) {
        if (this._getType(e) !== W.symbol) {
            const n = this._getOrReturnCtx(e);
            return F(n, {
                code: I.invalid_type,
                expected: W.symbol,
                received: n.parsedType
            }),
            re
        }
        return rr(e.data)
    }
}
Rv.create = t => new Rv({
    typeName: ne.ZodSymbol,
    ...ce(t)
});
class Nv extends ge {
    _parse(e) {
        if (this._getType(e) !== W.undefined) {
            const n = this._getOrReturnCtx(e);
            return F(n, {
                code: I.invalid_type,
                expected: W.undefined,
                received: n.parsedType
            }),
            re
        }
        return rr(e.data)
    }
}
Nv.create = t => new Nv({
    typeName: ne.ZodUndefined,
    ...ce(t)
});
class Pv extends ge {
    _parse(e) {
        if (this._getType(e) !== W.null) {
            const n = this._getOrReturnCtx(e);
            return F(n, {
                code: I.invalid_type,
                expected: W.null,
                received: n.parsedType
            }),
            re
        }
        return rr(e.data)
    }
}
Pv.create = t => new Pv({
    typeName: ne.ZodNull,
    ...ce(t)
});
class Av extends ge {
    constructor() {
        super(...arguments),
        this._any = !0
    }
    _parse(e) {
        return rr(e.data)
    }
}
Av.create = t => new Av({
    typeName: ne.ZodAny,
    ...ce(t)
});
class jv extends ge {
    constructor() {
        super(...arguments),
        this._unknown = !0
    }
    _parse(e) {
        return rr(e.data)
    }
}
jv.create = t => new jv({
    typeName: ne.ZodUnknown,
    ...ce(t)
});
class Jn extends ge {
    _parse(e) {
        const r = this._getOrReturnCtx(e);
        return F(r, {
            code: I.invalid_type,
            expected: W.never,
            received: r.parsedType
        }),
        re
    }
}
Jn.create = t => new Jn({
    typeName: ne.ZodNever,
    ...ce(t)
});
class Ov extends ge {
    _parse(e) {
        if (this._getType(e) !== W.undefined) {
            const n = this._getOrReturnCtx(e);
            return F(n, {
                code: I.invalid_type,
                expected: W.void,
                received: n.parsedType
            }),
            re
        }
        return rr(e.data)
    }
}
Ov.create = t => new Ov({
    typeName: ne.ZodVoid,
    ...ce(t)
});
class Ir extends ge {
    _parse(e) {
        const {ctx: r, status: n} = this._processInputParams(e)
          , s = this._def;
        if (r.parsedType !== W.array)
            return F(r, {
                code: I.invalid_type,
                expected: W.array,
                received: r.parsedType
            }),
            re;
        if (s.exactLength !== null) {
            const o = r.data.length > s.exactLength.value
              , a = r.data.length < s.exactLength.value;
            (o || a) && (F(r, {
                code: o ? I.too_big : I.too_small,
                minimum: a ? s.exactLength.value : void 0,
                maximum: o ? s.exactLength.value : void 0,
                type: "array",
                inclusive: !0,
                exact: !0,
                message: s.exactLength.message
            }),
            n.dirty())
        }
        if (s.minLength !== null && r.data.length < s.minLength.value && (F(r, {
            code: I.too_small,
            minimum: s.minLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: s.minLength.message
        }),
        n.dirty()),
        s.maxLength !== null && r.data.length > s.maxLength.value && (F(r, {
            code: I.too_big,
            maximum: s.maxLength.value,
            type: "array",
            inclusive: !0,
            exact: !1,
            message: s.maxLength.message
        }),
        n.dirty()),
        r.common.async)
            return Promise.all([...r.data].map( (o, a) => s.type._parseAsync(new Qn(r,o,r.path,a)))).then(o => Ut.mergeArray(n, o));
        const i = [...r.data].map( (o, a) => s.type._parseSync(new Qn(r,o,r.path,a)));
        return Ut.mergeArray(n, i)
    }
    get element() {
        return this._def.type
    }
    min(e, r) {
        return new Ir({
            ...this._def,
            minLength: {
                value: e,
                message: H.toString(r)
            }
        })
    }
    max(e, r) {
        return new Ir({
            ...this._def,
            maxLength: {
                value: e,
                message: H.toString(r)
            }
        })
    }
    length(e, r) {
        return new Ir({
            ...this._def,
            exactLength: {
                value: e,
                message: H.toString(r)
            }
        })
    }
    nonempty(e) {
        return this.min(1, e)
    }
}
Ir.create = (t, e) => new Ir({
    type: t,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ne.ZodArray,
    ...ce(e)
});
function ci(t) {
    if (t instanceof ze) {
        const e = {};
        for (const r in t.shape) {
            const n = t.shape[r];
            e[r] = Vn.create(ci(n))
        }
        return new ze({
            ...t._def,
            shape: () => e
        })
    } else
        return t instanceof Ir ? new Ir({
            ...t._def,
            type: ci(t.element)
        }) : t instanceof Vn ? Vn.create(ci(t.unwrap())) : t instanceof uo ? uo.create(ci(t.unwrap())) : t instanceof $s ? $s.create(t.items.map(e => ci(e))) : t
}
class ze extends ge {
    constructor() {
        super(...arguments),
        this._cached = null,
        this.nonstrict = this.passthrough,
        this.augment = this.extend
    }
    _getCached() {
        if (this._cached !== null)
            return this._cached;
        const e = this._def.shape()
          , r = ye.objectKeys(e);
        return this._cached = {
            shape: e,
            keys: r
        },
        this._cached
    }
    _parse(e) {
        if (this._getType(e) !== W.object) {
            const c = this._getOrReturnCtx(e);
            return F(c, {
                code: I.invalid_type,
                expected: W.object,
                received: c.parsedType
            }),
            re
        }
        const {status: n, ctx: s} = this._processInputParams(e)
          , {shape: i, keys: o} = this._getCached()
          , a = [];
        if (!(this._def.catchall instanceof Jn && this._def.unknownKeys === "strip"))
            for (const c in s.data)
                o.includes(c) || a.push(c);
        const l = [];
        for (const c of o) {
            const u = i[c]
              , h = s.data[c];
            l.push({
                key: {
                    status: "valid",
                    value: c
                },
                value: u._parse(new Qn(s,h,s.path,c)),
                alwaysSet: c in s.data
            })
        }
        if (this._def.catchall instanceof Jn) {
            const c = this._def.unknownKeys;
            if (c === "passthrough")
                for (const u of a)
                    l.push({
                        key: {
                            status: "valid",
                            value: u
                        },
                        value: {
                            status: "valid",
                            value: s.data[u]
                        }
                    });
            else if (c === "strict")
                a.length > 0 && (F(s, {
                    code: I.unrecognized_keys,
                    keys: a
                }),
                n.dirty());
            else if (c !== "strip")
                throw new Error("Internal ZodObject error: invalid unknownKeys value.")
        } else {
            const c = this._def.catchall;
            for (const u of a) {
                const h = s.data[u];
                l.push({
                    key: {
                        status: "valid",
                        value: u
                    },
                    value: c._parse(new Qn(s,h,s.path,u)),
                    alwaysSet: u in s.data
                })
            }
        }
        return s.common.async ? Promise.resolve().then(async () => {
            const c = [];
            for (const u of l) {
                const h = await u.key
                  , p = await u.value;
                c.push({
                    key: h,
                    value: p,
                    alwaysSet: u.alwaysSet
                })
            }
            return c
        }
        ).then(c => Ut.mergeObjectSync(n, c)) : Ut.mergeObjectSync(n, l)
    }
    get shape() {
        return this._def.shape()
    }
    strict(e) {
        return H.errToObj,
        new ze({
            ...this._def,
            unknownKeys: "strict",
            ...e !== void 0 ? {
                errorMap: (r, n) => {
                    var i, o;
                    const s = ((o = (i = this._def).errorMap) == null ? void 0 : o.call(i, r, n).message) ?? n.defaultError;
                    return r.code === "unrecognized_keys" ? {
                        message: H.errToObj(e).message ?? s
                    } : {
                        message: s
                    }
                }
            } : {}
        })
    }
    strip() {
        return new ze({
            ...this._def,
            unknownKeys: "strip"
        })
    }
    passthrough() {
        return new ze({
            ...this._def,
            unknownKeys: "passthrough"
        })
    }
    extend(e) {
        return new ze({
            ...this._def,
            shape: () => ({
                ...this._def.shape(),
                ...e
            })
        })
    }
    merge(e) {
        return new ze({
            unknownKeys: e._def.unknownKeys,
            catchall: e._def.catchall,
            shape: () => ({
                ...this._def.shape(),
                ...e._def.shape()
            }),
            typeName: ne.ZodObject
        })
    }
    setKey(e, r) {
        return this.augment({
            [e]: r
        })
    }
    catchall(e) {
        return new ze({
            ...this._def,
            catchall: e
        })
    }
    pick(e) {
        const r = {};
        for (const n of ye.objectKeys(e))
            e[n] && this.shape[n] && (r[n] = this.shape[n]);
        return new ze({
            ...this._def,
            shape: () => r
        })
    }
    omit(e) {
        const r = {};
        for (const n of ye.objectKeys(this.shape))
            e[n] || (r[n] = this.shape[n]);
        return new ze({
            ...this._def,
            shape: () => r
        })
    }
    deepPartial() {
        return ci(this)
    }
    partial(e) {
        const r = {};
        for (const n of ye.objectKeys(this.shape)) {
            const s = this.shape[n];
            e && !e[n] ? r[n] = s : r[n] = s.optional()
        }
        return new ze({
            ...this._def,
            shape: () => r
        })
    }
    required(e) {
        const r = {};
        for (const n of ye.objectKeys(this.shape))
            if (e && !e[n])
                r[n] = this.shape[n];
            else {
                let i = this.shape[n];
                for (; i instanceof Vn; )
                    i = i._def.innerType;
                r[n] = i
            }
        return new ze({
            ...this._def,
            shape: () => r
        })
    }
    keyof() {
        return w_(ye.objectKeys(this.shape))
    }
}
ze.create = (t, e) => new ze({
    shape: () => t,
    unknownKeys: "strip",
    catchall: Jn.create(),
    typeName: ne.ZodObject,
    ...ce(e)
});
ze.strictCreate = (t, e) => new ze({
    shape: () => t,
    unknownKeys: "strict",
    catchall: Jn.create(),
    typeName: ne.ZodObject,
    ...ce(e)
});
ze.lazycreate = (t, e) => new ze({
    shape: t,
    unknownKeys: "strip",
    catchall: Jn.create(),
    typeName: ne.ZodObject,
    ...ce(e)
});
class Lc extends ge {
    _parse(e) {
        const {ctx: r} = this._processInputParams(e)
          , n = this._def.options;
        function s(i) {
            for (const a of i)
                if (a.result.status === "valid")
                    return a.result;
            for (const a of i)
                if (a.result.status === "dirty")
                    return r.common.issues.push(...a.ctx.common.issues),
                    a.result;
            const o = i.map(a => new Xr(a.ctx.common.issues));
            return F(r, {
                code: I.invalid_union,
                unionErrors: o
            }),
            re
        }
        if (r.common.async)
            return Promise.all(n.map(async i => {
                const o = {
                    ...r,
                    common: {
                        ...r.common,
                        issues: []
                    },
                    parent: null
                };
                return {
                    result: await i._parseAsync({
                        data: r.data,
                        path: r.path,
                        parent: o
                    }),
                    ctx: o
                }
            }
            )).then(s);
        {
            let i;
            const o = [];
            for (const l of n) {
                const c = {
                    ...r,
                    common: {
                        ...r.common,
                        issues: []
                    },
                    parent: null
                }
                  , u = l._parseSync({
                    data: r.data,
                    path: r.path,
                    parent: c
                });
                if (u.status === "valid")
                    return u;
                u.status === "dirty" && !i && (i = {
                    result: u,
                    ctx: c
                }),
                c.common.issues.length && o.push(c.common.issues)
            }
            if (i)
                return r.common.issues.push(...i.ctx.common.issues),
                i.result;
            const a = o.map(l => new Xr(l));
            return F(r, {
                code: I.invalid_union,
                unionErrors: a
            }),
            re
        }
    }
    get options() {
        return this._def.options
    }
}
Lc.create = (t, e) => new Lc({
    options: t,
    typeName: ne.ZodUnion,
    ...ce(e)
});
function cf(t, e) {
    const r = gn(t)
      , n = gn(e);
    if (t === e)
        return {
            valid: !0,
            data: t
        };
    if (r === W.object && n === W.object) {
        const s = ye.objectKeys(e)
          , i = ye.objectKeys(t).filter(a => s.indexOf(a) !== -1)
          , o = {
            ...t,
            ...e
        };
        for (const a of i) {
            const l = cf(t[a], e[a]);
            if (!l.valid)
                return {
                    valid: !1
                };
            o[a] = l.data
        }
        return {
            valid: !0,
            data: o
        }
    } else if (r === W.array && n === W.array) {
        if (t.length !== e.length)
            return {
                valid: !1
            };
        const s = [];
        for (let i = 0; i < t.length; i++) {
            const o = t[i]
              , a = e[i]
              , l = cf(o, a);
            if (!l.valid)
                return {
                    valid: !1
                };
            s.push(l.data)
        }
        return {
            valid: !0,
            data: s
        }
    } else
        return r === W.date && n === W.date && +t == +e ? {
            valid: !0,
            data: t
        } : {
            valid: !1
        }
}
class $c extends ge {
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e)
          , s = (i, o) => {
            if (kv(i) || kv(o))
                return re;
            const a = cf(i.value, o.value);
            return a.valid ? ((Ev(i) || Ev(o)) && r.dirty(),
            {
                status: r.value,
                value: a.data
            }) : (F(n, {
                code: I.invalid_intersection_types
            }),
            re)
        }
        ;
        return n.common.async ? Promise.all([this._def.left._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        }), this._def.right._parseAsync({
            data: n.data,
            path: n.path,
            parent: n
        })]).then( ([i,o]) => s(i, o)) : s(this._def.left._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }), this._def.right._parseSync({
            data: n.data,
            path: n.path,
            parent: n
        }))
    }
}
$c.create = (t, e, r) => new $c({
    left: t,
    right: e,
    typeName: ne.ZodIntersection,
    ...ce(r)
});
class $s extends ge {
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e);
        if (n.parsedType !== W.array)
            return F(n, {
                code: I.invalid_type,
                expected: W.array,
                received: n.parsedType
            }),
            re;
        if (n.data.length < this._def.items.length)
            return F(n, {
                code: I.too_small,
                minimum: this._def.items.length,
                inclusive: !0,
                exact: !1,
                type: "array"
            }),
            re;
        !this._def.rest && n.data.length > this._def.items.length && (F(n, {
            code: I.too_big,
            maximum: this._def.items.length,
            inclusive: !0,
            exact: !1,
            type: "array"
        }),
        r.dirty());
        const i = [...n.data].map( (o, a) => {
            const l = this._def.items[a] || this._def.rest;
            return l ? l._parse(new Qn(n,o,n.path,a)) : null
        }
        ).filter(o => !!o);
        return n.common.async ? Promise.all(i).then(o => Ut.mergeArray(r, o)) : Ut.mergeArray(r, i)
    }
    get items() {
        return this._def.items
    }
    rest(e) {
        return new $s({
            ...this._def,
            rest: e
        })
    }
}
$s.create = (t, e) => {
    if (!Array.isArray(t))
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
    return new $s({
        items: t,
        typeName: ne.ZodTuple,
        rest: null,
        ...ce(e)
    })
}
;
class Iv extends ge {
    get keySchema() {
        return this._def.keyType
    }
    get valueSchema() {
        return this._def.valueType
    }
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e);
        if (n.parsedType !== W.map)
            return F(n, {
                code: I.invalid_type,
                expected: W.map,
                received: n.parsedType
            }),
            re;
        const s = this._def.keyType
          , i = this._def.valueType
          , o = [...n.data.entries()].map( ([a,l], c) => ({
            key: s._parse(new Qn(n,a,n.path,[c, "key"])),
            value: i._parse(new Qn(n,l,n.path,[c, "value"]))
        }));
        if (n.common.async) {
            const a = new Map;
            return Promise.resolve().then(async () => {
                for (const l of o) {
                    const c = await l.key
                      , u = await l.value;
                    if (c.status === "aborted" || u.status === "aborted")
                        return re;
                    (c.status === "dirty" || u.status === "dirty") && r.dirty(),
                    a.set(c.value, u.value)
                }
                return {
                    status: r.value,
                    value: a
                }
            }
            )
        } else {
            const a = new Map;
            for (const l of o) {
                const c = l.key
                  , u = l.value;
                if (c.status === "aborted" || u.status === "aborted")
                    return re;
                (c.status === "dirty" || u.status === "dirty") && r.dirty(),
                a.set(c.value, u.value)
            }
            return {
                status: r.value,
                value: a
            }
        }
    }
}
Iv.create = (t, e, r) => new Iv({
    valueType: e,
    keyType: t,
    typeName: ne.ZodMap,
    ...ce(r)
});
class ja extends ge {
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e);
        if (n.parsedType !== W.set)
            return F(n, {
                code: I.invalid_type,
                expected: W.set,
                received: n.parsedType
            }),
            re;
        const s = this._def;
        s.minSize !== null && n.data.size < s.minSize.value && (F(n, {
            code: I.too_small,
            minimum: s.minSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: s.minSize.message
        }),
        r.dirty()),
        s.maxSize !== null && n.data.size > s.maxSize.value && (F(n, {
            code: I.too_big,
            maximum: s.maxSize.value,
            type: "set",
            inclusive: !0,
            exact: !1,
            message: s.maxSize.message
        }),
        r.dirty());
        const i = this._def.valueType;
        function o(l) {
            const c = new Set;
            for (const u of l) {
                if (u.status === "aborted")
                    return re;
                u.status === "dirty" && r.dirty(),
                c.add(u.value)
            }
            return {
                status: r.value,
                value: c
            }
        }
        const a = [...n.data.values()].map( (l, c) => i._parse(new Qn(n,l,n.path,c)));
        return n.common.async ? Promise.all(a).then(l => o(l)) : o(a)
    }
    min(e, r) {
        return new ja({
            ...this._def,
            minSize: {
                value: e,
                message: H.toString(r)
            }
        })
    }
    max(e, r) {
        return new ja({
            ...this._def,
            maxSize: {
                value: e,
                message: H.toString(r)
            }
        })
    }
    size(e, r) {
        return this.min(e, r).max(e, r)
    }
    nonempty(e) {
        return this.min(1, e)
    }
}
ja.create = (t, e) => new ja({
    valueType: t,
    minSize: null,
    maxSize: null,
    typeName: ne.ZodSet,
    ...ce(e)
});
class Lv extends ge {
    get schema() {
        return this._def.getter()
    }
    _parse(e) {
        const {ctx: r} = this._processInputParams(e);
        return this._def.getter()._parse({
            data: r.data,
            path: r.path,
            parent: r
        })
    }
}
Lv.create = (t, e) => new Lv({
    getter: t,
    typeName: ne.ZodLazy,
    ...ce(e)
});
class $v extends ge {
    _parse(e) {
        if (e.data !== this._def.value) {
            const r = this._getOrReturnCtx(e);
            return F(r, {
                received: r.data,
                code: I.invalid_literal,
                expected: this._def.value
            }),
            re
        }
        return {
            status: "valid",
            value: e.data
        }
    }
    get value() {
        return this._def.value
    }
}
$v.create = (t, e) => new $v({
    value: t,
    typeName: ne.ZodLiteral,
    ...ce(e)
});
function w_(t, e) {
    return new lo({
        values: t,
        typeName: ne.ZodEnum,
        ...ce(e)
    })
}
class lo extends ge {
    _parse(e) {
        if (typeof e.data != "string") {
            const r = this._getOrReturnCtx(e)
              , n = this._def.values;
            return F(r, {
                expected: ye.joinValues(n),
                received: r.parsedType,
                code: I.invalid_type
            }),
            re
        }
        if (this._cache || (this._cache = new Set(this._def.values)),
        !this._cache.has(e.data)) {
            const r = this._getOrReturnCtx(e)
              , n = this._def.values;
            return F(r, {
                received: r.data,
                code: I.invalid_enum_value,
                options: n
            }),
            re
        }
        return rr(e.data)
    }
    get options() {
        return this._def.values
    }
    get enum() {
        const e = {};
        for (const r of this._def.values)
            e[r] = r;
        return e
    }
    get Values() {
        const e = {};
        for (const r of this._def.values)
            e[r] = r;
        return e
    }
    get Enum() {
        const e = {};
        for (const r of this._def.values)
            e[r] = r;
        return e
    }
    extract(e, r=this._def) {
        return lo.create(e, {
            ...this._def,
            ...r
        })
    }
    exclude(e, r=this._def) {
        return lo.create(this.options.filter(n => !e.includes(n)), {
            ...this._def,
            ...r
        })
    }
}
lo.create = w_;
class Dv extends ge {
    _parse(e) {
        const r = ye.getValidEnumValues(this._def.values)
          , n = this._getOrReturnCtx(e);
        if (n.parsedType !== W.string && n.parsedType !== W.number) {
            const s = ye.objectValues(r);
            return F(n, {
                expected: ye.joinValues(s),
                received: n.parsedType,
                code: I.invalid_type
            }),
            re
        }
        if (this._cache || (this._cache = new Set(ye.getValidEnumValues(this._def.values))),
        !this._cache.has(e.data)) {
            const s = ye.objectValues(r);
            return F(n, {
                received: n.data,
                code: I.invalid_enum_value,
                options: s
            }),
            re
        }
        return rr(e.data)
    }
    get enum() {
        return this._def.values
    }
}
Dv.create = (t, e) => new Dv({
    values: t,
    typeName: ne.ZodNativeEnum,
    ...ce(e)
});
class Dc extends ge {
    unwrap() {
        return this._def.type
    }
    _parse(e) {
        const {ctx: r} = this._processInputParams(e);
        if (r.parsedType !== W.promise && r.common.async === !1)
            return F(r, {
                code: I.invalid_type,
                expected: W.promise,
                received: r.parsedType
            }),
            re;
        const n = r.parsedType === W.promise ? r.data : Promise.resolve(r.data);
        return rr(n.then(s => this._def.type.parseAsync(s, {
            path: r.path,
            errorMap: r.common.contextualErrorMap
        })))
    }
}
Dc.create = (t, e) => new Dc({
    type: t,
    typeName: ne.ZodPromise,
    ...ce(e)
});
class co extends ge {
    innerType() {
        return this._def.schema
    }
    sourceType() {
        return this._def.schema._def.typeName === ne.ZodEffects ? this._def.schema.sourceType() : this._def.schema
    }
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e)
          , s = this._def.effect || null
          , i = {
            addIssue: o => {
                F(n, o),
                o.fatal ? r.abort() : r.dirty()
            }
            ,
            get path() {
                return n.path
            }
        };
        if (i.addIssue = i.addIssue.bind(i),
        s.type === "preprocess") {
            const o = s.transform(n.data, i);
            if (n.common.async)
                return Promise.resolve(o).then(async a => {
                    if (r.value === "aborted")
                        return re;
                    const l = await this._def.schema._parseAsync({
                        data: a,
                        path: n.path,
                        parent: n
                    });
                    return l.status === "aborted" ? re : l.status === "dirty" || r.value === "dirty" ? Uo(l.value) : l
                }
                );
            {
                if (r.value === "aborted")
                    return re;
                const a = this._def.schema._parseSync({
                    data: o,
                    path: n.path,
                    parent: n
                });
                return a.status === "aborted" ? re : a.status === "dirty" || r.value === "dirty" ? Uo(a.value) : a
            }
        }
        if (s.type === "refinement") {
            const o = a => {
                const l = s.refinement(a, i);
                if (n.common.async)
                    return Promise.resolve(l);
                if (l instanceof Promise)
                    throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
                return a
            }
            ;
            if (n.common.async === !1) {
                const a = this._def.schema._parseSync({
                    data: n.data,
                    path: n.path,
                    parent: n
                });
                return a.status === "aborted" ? re : (a.status === "dirty" && r.dirty(),
                o(a.value),
                {
                    status: r.value,
                    value: a.value
                })
            } else
                return this._def.schema._parseAsync({
                    data: n.data,
                    path: n.path,
                    parent: n
                }).then(a => a.status === "aborted" ? re : (a.status === "dirty" && r.dirty(),
                o(a.value).then( () => ({
                    status: r.value,
                    value: a.value
                }))))
        }
        if (s.type === "transform")
            if (n.common.async === !1) {
                const o = this._def.schema._parseSync({
                    data: n.data,
                    path: n.path,
                    parent: n
                });
                if (!ao(o))
                    return re;
                const a = s.transform(o.value, i);
                if (a instanceof Promise)
                    throw new Error("Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.");
                return {
                    status: r.value,
                    value: a
                }
            } else
                return this._def.schema._parseAsync({
                    data: n.data,
                    path: n.path,
                    parent: n
                }).then(o => ao(o) ? Promise.resolve(s.transform(o.value, i)).then(a => ({
                    status: r.value,
                    value: a
                })) : re);
        ye.assertNever(s)
    }
}
co.create = (t, e, r) => new co({
    schema: t,
    typeName: ne.ZodEffects,
    effect: e,
    ...ce(r)
});
co.createWithPreprocess = (t, e, r) => new co({
    schema: e,
    effect: {
        type: "preprocess",
        transform: t
    },
    typeName: ne.ZodEffects,
    ...ce(r)
});
class Vn extends ge {
    _parse(e) {
        return this._getType(e) === W.undefined ? rr(void 0) : this._def.innerType._parse(e)
    }
    unwrap() {
        return this._def.innerType
    }
}
Vn.create = (t, e) => new Vn({
    innerType: t,
    typeName: ne.ZodOptional,
    ...ce(e)
});
class uo extends ge {
    _parse(e) {
        return this._getType(e) === W.null ? rr(null) : this._def.innerType._parse(e)
    }
    unwrap() {
        return this._def.innerType
    }
}
uo.create = (t, e) => new uo({
    innerType: t,
    typeName: ne.ZodNullable,
    ...ce(e)
});
class uf extends ge {
    _parse(e) {
        const {ctx: r} = this._processInputParams(e);
        let n = r.data;
        return r.parsedType === W.undefined && (n = this._def.defaultValue()),
        this._def.innerType._parse({
            data: n,
            path: r.path,
            parent: r
        })
    }
    removeDefault() {
        return this._def.innerType
    }
}
uf.create = (t, e) => new uf({
    innerType: t,
    typeName: ne.ZodDefault,
    defaultValue: typeof e.default == "function" ? e.default : () => e.default,
    ...ce(e)
});
class df extends ge {
    _parse(e) {
        const {ctx: r} = this._processInputParams(e)
          , n = {
            ...r,
            common: {
                ...r.common,
                issues: []
            }
        }
          , s = this._def.innerType._parse({
            data: n.data,
            path: n.path,
            parent: {
                ...n
            }
        });
        return Oc(s) ? s.then(i => ({
            status: "valid",
            value: i.status === "valid" ? i.value : this._def.catchValue({
                get error() {
                    return new Xr(n.common.issues)
                },
                input: n.data
            })
        })) : {
            status: "valid",
            value: s.status === "valid" ? s.value : this._def.catchValue({
                get error() {
                    return new Xr(n.common.issues)
                },
                input: n.data
            })
        }
    }
    removeCatch() {
        return this._def.innerType
    }
}
df.create = (t, e) => new df({
    innerType: t,
    typeName: ne.ZodCatch,
    catchValue: typeof e.catch == "function" ? e.catch : () => e.catch,
    ...ce(e)
});
class Mv extends ge {
    _parse(e) {
        if (this._getType(e) !== W.nan) {
            const n = this._getOrReturnCtx(e);
            return F(n, {
                code: I.invalid_type,
                expected: W.nan,
                received: n.parsedType
            }),
            re
        }
        return {
            status: "valid",
            value: e.data
        }
    }
}
Mv.create = t => new Mv({
    typeName: ne.ZodNaN,
    ...ce(t)
});
class K2 extends ge {
    _parse(e) {
        const {ctx: r} = this._processInputParams(e)
          , n = r.data;
        return this._def.type._parse({
            data: n,
            path: r.path,
            parent: r
        })
    }
    unwrap() {
        return this._def.type
    }
}
class Qp extends ge {
    _parse(e) {
        const {status: r, ctx: n} = this._processInputParams(e);
        if (n.common.async)
            return (async () => {
                const i = await this._def.in._parseAsync({
                    data: n.data,
                    path: n.path,
                    parent: n
                });
                return i.status === "aborted" ? re : i.status === "dirty" ? (r.dirty(),
                Uo(i.value)) : this._def.out._parseAsync({
                    data: i.value,
                    path: n.path,
                    parent: n
                })
            }
            )();
        {
            const s = this._def.in._parseSync({
                data: n.data,
                path: n.path,
                parent: n
            });
            return s.status === "aborted" ? re : s.status === "dirty" ? (r.dirty(),
            {
                status: "dirty",
                value: s.value
            }) : this._def.out._parseSync({
                data: s.value,
                path: n.path,
                parent: n
            })
        }
    }
    static create(e, r) {
        return new Qp({
            in: e,
            out: r,
            typeName: ne.ZodPipeline
        })
    }
}
class hf extends ge {
    _parse(e) {
        const r = this._def.innerType._parse(e)
          , n = s => (ao(s) && (s.value = Object.freeze(s.value)),
        s);
        return Oc(r) ? r.then(s => n(s)) : n(r)
    }
    unwrap() {
        return this._def.innerType
    }
}
hf.create = (t, e) => new hf({
    innerType: t,
    typeName: ne.ZodReadonly,
    ...ce(e)
});
ze.lazycreate;
var ne;
(function(t) {
    t.ZodString = "ZodString",
    t.ZodNumber = "ZodNumber",
    t.ZodNaN = "ZodNaN",
    t.ZodBigInt = "ZodBigInt",
    t.ZodBoolean = "ZodBoolean",
    t.ZodDate = "ZodDate",
    t.ZodSymbol = "ZodSymbol",
    t.ZodUndefined = "ZodUndefined",
    t.ZodNull = "ZodNull",
    t.ZodAny = "ZodAny",
    t.ZodUnknown = "ZodUnknown",
    t.ZodNever = "ZodNever",
    t.ZodVoid = "ZodVoid",
    t.ZodArray = "ZodArray",
    t.ZodObject = "ZodObject",
    t.ZodUnion = "ZodUnion",
    t.ZodDiscriminatedUnion = "ZodDiscriminatedUnion",
    t.ZodIntersection = "ZodIntersection",
    t.ZodTuple = "ZodTuple",
    t.ZodRecord = "ZodRecord",
    t.ZodMap = "ZodMap",
    t.ZodSet = "ZodSet",
    t.ZodFunction = "ZodFunction",
    t.ZodLazy = "ZodLazy",
    t.ZodLiteral = "ZodLiteral",
    t.ZodEnum = "ZodEnum",
    t.ZodEffects = "ZodEffects",
    t.ZodNativeEnum = "ZodNativeEnum",
    t.ZodOptional = "ZodOptional",
    t.ZodNullable = "ZodNullable",
    t.ZodDefault = "ZodDefault",
    t.ZodCatch = "ZodCatch",
    t.ZodPromise = "ZodPromise",
    t.ZodBranded = "ZodBranded",
    t.ZodPipeline = "ZodPipeline",
    t.ZodReadonly = "ZodReadonly"
}
)(ne || (ne = {}));
const Fv = An.create;
Jn.create;
Ir.create;
const q2 = ze.create;
ze.strictCreate;
Lc.create;
$c.create;
$s.create;
lo.create;
Dc.create;
Vn.create;
uo.create;
const Uv = q2({
    email: Fv().email("Invalid email address"),
    password: Fv().min(6, "Password must be at least 6 characters")
})
  , G2 = () => {
    const t = Ga()
      , [e,r] = y.useState("")
      , [n,s] = y.useState("")
      , [i,o] = y.useState(!1)
      , [a,l] = y.useState(!0);
    y.useEffect( () => {
        const {data: {subscription: h}} = gt.auth.onAuthStateChange( (p, f) => {
            f && t("/admin"),
            l(!1)
        }
        );
        return gt.auth.getSession().then( ({data: {session: p}}) => {
            p && t("/admin"),
            l(!1)
        }
        ),
        () => h.unsubscribe()
    }
    , [t]);
    const c = async h => {
        h.preventDefault();
        const p = Uv.safeParse({
            email: e,
            password: n
        });
        if (!p.success) {
            St.error(p.error.errors[0].message);
            return
        }
        o(!0);
        const {error: f} = await gt.auth.signInWithPassword({
            email: e,
            password: n
        });
        f ? St.error(f.message) : St.success("Signed in successfully"),
        o(!1)
    }
      , u = async h => {
        h.preventDefault();
        const p = Uv.safeParse({
            email: e,
            password: n
        });
        if (!p.success) {
            St.error(p.error.errors[0].message);
            return
        }
        o(!0);
        const {error: f} = await gt.auth.signUp({
            email: e,
            password: n,
            options: {
                emailRedirectTo: `${window.location.origin}/admin`
            }
        });
        f ? f.message.includes("already registered") ? St.error("Email already registered. Please sign in.") : St.error(f.message) : St.success("Account created! You can now sign in."),
        o(!1)
    }
    ;
    return a ? d.jsx("div", {
        className: "min-h-screen bg-background flex items-center justify-center",
        children: d.jsx(Un, {
            className: "w-8 h-8 text-primary animate-spin"
        })
    }) : d.jsxs("div", {
        className: "min-h-screen bg-background flex flex-col items-center justify-center p-4",
        children: [d.jsx("div", {
            className: "absolute inset-0 bg-[radial-gradient(ellipse_at_top,hsl(var(--primary)/0.1),transparent_50%)]"
        }), d.jsxs("div", {
            className: "relative z-10 w-full max-w-md",
            children: [d.jsxs(Ye, {
                variant: "ghost",
                className: "mb-4",
                onClick: () => t("/"),
                children: [d.jsx(Yw, {
                    className: "w-4 h-4 mr-2"
                }), "Back to Home"]
            }), d.jsxs(jt, {
                className: "glass border-border/50",
                children: [d.jsxs(Jt, {
                    className: "text-center",
                    children: [d.jsx("div", {
                        className: "mx-auto mb-4 w-16 h-16 rounded-2xl bg-primary/10 border border-primary/20 flex items-center justify-center",
                        children: d.jsx(Wa, {
                            className: "w-8 h-8 text-primary"
                        })
                    }), d.jsx(Zt, {
                        className: "text-2xl font-heading",
                        children: "Admin Access"
                    }), d.jsx(oo, {
                        children: "Sign in to manage Perplex Hub"
                    })]
                }), d.jsx(Ot, {
                    children: d.jsxs(g_, {
                        defaultValue: "signin",
                        children: [d.jsxs(Gp, {
                            className: "grid w-full grid-cols-2 mb-6",
                            children: [d.jsx(Li, {
                                value: "signin",
                                children: "Sign In"
                            }), d.jsx(Li, {
                                value: "signup",
                                children: "Sign Up"
                            })]
                        }), d.jsx($i, {
                            value: "signin",
                            children: d.jsxs("form", {
                                onSubmit: c,
                                className: "space-y-4",
                                children: [d.jsxs("div", {
                                    className: "space-y-2",
                                    children: [d.jsx(Hr, {
                                        htmlFor: "email",
                                        children: "Email"
                                    }), d.jsx(ki, {
                                        id: "email",
                                        type: "email",
                                        placeholder: "admin@perplexhub.online",
                                        value: e,
                                        onChange: h => r(h.target.value),
                                        required: !0
                                    })]
                                }), d.jsxs("div", {
                                    className: "space-y-2",
                                    children: [d.jsx(Hr, {
                                        htmlFor: "password",
                                        children: "Password"
                                    }), d.jsx(ki, {
                                        id: "password",
                                        type: "password",
                                        placeholder: "",
                                        value: n,
                                        onChange: h => s(h.target.value),
                                        required: !0
                                    })]
                                }), d.jsx(Ye, {
                                    type: "submit",
                                    className: "w-full",
                                    variant: "glow",
                                    disabled: i,
                                    children: i ? d.jsx(Un, {
                                        className: "w-4 h-4 animate-spin"
                                    }) : "Sign In"
                                })]
                            })
                        }), d.jsx($i, {
                            value: "signup",
                            children: d.jsxs("form", {
                                onSubmit: u,
                                className: "space-y-4",
                                children: [d.jsxs("div", {
                                    className: "space-y-2",
                                    children: [d.jsx(Hr, {
                                        htmlFor: "signup-email",
                                        children: "Email"
                                    }), d.jsx(ki, {
                                        id: "signup-email",
                                        type: "email",
                                        placeholder: "admin@perplexhub.online",
                                        value: e,
                                        onChange: h => r(h.target.value),
                                        required: !0
                                    })]
                                }), d.jsxs("div", {
                                    className: "space-y-2",
                                    children: [d.jsx(Hr, {
                                        htmlFor: "signup-password",
                                        children: "Password"
                                    }), d.jsx(ki, {
                                        id: "signup-password",
                                        type: "password",
                                        placeholder: "",
                                        value: n,
                                        onChange: h => s(h.target.value),
                                        required: !0
                                    })]
                                }), d.jsx(Ye, {
                                    type: "submit",
                                    className: "w-full",
                                    variant: "glow",
                                    disabled: i,
                                    children: i ? d.jsx(Un, {
                                        className: "w-4 h-4 animate-spin"
                                    }) : "Create Account"
                                })]
                            })
                        })]
                    })
                })]
            })]
        })]
    })
}
  , ff = y.forwardRef( ({className: t, ...e}, r) => d.jsx("textarea", {
    className: me("flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50", t),
    ref: r,
    ...e
}));
ff.displayName = "Textarea";
function Bv(t, [e,r]) {
    return Math.min(r, Math.max(e, t))
}
var bd = 0;
function Q2() {
    y.useEffect( () => {
        const t = document.querySelectorAll("[data-radix-focus-guard]");
        return document.body.insertAdjacentElement("afterbegin", t[0] ?? zv()),
        document.body.insertAdjacentElement("beforeend", t[1] ?? zv()),
        bd++,
        () => {
            bd === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach(e => e.remove()),
            bd--
        }
    }
    , [])
}
function zv() {
    const t = document.createElement("span");
    return t.setAttribute("data-radix-focus-guard", ""),
    t.tabIndex = 0,
    t.style.outline = "none",
    t.style.opacity = "0",
    t.style.position = "fixed",
    t.style.pointerEvents = "none",
    t
}
var _d = "focusScope.autoFocusOnMount"
  , Sd = "focusScope.autoFocusOnUnmount"
  , Vv = {
    bubbles: !1,
    cancelable: !0
}
  , J2 = "FocusScope"
  , x_ = y.forwardRef( (t, e) => {
    const {loop: r=!1, trapped: n=!1, onMountAutoFocus: s, onUnmountAutoFocus: i, ...o} = t
      , [a,l] = y.useState(null)
      , c = tr(s)
      , u = tr(i)
      , h = y.useRef(null)
      , p = Ae(e, m => l(m))
      , f = y.useRef({
        paused: !1,
        pause() {
            this.paused = !0
        },
        resume() {
            this.paused = !1
        }
    }).current;
    y.useEffect( () => {
        if (n) {
            let m = function(v) {
                if (f.paused || !a)
                    return;
                const _ = v.target;
                a.contains(_) ? h.current = _ : hn(h.current, {
                    select: !0
                })
            }
              , x = function(v) {
                if (f.paused || !a)
                    return;
                const _ = v.relatedTarget;
                _ !== null && (a.contains(_) || hn(h.current, {
                    select: !0
                }))
            }
              , w = function(v) {
                if (document.activeElement === document.body)
                    for (const S of v)
                        S.removedNodes.length > 0 && hn(a)
            };
            document.addEventListener("focusin", m),
            document.addEventListener("focusout", x);
            const g = new MutationObserver(w);
            return a && g.observe(a, {
                childList: !0,
                subtree: !0
            }),
            () => {
                document.removeEventListener("focusin", m),
                document.removeEventListener("focusout", x),
                g.disconnect()
            }
        }
    }
    , [n, a, f.paused]),
    y.useEffect( () => {
        if (a) {
            Hv.add(f);
            const m = document.activeElement;
            if (!a.contains(m)) {
                const w = new CustomEvent(_d,Vv);
                a.addEventListener(_d, c),
                a.dispatchEvent(w),
                w.defaultPrevented || (Z2(rI(b_(a)), {
                    select: !0
                }),
                document.activeElement === m && hn(a))
            }
            return () => {
                a.removeEventListener(_d, c),
                setTimeout( () => {
                    const w = new CustomEvent(Sd,Vv);
                    a.addEventListener(Sd, u),
                    a.dispatchEvent(w),
                    w.defaultPrevented || hn(m ?? document.body, {
                        select: !0
                    }),
                    a.removeEventListener(Sd, u),
                    Hv.remove(f)
                }
                , 0)
            }
        }
    }
    , [a, c, u, f]);
    const b = y.useCallback(m => {
        if (!r && !n || f.paused)
            return;
        const x = m.key === "Tab" && !m.altKey && !m.ctrlKey && !m.metaKey
          , w = document.activeElement;
        if (x && w) {
            const g = m.currentTarget
              , [v,_] = Y2(g);
            v && _ ? !m.shiftKey && w === _ ? (m.preventDefault(),
            r && hn(v, {
                select: !0
            })) : m.shiftKey && w === v && (m.preventDefault(),
            r && hn(_, {
                select: !0
            })) : w === g && m.preventDefault()
        }
    }
    , [r, n, f.paused]);
    return d.jsx(le.div, {
        tabIndex: -1,
        ...o,
        ref: p,
        onKeyDown: b
    })
}
);
x_.displayName = J2;
function Z2(t, {select: e=!1}={}) {
    const r = document.activeElement;
    for (const n of t)
        if (hn(n, {
            select: e
        }),
        document.activeElement !== r)
            return
}
function Y2(t) {
    const e = b_(t)
      , r = Wv(e, t)
      , n = Wv(e.reverse(), t);
    return [r, n]
}
function b_(t) {
    const e = []
      , r = document.createTreeWalker(t, NodeFilter.SHOW_ELEMENT, {
        acceptNode: n => {
            const s = n.tagName === "INPUT" && n.type === "hidden";
            return n.disabled || n.hidden || s ? NodeFilter.FILTER_SKIP : n.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP
        }
    });
    for (; r.nextNode(); )
        e.push(r.currentNode);
    return e
}
function Wv(t, e) {
    for (const r of t)
        if (!X2(r, {
            upTo: e
        }))
            return r
}
function X2(t, {upTo: e}) {
    if (getComputedStyle(t).visibility === "hidden")
        return !0;
    for (; t; ) {
        if (e !== void 0 && t === e)
            return !1;
        if (getComputedStyle(t).display === "none")
            return !0;
        t = t.parentElement
    }
    return !1
}
function eI(t) {
    return t instanceof HTMLInputElement && "select"in t
}
function hn(t, {select: e=!1}={}) {
    if (t && t.focus) {
        const r = document.activeElement;
        t.focus({
            preventScroll: !0
        }),
        t !== r && eI(t) && e && t.select()
    }
}
var Hv = tI();
function tI() {
    let t = [];
    return {
        add(e) {
            const r = t[0];
            e !== r && (r == null || r.pause()),
            t = Kv(t, e),
            t.unshift(e)
        },
        remove(e) {
            var r;
            t = Kv(t, e),
            (r = t[0]) == null || r.resume()
        }
    }
}
function Kv(t, e) {
    const r = [...t]
      , n = r.indexOf(e);
    return n !== -1 && r.splice(n, 1),
    r
}
function rI(t) {
    return t.filter(e => e.tagName !== "A")
}
function nI(t) {
    const e = y.useRef({
        value: t,
        previous: t
    });
    return y.useMemo( () => (e.current.value !== t && (e.current.previous = e.current.value,
    e.current.value = t),
    e.current.previous), [t])
}
var sI = function(t) {
    if (typeof document > "u")
        return null;
    var e = Array.isArray(t) ? t[0] : t;
    return e.ownerDocument.body
}
  , ri = new WeakMap
  , El = new WeakMap
  , Cl = {}
  , kd = 0
  , __ = function(t) {
    return t && (t.host || __(t.parentNode))
}
  , iI = function(t, e) {
    return e.map(function(r) {
        if (t.contains(r))
            return r;
        var n = __(r);
        return n && t.contains(n) ? n : (console.error("aria-hidden", r, "in not contained inside", t, ". Doing nothing"),
        null)
    }).filter(function(r) {
        return !!r
    })
}
  , oI = function(t, e, r, n) {
    var s = iI(e, Array.isArray(t) ? t : [t]);
    Cl[r] || (Cl[r] = new WeakMap);
    var i = Cl[r]
      , o = []
      , a = new Set
      , l = new Set(s)
      , c = function(h) {
        !h || a.has(h) || (a.add(h),
        c(h.parentNode))
    };
    s.forEach(c);
    var u = function(h) {
        !h || l.has(h) || Array.prototype.forEach.call(h.children, function(p) {
            if (a.has(p))
                u(p);
            else
                try {
                    var f = p.getAttribute(n)
                      , b = f !== null && f !== "false"
                      , m = (ri.get(p) || 0) + 1
                      , x = (i.get(p) || 0) + 1;
                    ri.set(p, m),
                    i.set(p, x),
                    o.push(p),
                    m === 1 && b && El.set(p, !0),
                    x === 1 && p.setAttribute(r, "true"),
                    b || p.setAttribute(n, "true")
                } catch (w) {
                    console.error("aria-hidden: cannot operate on ", p, w)
                }
        })
    };
    return u(e),
    a.clear(),
    kd++,
    function() {
        o.forEach(function(h) {
            var p = ri.get(h) - 1
              , f = i.get(h) - 1;
            ri.set(h, p),
            i.set(h, f),
            p || (El.has(h) || h.removeAttribute(n),
            El.delete(h)),
            f || h.removeAttribute(r)
        }),
        kd--,
        kd || (ri = new WeakMap,
        ri = new WeakMap,
        El = new WeakMap,
        Cl = {})
    }
}
  , aI = function(t, e, r) {
    r === void 0 && (r = "data-aria-hidden");
    var n = Array.from(Array.isArray(t) ? t : [t])
      , s = sI(t);
    return s ? (n.push.apply(n, Array.from(s.querySelectorAll("[aria-live]"))),
    oI(n, s, r, "aria-hidden")) : function() {
        return null
    }
}
  , Kl = "right-scroll-bar-position"
  , ql = "width-before-scroll-bar"
  , lI = "with-scroll-bars-hidden"
  , cI = "--removed-body-scroll-bar-size";
function Ed(t, e) {
    return typeof t == "function" ? t(e) : t && (t.current = e),
    t
}
function uI(t, e) {
    var r = y.useState(function() {
        return {
            value: t,
            callback: e,
            facade: {
                get current() {
                    return r.value
                },
                set current(n) {
                    var s = r.value;
                    s !== n && (r.value = n,
                    r.callback(n, s))
                }
            }
        }
    })[0];
    return r.callback = e,
    r.facade
}
var dI = typeof window < "u" ? y.useLayoutEffect : y.useEffect
  , qv = new WeakMap;
function hI(t, e) {
    var r = uI(null, function(n) {
        return t.forEach(function(s) {
            return Ed(s, n)
        })
    });
    return dI(function() {
        var n = qv.get(r);
        if (n) {
            var s = new Set(n)
              , i = new Set(t)
              , o = r.current;
            s.forEach(function(a) {
                i.has(a) || Ed(a, null)
            }),
            i.forEach(function(a) {
                s.has(a) || Ed(a, o)
            })
        }
        qv.set(r, t)
    }, [t]),
    r
}
function fI(t) {
    return t
}
function pI(t, e) {
    e === void 0 && (e = fI);
    var r = []
      , n = !1
      , s = {
        read: function() {
            if (n)
                throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
            return r.length ? r[r.length - 1] : t
        },
        useMedium: function(i) {
            var o = e(i, n);
            return r.push(o),
            function() {
                r = r.filter(function(a) {
                    return a !== o
                })
            }
        },
        assignSyncMedium: function(i) {
            for (n = !0; r.length; ) {
                var o = r;
                r = [],
                o.forEach(i)
            }
            r = {
                push: function(a) {
                    return i(a)
                },
                filter: function() {
                    return r
                }
            }
        },
        assignMedium: function(i) {
            n = !0;
            var o = [];
            if (r.length) {
                var a = r;
                r = [],
                a.forEach(i),
                o = r
            }
            var l = function() {
                var u = o;
                o = [],
                u.forEach(i)
            }
              , c = function() {
                return Promise.resolve().then(l)
            };
            c(),
            r = {
                push: function(u) {
                    o.push(u),
                    c()
                },
                filter: function(u) {
                    return o = o.filter(u),
                    r
                }
            }
        }
    };
    return s
}
function mI(t) {
    t === void 0 && (t = {});
    var e = pI(null);
    return e.options = Nr({
        async: !0,
        ssr: !1
    }, t),
    e
}
var S_ = function(t) {
    var e = t.sideCar
      , r = wo(t, ["sideCar"]);
    if (!e)
        throw new Error("Sidecar: please provide `sideCar` property to import the right car");
    var n = e.read();
    if (!n)
        throw new Error("Sidecar medium not found");
    return y.createElement(n, Nr({}, r))
};
S_.isSideCarExport = !0;
function gI(t, e) {
    return t.useMedium(e),
    S_
}
var k_ = mI()
  , Cd = function() {}
  , _u = y.forwardRef(function(t, e) {
    var r = y.useRef(null)
      , n = y.useState({
        onScrollCapture: Cd,
        onWheelCapture: Cd,
        onTouchMoveCapture: Cd
    })
      , s = n[0]
      , i = n[1]
      , o = t.forwardProps
      , a = t.children
      , l = t.className
      , c = t.removeScrollBar
      , u = t.enabled
      , h = t.shards
      , p = t.sideCar
      , f = t.noRelative
      , b = t.noIsolation
      , m = t.inert
      , x = t.allowPinchZoom
      , w = t.as
      , g = w === void 0 ? "div" : w
      , v = t.gapMode
      , _ = wo(t, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noRelative", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"])
      , S = p
      , k = hI([r, e])
      , C = Nr(Nr({}, _), s);
    return y.createElement(y.Fragment, null, u && y.createElement(S, {
        sideCar: k_,
        removeScrollBar: c,
        shards: h,
        noRelative: f,
        noIsolation: b,
        inert: m,
        setCallbacks: i,
        allowPinchZoom: !!x,
        lockRef: r,
        gapMode: v
    }), o ? y.cloneElement(y.Children.only(a), Nr(Nr({}, C), {
        ref: k
    })) : y.createElement(g, Nr({}, C, {
        className: l,
        ref: k
    }), a))
});
_u.defaultProps = {
    enabled: !0,
    removeScrollBar: !0,
    inert: !1
};
_u.classNames = {
    fullWidth: ql,
    zeroRight: Kl
};
var vI = function() {
    if (typeof __webpack_nonce__ < "u")
        return __webpack_nonce__
};
function yI() {
    if (!document)
        return null;
    var t = document.createElement("style");
    t.type = "text/css";
    var e = vI();
    return e && t.setAttribute("nonce", e),
    t
}
function wI(t, e) {
    t.styleSheet ? t.styleSheet.cssText = e : t.appendChild(document.createTextNode(e))
}
function xI(t) {
    var e = document.head || document.getElementsByTagName("head")[0];
    e.appendChild(t)
}
var bI = function() {
    var t = 0
      , e = null;
    return {
        add: function(r) {
            t == 0 && (e = yI()) && (wI(e, r),
            xI(e)),
            t++
        },
        remove: function() {
            t--,
            !t && e && (e.parentNode && e.parentNode.removeChild(e),
            e = null)
        }
    }
}
  , _I = function() {
    var t = bI();
    return function(e, r) {
        y.useEffect(function() {
            return t.add(e),
            function() {
                t.remove()
            }
        }, [e && r])
    }
}
  , E_ = function() {
    var t = _I()
      , e = function(r) {
        var n = r.styles
          , s = r.dynamic;
        return t(n, s),
        null
    };
    return e
}
  , SI = {
    left: 0,
    top: 0,
    right: 0,
    gap: 0
}
  , Td = function(t) {
    return parseInt(t || "", 10) || 0
}
  , kI = function(t) {
    var e = window.getComputedStyle(document.body)
      , r = e[t === "padding" ? "paddingLeft" : "marginLeft"]
      , n = e[t === "padding" ? "paddingTop" : "marginTop"]
      , s = e[t === "padding" ? "paddingRight" : "marginRight"];
    return [Td(r), Td(n), Td(s)]
}
  , EI = function(t) {
    if (t === void 0 && (t = "margin"),
    typeof window > "u")
        return SI;
    var e = kI(t)
      , r = document.documentElement.clientWidth
      , n = window.innerWidth;
    return {
        left: e[0],
        top: e[1],
        right: e[2],
        gap: Math.max(0, n - r + e[2] - e[0])
    }
}
  , CI = E_()
  , Di = "data-scroll-locked"
  , TI = function(t, e, r, n) {
    var s = t.left
      , i = t.top
      , o = t.right
      , a = t.gap;
    return r === void 0 && (r = "margin"),
    `
  .`.concat(lI, ` {
   overflow: hidden `).concat(n, `;
   padding-right: `).concat(a, "px ").concat(n, `;
  }
  body[`).concat(Di, `] {
    overflow: hidden `).concat(n, `;
    overscroll-behavior: contain;
    `).concat([e && "position: relative ".concat(n, ";"), r === "margin" && `
    padding-left: `.concat(s, `px;
    padding-top: `).concat(i, `px;
    padding-right: `).concat(o, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(a, "px ").concat(n, `;
    `), r === "padding" && "padding-right: ".concat(a, "px ").concat(n, ";")].filter(Boolean).join(""), `
  }
  
  .`).concat(Kl, ` {
    right: `).concat(a, "px ").concat(n, `;
  }
  
  .`).concat(ql, ` {
    margin-right: `).concat(a, "px ").concat(n, `;
  }
  
  .`).concat(Kl, " .").concat(Kl, ` {
    right: 0 `).concat(n, `;
  }
  
  .`).concat(ql, " .").concat(ql, ` {
    margin-right: 0 `).concat(n, `;
  }
  
  body[`).concat(Di, `] {
    `).concat(cI, ": ").concat(a, `px;
  }
`)
}
  , Gv = function() {
    var t = parseInt(document.body.getAttribute(Di) || "0", 10);
    return isFinite(t) ? t : 0
}
  , RI = function() {
    y.useEffect(function() {
        return document.body.setAttribute(Di, (Gv() + 1).toString()),
        function() {
            var t = Gv() - 1;
            t <= 0 ? document.body.removeAttribute(Di) : document.body.setAttribute(Di, t.toString())
        }
    }, [])
}
  , NI = function(t) {
    var e = t.noRelative
      , r = t.noImportant
      , n = t.gapMode
      , s = n === void 0 ? "margin" : n;
    RI();
    var i = y.useMemo(function() {
        return EI(s)
    }, [s]);
    return y.createElement(CI, {
        styles: TI(i, !e, s, r ? "" : "!important")
    })
}
  , pf = !1;
if (typeof window < "u")
    try {
        var Tl = Object.defineProperty({}, "passive", {
            get: function() {
                return pf = !0,
                !0
            }
        });
        window.addEventListener("test", Tl, Tl),
        window.removeEventListener("test", Tl, Tl)
    } catch {
        pf = !1
    }
var ni = pf ? {
    passive: !1
} : !1
  , PI = function(t) {
    return t.tagName === "TEXTAREA"
}
  , C_ = function(t, e) {
    if (!(t instanceof Element))
        return !1;
    var r = window.getComputedStyle(t);
    return r[e] !== "hidden" && !(r.overflowY === r.overflowX && !PI(t) && r[e] === "visible")
}
  , AI = function(t) {
    return C_(t, "overflowY")
}
  , jI = function(t) {
    return C_(t, "overflowX")
}
  , Qv = function(t, e) {
    var r = e.ownerDocument
      , n = e;
    do {
        typeof ShadowRoot < "u" && n instanceof ShadowRoot && (n = n.host);
        var s = T_(t, n);
        if (s) {
            var i = R_(t, n)
              , o = i[1]
              , a = i[2];
            if (o > a)
                return !0
        }
        n = n.parentNode
    } while (n && n !== r.body);
    return !1
}
  , OI = function(t) {
    var e = t.scrollTop
      , r = t.scrollHeight
      , n = t.clientHeight;
    return [e, r, n]
}
  , II = function(t) {
    var e = t.scrollLeft
      , r = t.scrollWidth
      , n = t.clientWidth;
    return [e, r, n]
}
  , T_ = function(t, e) {
    return t === "v" ? AI(e) : jI(e)
}
  , R_ = function(t, e) {
    return t === "v" ? OI(e) : II(e)
}
  , LI = function(t, e) {
    return t === "h" && e === "rtl" ? -1 : 1
}
  , $I = function(t, e, r, n, s) {
    var i = LI(t, window.getComputedStyle(e).direction)
      , o = i * n
      , a = r.target
      , l = e.contains(a)
      , c = !1
      , u = o > 0
      , h = 0
      , p = 0;
    do {
        if (!a)
            break;
        var f = R_(t, a)
          , b = f[0]
          , m = f[1]
          , x = f[2]
          , w = m - x - i * b;
        (b || w) && T_(t, a) && (h += w,
        p += b);
        var g = a.parentNode;
        a = g && g.nodeType === Node.DOCUMENT_FRAGMENT_NODE ? g.host : g
    } while (!l && a !== document.body || l && (e.contains(a) || e === a));
    return (u && (Math.abs(h) < 1 || !s) || !u && (Math.abs(p) < 1 || !s)) && (c = !0),
    c
}
  , Rl = function(t) {
    return "changedTouches"in t ? [t.changedTouches[0].clientX, t.changedTouches[0].clientY] : [0, 0]
}
  , Jv = function(t) {
    return [t.deltaX, t.deltaY]
}
  , Zv = function(t) {
    return t && "current"in t ? t.current : t
}
  , DI = function(t, e) {
    return t[0] === e[0] && t[1] === e[1]
}
  , MI = function(t) {
    return `
  .block-interactivity-`.concat(t, ` {pointer-events: none;}
  .allow-interactivity-`).concat(t, ` {pointer-events: all;}
`)
}
  , FI = 0
  , si = [];
function UI(t) {
    var e = y.useRef([])
      , r = y.useRef([0, 0])
      , n = y.useRef()
      , s = y.useState(FI++)[0]
      , i = y.useState(E_)[0]
      , o = y.useRef(t);
    y.useEffect(function() {
        o.current = t
    }, [t]),
    y.useEffect(function() {
        if (t.inert) {
            document.body.classList.add("block-interactivity-".concat(s));
            var m = yA([t.lockRef.current], (t.shards || []).map(Zv), !0).filter(Boolean);
            return m.forEach(function(x) {
                return x.classList.add("allow-interactivity-".concat(s))
            }),
            function() {
                document.body.classList.remove("block-interactivity-".concat(s)),
                m.forEach(function(x) {
                    return x.classList.remove("allow-interactivity-".concat(s))
                })
            }
        }
    }, [t.inert, t.lockRef.current, t.shards]);
    var a = y.useCallback(function(m, x) {
        if ("touches"in m && m.touches.length === 2 || m.type === "wheel" && m.ctrlKey)
            return !o.current.allowPinchZoom;
        var w = Rl(m), g = r.current, v = "deltaX"in m ? m.deltaX : g[0] - w[0], _ = "deltaY"in m ? m.deltaY : g[1] - w[1], S, k = m.target, C = Math.abs(v) > Math.abs(_) ? "h" : "v";
        if ("touches"in m && C === "h" && k.type === "range")
            return !1;
        var T = Qv(C, k);
        if (!T)
            return !0;
        if (T ? S = C : (S = C === "v" ? "h" : "v",
        T = Qv(C, k)),
        !T)
            return !1;
        if (!n.current && "changedTouches"in m && (v || _) && (n.current = S),
        !S)
            return !0;
        var A = n.current || S;
        return $I(A, x, m, A === "h" ? v : _, !0)
    }, [])
      , l = y.useCallback(function(m) {
        var x = m;
        if (!(!si.length || si[si.length - 1] !== i)) {
            var w = "deltaY"in x ? Jv(x) : Rl(x)
              , g = e.current.filter(function(S) {
                return S.name === x.type && (S.target === x.target || x.target === S.shadowParent) && DI(S.delta, w)
            })[0];
            if (g && g.should) {
                x.cancelable && x.preventDefault();
                return
            }
            if (!g) {
                var v = (o.current.shards || []).map(Zv).filter(Boolean).filter(function(S) {
                    return S.contains(x.target)
                })
                  , _ = v.length > 0 ? a(x, v[0]) : !o.current.noIsolation;
                _ && x.cancelable && x.preventDefault()
            }
        }
    }, [])
      , c = y.useCallback(function(m, x, w, g) {
        var v = {
            name: m,
            delta: x,
            target: w,
            should: g,
            shadowParent: BI(w)
        };
        e.current.push(v),
        setTimeout(function() {
            e.current = e.current.filter(function(_) {
                return _ !== v
            })
        }, 1)
    }, [])
      , u = y.useCallback(function(m) {
        r.current = Rl(m),
        n.current = void 0
    }, [])
      , h = y.useCallback(function(m) {
        c(m.type, Jv(m), m.target, a(m, t.lockRef.current))
    }, [])
      , p = y.useCallback(function(m) {
        c(m.type, Rl(m), m.target, a(m, t.lockRef.current))
    }, []);
    y.useEffect(function() {
        return si.push(i),
        t.setCallbacks({
            onScrollCapture: h,
            onWheelCapture: h,
            onTouchMoveCapture: p
        }),
        document.addEventListener("wheel", l, ni),
        document.addEventListener("touchmove", l, ni),
        document.addEventListener("touchstart", u, ni),
        function() {
            si = si.filter(function(m) {
                return m !== i
            }),
            document.removeEventListener("wheel", l, ni),
            document.removeEventListener("touchmove", l, ni),
            document.removeEventListener("touchstart", u, ni)
        }
    }, []);
    var f = t.removeScrollBar
      , b = t.inert;
    return y.createElement(y.Fragment, null, b ? y.createElement(i, {
        styles: MI(s)
    }) : null, f ? y.createElement(NI, {
        noRelative: t.noRelative,
        gapMode: t.gapMode
    }) : null)
}
function BI(t) {
    for (var e = null; t !== null; )
        t instanceof ShadowRoot && (e = t.host,
        t = t.host),
        t = t.parentNode;
    return e
}
const zI = gI(k_, UI);
var N_ = y.forwardRef(function(t, e) {
    return y.createElement(_u, Nr({}, t, {
        ref: e,
        sideCar: zI
    }))
});
N_.classNames = _u.classNames;
var VI = [" ", "Enter", "ArrowUp", "ArrowDown"]
  , WI = [" ", "Enter"]
  , Ds = "Select"
  , [Su,ku,HI] = tu(Ds)
  , [xo,DL] = tn(Ds, [HI, cu])
  , Eu = cu()
  , [KI,ts] = xo(Ds)
  , [qI,GI] = xo(Ds)
  , P_ = t => {
    const {__scopeSelect: e, children: r, open: n, defaultOpen: s, onOpenChange: i, value: o, defaultValue: a, onValueChange: l, dir: c, name: u, autoComplete: h, disabled: p, required: f, form: b} = t
      , m = Eu(e)
      , [x,w] = y.useState(null)
      , [g,v] = y.useState(null)
      , [_,S] = y.useState(!1)
      , k = gu(c)
      , [C,T] = Kn({
        prop: n,
        defaultProp: s ?? !1,
        onChange: i,
        caller: Ds
    })
      , [A,P] = Kn({
        prop: o,
        defaultProp: a,
        onChange: l,
        caller: Ds
    })
      , B = y.useRef(null)
      , L = x ? b || !!x.closest("form") : !0
      , [G,$] = y.useState(new Set)
      , Y = Array.from(G).map(U => U.props.value).join(";");
    return d.jsx(WR, {
        ...m,
        children: d.jsxs(KI, {
            required: f,
            scope: e,
            trigger: x,
            onTriggerChange: w,
            valueNode: g,
            onValueNodeChange: v,
            valueNodeHasChildren: _,
            onValueNodeHasChildrenChange: S,
            contentId: zs(),
            value: A,
            onValueChange: P,
            open: C,
            onOpenChange: T,
            dir: k,
            triggerPointerDownPosRef: B,
            disabled: p,
            children: [d.jsx(Su.Provider, {
                scope: e,
                children: d.jsx(qI, {
                    scope: t.__scopeSelect,
                    onNativeOptionAdd: y.useCallback(U => {
                        $(Q => new Set(Q).add(U))
                    }
                    , []),
                    onNativeOptionRemove: y.useCallback(U => {
                        $(Q => {
                            const R = new Set(Q);
                            return R.delete(U),
                            R
                        }
                        )
                    }
                    , []),
                    children: r
                })
            }), L ? d.jsxs(eS, {
                "aria-hidden": !0,
                required: f,
                tabIndex: -1,
                name: u,
                autoComplete: h,
                value: A,
                onChange: U => P(U.target.value),
                disabled: p,
                form: b,
                children: [A === void 0 ? d.jsx("option", {
                    value: ""
                }) : null, Array.from(G)]
            }, Y) : null]
        })
    })
}
;
P_.displayName = Ds;
var A_ = "SelectTrigger"
  , j_ = y.forwardRef( (t, e) => {
    const {__scopeSelect: r, disabled: n=!1, ...s} = t
      , i = Eu(r)
      , o = ts(A_, r)
      , a = o.disabled || n
      , l = Ae(e, o.onTriggerChange)
      , c = ku(r)
      , u = y.useRef("touch")
      , [h,p,f] = rS(m => {
        const x = c().filter(v => !v.disabled)
          , w = x.find(v => v.value === o.value)
          , g = nS(x, m, w);
        g !== void 0 && o.onValueChange(g.value)
    }
    )
      , b = m => {
        a || (o.onOpenChange(!0),
        f()),
        m && (o.triggerPointerDownPosRef.current = {
            x: Math.round(m.pageX),
            y: Math.round(m.pageY)
        })
    }
    ;
    return d.jsx(Px, {
        asChild: !0,
        ...i,
        children: d.jsx(le.button, {
            type: "button",
            role: "combobox",
            "aria-controls": o.contentId,
            "aria-expanded": o.open,
            "aria-required": o.required,
            "aria-autocomplete": "none",
            dir: o.dir,
            "data-state": o.open ? "open" : "closed",
            disabled: a,
            "data-disabled": a ? "" : void 0,
            "data-placeholder": tS(o.value) ? "" : void 0,
            ...s,
            ref: l,
            onClick: te(s.onClick, m => {
                m.currentTarget.focus(),
                u.current !== "mouse" && b(m)
            }
            ),
            onPointerDown: te(s.onPointerDown, m => {
                u.current = m.pointerType;
                const x = m.target;
                x.hasPointerCapture(m.pointerId) && x.releasePointerCapture(m.pointerId),
                m.button === 0 && m.ctrlKey === !1 && m.pointerType === "mouse" && (b(m),
                m.preventDefault())
            }
            ),
            onKeyDown: te(s.onKeyDown, m => {
                const x = h.current !== "";
                !(m.ctrlKey || m.altKey || m.metaKey) && m.key.length === 1 && p(m.key),
                !(x && m.key === " ") && VI.includes(m.key) && (b(),
                m.preventDefault())
            }
            )
        })
    })
}
);
j_.displayName = A_;
var O_ = "SelectValue"
  , I_ = y.forwardRef( (t, e) => {
    const {__scopeSelect: r, className: n, style: s, children: i, placeholder: o="", ...a} = t
      , l = ts(O_, r)
      , {onValueNodeHasChildrenChange: c} = l
      , u = i !== void 0
      , h = Ae(e, l.onValueNodeChange);
    return et( () => {
        c(u)
    }
    , [c, u]),
    d.jsx(le.span, {
        ...a,
        ref: h,
        style: {
            pointerEvents: "none"
        },
        children: tS(l.value) ? d.jsx(d.Fragment, {
            children: o
        }) : i
    })
}
);
I_.displayName = O_;
var QI = "SelectIcon"
  , L_ = y.forwardRef( (t, e) => {
    const {__scopeSelect: r, children: n, ...s} = t;
    return d.jsx(le.span, {
        "aria-hidden": !0,
        ...s,
        ref: e,
        children: n || ""
    })
}
);
L_.displayName = QI;
var JI = "SelectPortal"
  , $_ = t => d.jsx(gp, {
    asChild: !0,
    ...t
});
$_.displayName = JI;
var Ms = "SelectContent"
  , D_ = y.forwardRef( (t, e) => {
    const r = ts(Ms, t.__scopeSelect)
      , [n,s] = y.useState();
    if (et( () => {
        s(new DocumentFragment)
    }
    , []),
    !r.open) {
        const i = n;
        return i ? Bs.createPortal(d.jsx(M_, {
            scope: t.__scopeSelect,
            children: d.jsx(Su.Slot, {
                scope: t.__scopeSelect,
                children: d.jsx("div", {
                    children: t.children
                })
            })
        }), i) : null
    }
    return d.jsx(F_, {
        ...t,
        ref: e
    })
}
);
D_.displayName = Ms;
var cr = 10
  , [M_,rs] = xo(Ms)
  , ZI = "SelectContentImpl"
  , YI = va("SelectContent.RemoveScroll")
  , F_ = y.forwardRef( (t, e) => {
    const {__scopeSelect: r, position: n="item-aligned", onCloseAutoFocus: s, onEscapeKeyDown: i, onPointerDownOutside: o, side: a, sideOffset: l, align: c, alignOffset: u, arrowPadding: h, collisionBoundary: p, collisionPadding: f, sticky: b, hideWhenDetached: m, avoidCollisions: x, ...w} = t
      , g = ts(Ms, r)
      , [v,_] = y.useState(null)
      , [S,k] = y.useState(null)
      , C = Ae(e, M => _(M))
      , [T,A] = y.useState(null)
      , [P,B] = y.useState(null)
      , L = ku(r)
      , [G,$] = y.useState(!1)
      , Y = y.useRef(!1);
    y.useEffect( () => {
        if (v)
            return aI(v)
    }
    , [v]),
    Q2();
    const U = y.useCallback(M => {
        const [be,...Fe] = L().map(ve => ve.ref.current)
          , [we] = Fe.slice(-1)
          , fe = document.activeElement;
        for (const ve of M)
            if (ve === fe || (ve == null || ve.scrollIntoView({
                block: "nearest"
            }),
            ve === be && S && (S.scrollTop = 0),
            ve === we && S && (S.scrollTop = S.scrollHeight),
            ve == null || ve.focus(),
            document.activeElement !== fe))
                return
    }
    , [L, S])
      , Q = y.useCallback( () => U([T, v]), [U, T, v]);
    y.useEffect( () => {
        G && Q()
    }
    , [G, Q]);
    const {onOpenChange: R, triggerPointerDownPosRef: N} = g;
    y.useEffect( () => {
        if (v) {
            let M = {
                x: 0,
                y: 0
            };
            const be = we => {
                var fe, ve;
                M = {
                    x: Math.abs(Math.round(we.pageX) - (((fe = N.current) == null ? void 0 : fe.x) ?? 0)),
                    y: Math.abs(Math.round(we.pageY) - (((ve = N.current) == null ? void 0 : ve.y) ?? 0))
                }
            }
              , Fe = we => {
                M.x <= 10 && M.y <= 10 ? we.preventDefault() : v.contains(we.target) || R(!1),
                document.removeEventListener("pointermove", be),
                N.current = null
            }
            ;
            return N.current !== null && (document.addEventListener("pointermove", be),
            document.addEventListener("pointerup", Fe, {
                capture: !0,
                once: !0
            })),
            () => {
                document.removeEventListener("pointermove", be),
                document.removeEventListener("pointerup", Fe, {
                    capture: !0
                })
            }
        }
    }
    , [v, R, N]),
    y.useEffect( () => {
        const M = () => R(!1);
        return window.addEventListener("blur", M),
        window.addEventListener("resize", M),
        () => {
            window.removeEventListener("blur", M),
            window.removeEventListener("resize", M)
        }
    }
    , [R]);
    const [D,ee] = rS(M => {
        const be = L().filter(fe => !fe.disabled)
          , Fe = be.find(fe => fe.ref.current === document.activeElement)
          , we = nS(be, M, Fe);
        we && setTimeout( () => we.ref.current.focus())
    }
    )
      , q = y.useCallback( (M, be, Fe) => {
        const we = !Y.current && !Fe;
        (g.value !== void 0 && g.value === be || we) && (A(M),
        we && (Y.current = !0))
    }
    , [g.value])
      , oe = y.useCallback( () => v == null ? void 0 : v.focus(), [v])
      , se = y.useCallback( (M, be, Fe) => {
        const we = !Y.current && !Fe;
        (g.value !== void 0 && g.value === be || we) && B(M)
    }
    , [g.value])
      , Te = n === "popper" ? mf : U_
      , Me = Te === mf ? {
        side: a,
        sideOffset: l,
        align: c,
        alignOffset: u,
        arrowPadding: h,
        collisionBoundary: p,
        collisionPadding: f,
        sticky: b,
        hideWhenDetached: m,
        avoidCollisions: x
    } : {};
    return d.jsx(M_, {
        scope: r,
        content: v,
        viewport: S,
        onViewportChange: k,
        itemRefCallback: q,
        selectedItem: T,
        onItemLeave: oe,
        itemTextRefCallback: se,
        focusSelectedItem: Q,
        selectedItemText: P,
        position: n,
        isPositioned: G,
        searchRef: D,
        children: d.jsx(N_, {
            as: YI,
            allowPinchZoom: !0,
            children: d.jsx(x_, {
                asChild: !0,
                trapped: g.open,
                onMountAutoFocus: M => {
                    M.preventDefault()
                }
                ,
                onUnmountAutoFocus: te(s, M => {
                    var be;
                    (be = g.trigger) == null || be.focus({
                        preventScroll: !0
                    }),
                    M.preventDefault()
                }
                ),
                children: d.jsx(ru, {
                    asChild: !0,
                    disableOutsidePointerEvents: !0,
                    onEscapeKeyDown: i,
                    onPointerDownOutside: o,
                    onFocusOutside: M => M.preventDefault(),
                    onDismiss: () => g.onOpenChange(!1),
                    children: d.jsx(Te, {
                        role: "listbox",
                        id: g.contentId,
                        "data-state": g.open ? "open" : "closed",
                        dir: g.dir,
                        onContextMenu: M => M.preventDefault(),
                        ...w,
                        ...Me,
                        onPlaced: () => $(!0),
                        ref: C,
                        style: {
                            display: "flex",
                            flexDirection: "column",
                            outline: "none",
                            ...w.style
                        },
                        onKeyDown: te(w.onKeyDown, M => {
                            const be = M.ctrlKey || M.altKey || M.metaKey;
                            if (M.key === "Tab" && M.preventDefault(),
                            !be && M.key.length === 1 && ee(M.key),
                            ["ArrowUp", "ArrowDown", "Home", "End"].includes(M.key)) {
                                let we = L().filter(fe => !fe.disabled).map(fe => fe.ref.current);
                                if (["ArrowUp", "End"].includes(M.key) && (we = we.slice().reverse()),
                                ["ArrowUp", "ArrowDown"].includes(M.key)) {
                                    const fe = M.target
                                      , ve = we.indexOf(fe);
                                    we = we.slice(ve + 1)
                                }
                                setTimeout( () => U(we)),
                                M.preventDefault()
                            }
                        }
                        )
                    })
                })
            })
        })
    })
}
);
F_.displayName = ZI;
var XI = "SelectItemAlignedPosition"
  , U_ = y.forwardRef( (t, e) => {
    const {__scopeSelect: r, onPlaced: n, ...s} = t
      , i = ts(Ms, r)
      , o = rs(Ms, r)
      , [a,l] = y.useState(null)
      , [c,u] = y.useState(null)
      , h = Ae(e, C => u(C))
      , p = ku(r)
      , f = y.useRef(!1)
      , b = y.useRef(!0)
      , {viewport: m, selectedItem: x, selectedItemText: w, focusSelectedItem: g} = o
      , v = y.useCallback( () => {
        if (i.trigger && i.valueNode && a && c && m && x && w) {
            const C = i.trigger.getBoundingClientRect()
              , T = c.getBoundingClientRect()
              , A = i.valueNode.getBoundingClientRect()
              , P = w.getBoundingClientRect();
            if (i.dir !== "rtl") {
                const fe = P.left - T.left
                  , ve = A.left - fe
                  , at = C.left - ve
                  , Vt = C.width + at
                  , ns = Math.max(Vt, T.width)
                  , nn = window.innerWidth - cr
                  , ss = Bv(ve, [cr, Math.max(cr, nn - ns)]);
                a.style.minWidth = Vt + "px",
                a.style.left = ss + "px"
            } else {
                const fe = T.right - P.right
                  , ve = window.innerWidth - A.right - fe
                  , at = window.innerWidth - C.right - ve
                  , Vt = C.width + at
                  , ns = Math.max(Vt, T.width)
                  , nn = window.innerWidth - cr
                  , ss = Bv(ve, [cr, Math.max(cr, nn - ns)]);
                a.style.minWidth = Vt + "px",
                a.style.right = ss + "px"
            }
            const B = p()
              , L = window.innerHeight - cr * 2
              , G = m.scrollHeight
              , $ = window.getComputedStyle(c)
              , Y = parseInt($.borderTopWidth, 10)
              , U = parseInt($.paddingTop, 10)
              , Q = parseInt($.borderBottomWidth, 10)
              , R = parseInt($.paddingBottom, 10)
              , N = Y + U + G + R + Q
              , D = Math.min(x.offsetHeight * 5, N)
              , ee = window.getComputedStyle(m)
              , q = parseInt(ee.paddingTop, 10)
              , oe = parseInt(ee.paddingBottom, 10)
              , se = C.top + C.height / 2 - cr
              , Te = L - se
              , Me = x.offsetHeight / 2
              , M = x.offsetTop + Me
              , be = Y + U + M
              , Fe = N - be;
            if (be <= se) {
                const fe = B.length > 0 && x === B[B.length - 1].ref.current;
                a.style.bottom = "0px";
                const ve = c.clientHeight - m.offsetTop - m.offsetHeight
                  , at = Math.max(Te, Me + (fe ? oe : 0) + ve + Q)
                  , Vt = be + at;
                a.style.height = Vt + "px"
            } else {
                const fe = B.length > 0 && x === B[0].ref.current;
                a.style.top = "0px";
                const at = Math.max(se, Y + m.offsetTop + (fe ? q : 0) + Me) + Fe;
                a.style.height = at + "px",
                m.scrollTop = be - se + m.offsetTop
            }
            a.style.margin = `${cr}px 0`,
            a.style.minHeight = D + "px",
            a.style.maxHeight = L + "px",
            n == null || n(),
            requestAnimationFrame( () => f.current = !0)
        }
    }
    , [p, i.trigger, i.valueNode, a, c, m, x, w, i.dir, n]);
    et( () => v(), [v]);
    const [_,S] = y.useState();
    et( () => {
        c && S(window.getComputedStyle(c).zIndex)
    }
    , [c]);
    const k = y.useCallback(C => {
        C && b.current === !0 && (v(),
        g == null || g(),
        b.current = !1)
    }
    , [v, g]);
    return d.jsx(tL, {
        scope: r,
        contentWrapper: a,
        shouldExpandOnScrollRef: f,
        onScrollButtonChange: k,
        children: d.jsx("div", {
            ref: l,
            style: {
                display: "flex",
                flexDirection: "column",
                position: "fixed",
                zIndex: _
            },
            children: d.jsx(le.div, {
                ...s,
                ref: h,
                style: {
                    boxSizing: "border-box",
                    maxHeight: "100%",
                    ...s.style
                }
            })
        })
    })
}
);
U_.displayName = XI;
var eL = "SelectPopperPosition"
  , mf = y.forwardRef( (t, e) => {
    const {__scopeSelect: r, align: n="start", collisionPadding: s=cr, ...i} = t
      , o = Eu(r);
    return d.jsx(Ax, {
        ...o,
        ...i,
        ref: e,
        align: n,
        collisionPadding: s,
        style: {
            boxSizing: "border-box",
            ...i.style,
            "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
            "--radix-select-content-available-width": "var(--radix-popper-available-width)",
            "--radix-select-content-available-height": "var(--radix-popper-available-height)",
            "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
            "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
    })
}
);
mf.displayName = eL;
var [tL,Jp] = xo(Ms, {})
  , gf = "SelectViewport"
  , B_ = y.forwardRef( (t, e) => {
    const {__scopeSelect: r, nonce: n, ...s} = t
      , i = rs(gf, r)
      , o = Jp(gf, r)
      , a = Ae(e, i.onViewportChange)
      , l = y.useRef(0);
    return d.jsxs(d.Fragment, {
        children: [d.jsx("style", {
            dangerouslySetInnerHTML: {
                __html: "[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}"
            },
            nonce: n
        }), d.jsx(Su.Slot, {
            scope: r,
            children: d.jsx(le.div, {
                "data-radix-select-viewport": "",
                role: "presentation",
                ...s,
                ref: a,
                style: {
                    position: "relative",
                    flex: 1,
                    overflow: "hidden auto",
                    ...s.style
                },
                onScroll: te(s.onScroll, c => {
                    const u = c.currentTarget
                      , {contentWrapper: h, shouldExpandOnScrollRef: p} = o;
                    if (p != null && p.current && h) {
                        const f = Math.abs(l.current - u.scrollTop);
                        if (f > 0) {
                            const b = window.innerHeight - cr * 2
                              , m = parseFloat(h.style.minHeight)
                              , x = parseFloat(h.style.height)
                              , w = Math.max(m, x);
                            if (w < b) {
                                const g = w + f
                                  , v = Math.min(b, g)
                                  , _ = g - v;
                                h.style.height = v + "px",
                                h.style.bottom === "0px" && (u.scrollTop = _ > 0 ? _ : 0,
                                h.style.justifyContent = "flex-end")
                            }
                        }
                    }
                    l.current = u.scrollTop
                }
                )
            })
        })]
    })
}
);
B_.displayName = gf;
var z_ = "SelectGroup"
  , [rL,nL] = xo(z_)
  , sL = y.forwardRef( (t, e) => {
    const {__scopeSelect: r, ...n} = t
      , s = zs();
    return d.jsx(rL, {
        scope: r,
        id: s,
        children: d.jsx(le.div, {
            role: "group",
            "aria-labelledby": s,
            ...n,
            ref: e
        })
    })
}
);
sL.displayName = z_;
var V_ = "SelectLabel"
  , W_ = y.forwardRef( (t, e) => {
    const {__scopeSelect: r, ...n} = t
      , s = nL(V_, r);
    return d.jsx(le.div, {
        id: s.id,
        ...n,
        ref: e
    })
}
);
W_.displayName = V_;
var Mc = "SelectItem"
  , [iL,H_] = xo(Mc)
  , K_ = y.forwardRef( (t, e) => {
    const {__scopeSelect: r, value: n, disabled: s=!1, textValue: i, ...o} = t
      , a = ts(Mc, r)
      , l = rs(Mc, r)
      , c = a.value === n
      , [u,h] = y.useState(i ?? "")
      , [p,f] = y.useState(!1)
      , b = Ae(e, g => {
        var v;
        return (v = l.itemRefCallback) == null ? void 0 : v.call(l, g, n, s)
    }
    )
      , m = zs()
      , x = y.useRef("touch")
      , w = () => {
        s || (a.onValueChange(n),
        a.onOpenChange(!1))
    }
    ;
    if (n === "")
        throw new Error("A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder.");
    return d.jsx(iL, {
        scope: r,
        value: n,
        disabled: s,
        textId: m,
        isSelected: c,
        onItemTextChange: y.useCallback(g => {
            h(v => v || ((g == null ? void 0 : g.textContent) ?? "").trim())
        }
        , []),
        children: d.jsx(Su.ItemSlot, {
            scope: r,
            value: n,
            disabled: s,
            textValue: u,
            children: d.jsx(le.div, {
                role: "option",
                "aria-labelledby": m,
                "data-highlighted": p ? "" : void 0,
                "aria-selected": c && p,
                "data-state": c ? "checked" : "unchecked",
                "aria-disabled": s || void 0,
                "data-disabled": s ? "" : void 0,
                tabIndex: s ? void 0 : -1,
                ...o,
                ref: b,
                onFocus: te(o.onFocus, () => f(!0)),
                onBlur: te(o.onBlur, () => f(!1)),
                onClick: te(o.onClick, () => {
                    x.current !== "mouse" && w()
                }
                ),
                onPointerUp: te(o.onPointerUp, () => {
                    x.current === "mouse" && w()
                }
                ),
                onPointerDown: te(o.onPointerDown, g => {
                    x.current = g.pointerType
                }
                ),
                onPointerMove: te(o.onPointerMove, g => {
                    var v;
                    x.current = g.pointerType,
                    s ? (v = l.onItemLeave) == null || v.call(l) : x.current === "mouse" && g.currentTarget.focus({
                        preventScroll: !0
                    })
                }
                ),
                onPointerLeave: te(o.onPointerLeave, g => {
                    var v;
                    g.currentTarget === document.activeElement && ((v = l.onItemLeave) == null || v.call(l))
                }
                ),
                onKeyDown: te(o.onKeyDown, g => {
                    var _;
                    ((_ = l.searchRef) == null ? void 0 : _.current) !== "" && g.key === " " || (WI.includes(g.key) && w(),
                    g.key === " " && g.preventDefault())
                }
                )
            })
        })
    })
}
);
K_.displayName = Mc;
var Bo = "SelectItemText"
  , q_ = y.forwardRef( (t, e) => {
    const {__scopeSelect: r, className: n, style: s, ...i} = t
      , o = ts(Bo, r)
      , a = rs(Bo, r)
      , l = H_(Bo, r)
      , c = GI(Bo, r)
      , [u,h] = y.useState(null)
      , p = Ae(e, w => h(w), l.onItemTextChange, w => {
        var g;
        return (g = a.itemTextRefCallback) == null ? void 0 : g.call(a, w, l.value, l.disabled)
    }
    )
      , f = u == null ? void 0 : u.textContent
      , b = y.useMemo( () => d.jsx("option", {
        value: l.value,
        disabled: l.disabled,
        children: f
    }, l.value), [l.disabled, l.value, f])
      , {onNativeOptionAdd: m, onNativeOptionRemove: x} = c;
    return et( () => (m(b),
    () => x(b)), [m, x, b]),
    d.jsxs(d.Fragment, {
        children: [d.jsx(le.span, {
            id: l.textId,
            ...i,
            ref: p
        }), l.isSelected && o.valueNode && !o.valueNodeHasChildren ? Bs.createPortal(i.children, o.valueNode) : null]
    })
}
);
q_.displayName = Bo;
var G_ = "SelectItemIndicator"
  , Q_ = y.forwardRef( (t, e) => {
    const {__scopeSelect: r, ...n} = t;
    return H_(G_, r).isSelected ? d.jsx(le.span, {
        "aria-hidden": !0,
        ...n,
        ref: e
    }) : null
}
);
Q_.displayName = G_;
var vf = "SelectScrollUpButton"
  , J_ = y.forwardRef( (t, e) => {
    const r = rs(vf, t.__scopeSelect)
      , n = Jp(vf, t.__scopeSelect)
      , [s,i] = y.useState(!1)
      , o = Ae(e, n.onScrollButtonChange);
    return et( () => {
        if (r.viewport && r.isPositioned) {
            let a = function() {
                const c = l.scrollTop > 0;
                i(c)
            };
            const l = r.viewport;
            return a(),
            l.addEventListener("scroll", a),
            () => l.removeEventListener("scroll", a)
        }
    }
    , [r.viewport, r.isPositioned]),
    s ? d.jsx(Y_, {
        ...t,
        ref: o,
        onAutoScroll: () => {
            const {viewport: a, selectedItem: l} = r;
            a && l && (a.scrollTop = a.scrollTop - l.offsetHeight)
        }
    }) : null
}
);
J_.displayName = vf;
var yf = "SelectScrollDownButton"
  , Z_ = y.forwardRef( (t, e) => {
    const r = rs(yf, t.__scopeSelect)
      , n = Jp(yf, t.__scopeSelect)
      , [s,i] = y.useState(!1)
      , o = Ae(e, n.onScrollButtonChange);
    return et( () => {
        if (r.viewport && r.isPositioned) {
            let a = function() {
                const c = l.scrollHeight - l.clientHeight
                  , u = Math.ceil(l.scrollTop) < c;
                i(u)
            };
            const l = r.viewport;
            return a(),
            l.addEventListener("scroll", a),
            () => l.removeEventListener("scroll", a)
        }
    }
    , [r.viewport, r.isPositioned]),
    s ? d.jsx(Y_, {
        ...t,
        ref: o,
        onAutoScroll: () => {
            const {viewport: a, selectedItem: l} = r;
            a && l && (a.scrollTop = a.scrollTop + l.offsetHeight)
        }
    }) : null
}
);
Z_.displayName = yf;
var Y_ = y.forwardRef( (t, e) => {
    const {__scopeSelect: r, onAutoScroll: n, ...s} = t
      , i = rs("SelectScrollButton", r)
      , o = y.useRef(null)
      , a = ku(r)
      , l = y.useCallback( () => {
        o.current !== null && (window.clearInterval(o.current),
        o.current = null)
    }
    , []);
    return y.useEffect( () => () => l(), [l]),
    et( () => {
        var u;
        const c = a().find(h => h.ref.current === document.activeElement);
        (u = c == null ? void 0 : c.ref.current) == null || u.scrollIntoView({
            block: "nearest"
        })
    }
    , [a]),
    d.jsx(le.div, {
        "aria-hidden": !0,
        ...s,
        ref: e,
        style: {
            flexShrink: 0,
            ...s.style
        },
        onPointerDown: te(s.onPointerDown, () => {
            o.current === null && (o.current = window.setInterval(n, 50))
        }
        ),
        onPointerMove: te(s.onPointerMove, () => {
            var c;
            (c = i.onItemLeave) == null || c.call(i),
            o.current === null && (o.current = window.setInterval(n, 50))
        }
        ),
        onPointerLeave: te(s.onPointerLeave, () => {
            l()
        }
        )
    })
}
)
  , oL = "SelectSeparator"
  , X_ = y.forwardRef( (t, e) => {
    const {__scopeSelect: r, ...n} = t;
    return d.jsx(le.div, {
        "aria-hidden": !0,
        ...n,
        ref: e
    })
}
);
X_.displayName = oL;
var wf = "SelectArrow"
  , aL = y.forwardRef( (t, e) => {
    const {__scopeSelect: r, ...n} = t
      , s = Eu(r)
      , i = ts(wf, r)
      , o = rs(wf, r);
    return i.open && o.position === "popper" ? d.jsx(jx, {
        ...s,
        ...n,
        ref: e
    }) : null
}
);
aL.displayName = wf;
var lL = "SelectBubbleInput"
  , eS = y.forwardRef( ({__scopeSelect: t, value: e, ...r}, n) => {
    const s = y.useRef(null)
      , i = Ae(n, s)
      , o = nI(e);
    return y.useEffect( () => {
        const a = s.current;
        if (!a)
            return;
        const l = window.HTMLSelectElement.prototype
          , u = Object.getOwnPropertyDescriptor(l, "value").set;
        if (o !== e && u) {
            const h = new Event("change",{
                bubbles: !0
            });
            u.call(a, e),
            a.dispatchEvent(h)
        }
    }
    , [o, e]),
    d.jsx(le.select, {
        ...r,
        style: {
            ...Rw,
            ...r.style
        },
        ref: i,
        defaultValue: e
    })
}
);
eS.displayName = lL;
function tS(t) {
    return t === "" || t === void 0
}
function rS(t) {
    const e = tr(t)
      , r = y.useRef("")
      , n = y.useRef(0)
      , s = y.useCallback(o => {
        const a = r.current + o;
        e(a),
        function l(c) {
            r.current = c,
            window.clearTimeout(n.current),
            c !== "" && (n.current = window.setTimeout( () => l(""), 1e3))
        }(a)
    }
    , [e])
      , i = y.useCallback( () => {
        r.current = "",
        window.clearTimeout(n.current)
    }
    , []);
    return y.useEffect( () => () => window.clearTimeout(n.current), []),
    [r, s, i]
}
function nS(t, e, r) {
    const s = e.length > 1 && Array.from(e).every(c => c === e[0]) ? e[0] : e
      , i = r ? t.indexOf(r) : -1;
    let o = cL(t, Math.max(i, 0));
    s.length === 1 && (o = o.filter(c => c !== r));
    const l = o.find(c => c.textValue.toLowerCase().startsWith(s.toLowerCase()));
    return l !== r ? l : void 0
}
function cL(t, e) {
    return t.map( (r, n) => t[(e + n) % t.length])
}
var uL = P_
  , sS = j_
  , dL = I_
  , hL = L_
  , fL = $_
  , iS = D_
  , pL = B_
  , oS = W_
  , aS = K_
  , mL = q_
  , gL = Q_
  , lS = J_
  , cS = Z_
  , uS = X_;
const vL = uL
  , yL = dL
  , dS = y.forwardRef( ({className: t, children: e, ...r}, n) => d.jsxs(sS, {
    ref: n,
    className: me("flex h-10 w-full items-center justify-between rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1", t),
    ...r,
    children: [e, d.jsx(hL, {
        asChild: !0,
        children: d.jsx(xp, {
            className: "h-4 w-4 opacity-50"
        })
    })]
}));
dS.displayName = sS.displayName;
const hS = y.forwardRef( ({className: t, ...e}, r) => d.jsx(lS, {
    ref: r,
    className: me("flex cursor-default items-center justify-center py-1", t),
    ...e,
    children: d.jsx(QE, {
        className: "h-4 w-4"
    })
}));
hS.displayName = lS.displayName;
const fS = y.forwardRef( ({className: t, ...e}, r) => d.jsx(cS, {
    ref: r,
    className: me("flex cursor-default items-center justify-center py-1", t),
    ...e,
    children: d.jsx(xp, {
        className: "h-4 w-4"
    })
}));
fS.displayName = cS.displayName;
const pS = y.forwardRef( ({className: t, children: e, position: r="popper", ...n}, s) => d.jsx(fL, {
    children: d.jsxs(iS, {
        ref: s,
        className: me("relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2", r === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1", t),
        position: r,
        ...n,
        children: [d.jsx(hS, {}), d.jsx(pL, {
            className: me("p-1", r === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"),
            children: e
        }), d.jsx(fS, {})]
    })
}));
pS.displayName = iS.displayName;
const wL = y.forwardRef( ({className: t, ...e}, r) => d.jsx(oS, {
    ref: r,
    className: me("py-1.5 pl-8 pr-2 text-sm font-semibold", t),
    ...e
}));
wL.displayName = oS.displayName;
const Gl = y.forwardRef( ({className: t, children: e, ...r}, n) => d.jsxs(aS, {
    ref: n,
    className: me("relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-8 pr-2 text-sm outline-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 focus:bg-accent focus:text-accent-foreground", t),
    ...r,
    children: [d.jsx("span", {
        className: "absolute left-2 flex h-3.5 w-3.5 items-center justify-center",
        children: d.jsx(gL, {
            children: d.jsx(kh, {
                className: "h-4 w-4"
            })
        })
    }), d.jsx(mL, {
        children: e
    })]
}));
Gl.displayName = aS.displayName;
const xL = y.forwardRef( ({className: t, ...e}, r) => d.jsx(uS, {
    ref: r,
    className: me("-mx-1 my-1 h-px bg-muted", t),
    ...e
}));
xL.displayName = uS.displayName;
const bL = () => {
    const t = Ga()
      , [e,r] = y.useState(!0)
      , [n,s] = y.useState([])
      , [i,o] = y.useState(null)
      , [a,l] = y.useState("")
      , [c,u] = y.useState(!1)
      , [h,p] = y.useState(!1);
    y.useEffect( () => {
        (async () => {
            const {data: {session: S}} = await gt.auth.getSession();
            if (!S) {
                t("/auth");
                return
            }
            const {data: k} = await gt.from("user_roles").select("role").eq("user_id", S.user.id).eq("role", "admin").single();
            p(!!k),
            k || St.error("Access denied. Admin privileges required."),
            await f(),
            await b(),
            r(!1)
        }
        )();
        const {data: {subscription: _}} = gt.auth.onAuthStateChange( (S, k) => {
            k || t("/auth")
        }
        );
        return () => _.unsubscribe()
    }
    , [t]);
    const f = async () => {
        const {data: v, error: _} = await gt.from("scripts").select("*").order("display_order");
        _ ? St.error("Failed to load scripts") : s(v)
    }
      , b = async () => {
        const {data: v} = await gt.from("hub_settings").select("setting_value").eq("setting_key", "main_loader").single();
        v && l(v.setting_value)
    }
      , m = async () => {
        await gt.auth.signOut(),
        t("/")
    }
      , x = async () => {
        if (!i || !h)
            return;
        u(!0);
        const {error: v} = await gt.from("scripts").update({
            lua_content: i.lua_content,
            status: i.status,
            is_premium: i.is_premium,
            price: i.price
        }).eq("id", i.id);
        v ? St.error("Failed to save script") : (St.success("Script saved successfully"),
        await f()),
        u(!1)
    }
      , w = async () => {
        if (!h)
            return;
        u(!0);
        const {error: v} = await gt.from("hub_settings").upsert({
            setting_key: "main_loader",
            setting_value: a
        }, {
            onConflict: "setting_key"
        });
        v ? St.error("Failed to save main loader") : St.success("Main loader saved successfully"),
        u(!1)
    }
      , g = (v, _) => {
        var C;
        const S = (C = v.target.files) == null ? void 0 : C[0];
        if (!S)
            return;
        const k = new FileReader;
        k.onload = T => {
            var P;
            const A = (P = T.target) == null ? void 0 : P.result;
            _ === "script" && i ? o({
                ...i,
                lua_content: A
            }) : _ === "loader" && l(A),
            St.success("File loaded successfully")
        }
        ,
        k.readAsText(S)
    }
    ;
    return e ? d.jsx("div", {
        className: "min-h-screen bg-background flex items-center justify-center",
        children: d.jsx(Un, {
            className: "w-8 h-8 text-primary animate-spin"
        })
    }) : d.jsxs("div", {
        className: "min-h-screen bg-background",
        children: [d.jsx("div", {
            className: "absolute inset-0 bg-[radial-gradient(ellipse_at_top,hsl(var(--primary)/0.08),transparent_50%)]"
        }), d.jsx("header", {
            className: "relative z-10 border-b border-border/50 bg-card/50 backdrop-blur-sm",
            children: d.jsxs("div", {
                className: "container mx-auto px-4 py-4 flex items-center justify-between",
                children: [d.jsxs("div", {
                    className: "flex items-center gap-4",
                    children: [d.jsx(Ye, {
                        variant: "ghost",
                        size: "icon",
                        onClick: () => t("/"),
                        children: d.jsx(Yw, {
                            className: "w-5 h-5"
                        })
                    }), d.jsxs("div", {
                        className: "flex items-center gap-3",
                        children: [d.jsx("div", {
                            className: "w-10 h-10 rounded-xl bg-primary/10 border border-primary/20 flex items-center justify-center",
                            children: d.jsx(Wa, {
                                className: "w-5 h-5 text-primary"
                            })
                        }), d.jsxs("div", {
                            children: [d.jsx("h1", {
                                className: "font-heading font-bold text-lg",
                                children: "Perplex Hub Admin"
                            }), d.jsx("p", {
                                className: "text-xs text-muted-foreground",
                                children: h ? "Full Access" : "View Only"
                            })]
                        })]
                    })]
                }), d.jsxs(Ye, {
                    variant: "ghost",
                    onClick: m,
                    children: [d.jsx(sC, {
                        className: "w-4 h-4 mr-2"
                    }), " Sign Out"]
                })]
            })
        }), d.jsxs("main", {
            className: "relative z-10 container mx-auto px-4 py-8",
            children: [!h && d.jsx(jt, {
                className: "mb-6 border-destructive/50 bg-destructive/10",
                children: d.jsx(Ot, {
                    className: "py-4",
                    children: d.jsxs("div", {
                        className: "flex items-center gap-3",
                        children: [d.jsx(Ai, {
                            className: "w-5 h-5 text-destructive"
                        }), d.jsx("p", {
                            className: "text-sm",
                            children: "You don't have admin privileges. Contact an administrator to get access."
                        })]
                    })
                })
            }), d.jsxs(g_, {
                defaultValue: "scripts",
                className: "space-y-6",
                children: [d.jsxs(Gp, {
                    children: [d.jsxs(Li, {
                        value: "scripts",
                        className: "gap-2",
                        children: [d.jsx(YE, {
                            className: "w-4 h-4"
                        }), " Scripts"]
                    }), d.jsxs(Li, {
                        value: "loader",
                        className: "gap-2",
                        children: [d.jsx(sd, {
                            className: "w-4 h-4"
                        }), " Main Loader"]
                    }), d.jsxs(Li, {
                        value: "status",
                        className: "gap-2",
                        children: [d.jsx(Zw, {
                            className: "w-4 h-4"
                        }), " Status"]
                    })]
                }), d.jsx($i, {
                    value: "scripts",
                    className: "space-y-6",
                    children: d.jsxs("div", {
                        className: "grid lg:grid-cols-3 gap-6",
                        children: [d.jsxs(jt, {
                            className: "glass",
                            children: [d.jsxs(Jt, {
                                children: [d.jsx(Zt, {
                                    className: "text-lg",
                                    children: "Game Scripts"
                                }), d.jsx(oo, {
                                    children: "Select a script to edit"
                                })]
                            }), d.jsx(Ot, {
                                className: "space-y-2",
                                children: n.map(v => d.jsxs("button", {
                                    onClick: () => o(v),
                                    className: `w-full text-left px-4 py-3 rounded-lg border transition-colors ${(i == null ? void 0 : i.id) === v.id ? "border-primary bg-primary/10" : "border-border/50 hover:border-primary/50"}`,
                                    children: [d.jsxs("div", {
                                        className: "flex items-center justify-between",
                                        children: [d.jsx("span", {
                                            className: "font-medium text-sm",
                                            children: v.game_name
                                        }), d.jsx("span", {
                                            className: `w-2 h-2 rounded-full ${v.status === "operational" ? "bg-[hsl(var(--status-operational))]" : v.status === "degraded" ? "bg-[hsl(var(--status-degraded))]" : "bg-[hsl(var(--status-maintenance))]"}`
                                        })]
                                    }), d.jsx("span", {
                                        className: "text-xs text-muted-foreground",
                                        children: v.game_slug
                                    })]
                                }, v.id))
                            })]
                        }), d.jsxs(jt, {
                            className: "glass lg:col-span-2",
                            children: [d.jsx(Jt, {
                                children: d.jsx(Zt, {
                                    className: "text-lg",
                                    children: i ? i.game_name : "Select a Script"
                                })
                            }), d.jsx(Ot, {
                                className: "space-y-4",
                                children: i ? d.jsxs(d.Fragment, {
                                    children: [d.jsxs("div", {
                                        className: "grid grid-cols-2 gap-4",
                                        children: [d.jsxs("div", {
                                            className: "space-y-2",
                                            children: [d.jsx(Hr, {
                                                children: "Status"
                                            }), d.jsxs(vL, {
                                                value: i.status,
                                                onValueChange: v => o({
                                                    ...i,
                                                    status: v
                                                }),
                                                disabled: !h,
                                                children: [d.jsx(dS, {
                                                    children: d.jsx(yL, {})
                                                }), d.jsxs(pS, {
                                                    children: [d.jsx(Gl, {
                                                        value: "operational",
                                                        children: " Operational"
                                                    }), d.jsx(Gl, {
                                                        value: "degraded",
                                                        children: " Degraded"
                                                    }), d.jsx(Gl, {
                                                        value: "maintenance",
                                                        children: " Maintenance"
                                                    })]
                                                })]
                                            })]
                                        }), d.jsxs("div", {
                                            className: "space-y-2",
                                            children: [d.jsx(Hr, {
                                                children: "Price (if premium)"
                                            }), d.jsx(ki, {
                                                type: "number",
                                                step: "0.01",
                                                value: i.price || "",
                                                onChange: v => o({
                                                    ...i,
                                                    price: v.target.value ? parseFloat(v.target.value) : null
                                                }),
                                                disabled: !h
                                            })]
                                        })]
                                    }), d.jsxs("div", {
                                        className: "space-y-2",
                                        children: [d.jsxs("div", {
                                            className: "flex items-center justify-between",
                                            children: [d.jsx(Hr, {
                                                children: "Lua Content"
                                            }), d.jsxs("label", {
                                                className: "cursor-pointer",
                                                children: [d.jsx("input", {
                                                    type: "file",
                                                    accept: ".lua,.txt",
                                                    className: "hidden",
                                                    onChange: v => g(v, "script"),
                                                    disabled: !h
                                                }), d.jsx(Ye, {
                                                    variant: "ghost",
                                                    size: "sm",
                                                    asChild: !0,
                                                    disabled: !h,
                                                    children: d.jsxs("span", {
                                                        children: [d.jsx(sd, {
                                                            className: "w-4 h-4 mr-2"
                                                        }), " Upload File"]
                                                    })
                                                })]
                                            })]
                                        }), d.jsx(ff, {
                                            className: "font-mono text-xs h-[300px]",
                                            value: i.lua_content,
                                            onChange: v => o({
                                                ...i,
                                                lua_content: v.target.value
                                            }),
                                            disabled: !h
                                        })]
                                    }), d.jsxs(Ye, {
                                        onClick: x,
                                        variant: "glow",
                                        disabled: c || !h,
                                        children: [c ? d.jsx(Un, {
                                            className: "w-4 h-4 animate-spin"
                                        }) : d.jsx(xg, {
                                            className: "w-4 h-4 mr-2"
                                        }), " Save Script"]
                                    })]
                                }) : d.jsx("div", {
                                    className: "text-center py-12 text-muted-foreground",
                                    children: "Select a script from the list to edit"
                                })
                            })]
                        })]
                    })
                }), d.jsx($i, {
                    value: "loader",
                    children: d.jsxs(jt, {
                        className: "glass",
                        children: [d.jsxs(Jt, {
                            children: [d.jsxs(Zt, {
                                className: "flex items-center gap-2",
                                children: [d.jsx(Ai, {
                                    className: "w-5 h-5 text-primary"
                                }), " Main Loader Script"]
                            }), d.jsx(oo, {
                                children: "This is the obfuscated script served when accessing the loadstring URL"
                            })]
                        }), d.jsxs(Ot, {
                            className: "space-y-4",
                            children: [d.jsxs("div", {
                                className: "flex items-center justify-between",
                                children: [d.jsx(Hr, {
                                    children: "Obfuscated Loader Content"
                                }), d.jsxs("label", {
                                    className: "cursor-pointer",
                                    children: [d.jsx("input", {
                                        type: "file",
                                        accept: ".lua,.txt",
                                        className: "hidden",
                                        onChange: v => g(v, "loader"),
                                        disabled: !h
                                    }), d.jsx(Ye, {
                                        variant: "ghost",
                                        size: "sm",
                                        asChild: !0,
                                        disabled: !h,
                                        children: d.jsxs("span", {
                                            children: [d.jsx(sd, {
                                                className: "w-4 h-4 mr-2"
                                            }), " Upload Obfuscated File"]
                                        })
                                    })]
                                })]
                            }), d.jsx(ff, {
                                className: "font-mono text-xs h-[400px]",
                                value: a,
                                onChange: v => l(v.target.value),
                                placeholder: "Paste your obfuscated loader script here...",
                                disabled: !h
                            }), d.jsxs("div", {
                                className: "flex items-center justify-between",
                                children: [d.jsxs("p", {
                                    className: "text-xs text-muted-foreground",
                                    children: [a.length.toLocaleString(), " characters"]
                                }), d.jsxs(Ye, {
                                    onClick: w,
                                    variant: "glow",
                                    disabled: c || !h,
                                    children: [c ? d.jsx(Un, {
                                        className: "w-4 h-4 animate-spin"
                                    }) : d.jsx(xg, {
                                        className: "w-4 h-4 mr-2"
                                    }), " Save Loader"]
                                })]
                            })]
                        })]
                    })
                }), d.jsx($i, {
                    value: "status",
                    children: d.jsxs(jt, {
                        className: "glass",
                        children: [d.jsx(Jt, {
                            children: d.jsxs("div", {
                                className: "flex items-center justify-between",
                                children: [d.jsx(Zt, {
                                    children: "Script Status Overview"
                                }), d.jsxs(Ye, {
                                    variant: "ghost",
                                    size: "sm",
                                    onClick: f,
                                    children: [d.jsx(oC, {
                                        className: "w-4 h-4 mr-2"
                                    }), " Refresh"]
                                })]
                            })
                        }), d.jsx(Ot, {
                            children: d.jsx("div", {
                                className: "grid sm:grid-cols-2 lg:grid-cols-3 gap-4",
                                children: n.map(v => d.jsxs("div", {
                                    className: "p-4 rounded-lg border border-border/50 bg-secondary/20",
                                    children: [d.jsxs("div", {
                                        className: "flex items-center justify-between mb-2",
                                        children: [d.jsx("span", {
                                            className: "font-medium",
                                            children: v.game_name
                                        }), d.jsx("span", {
                                            className: `px-2 py-1 rounded-full text-xs font-medium ${v.status === "operational" ? "bg-[hsl(var(--status-operational)/0.2)] text-[hsl(var(--status-operational))]" : v.status === "degraded" ? "bg-[hsl(var(--status-degraded)/0.2)] text-[hsl(var(--status-degraded))]" : "bg-[hsl(var(--status-maintenance)/0.2)] text-[hsl(var(--status-maintenance))]"}`,
                                            children: v.status
                                        })]
                                    }), d.jsx("p", {
                                        className: "text-xs text-muted-foreground",
                                        children: v.is_premium ? `Premium - $${v.price}` : "Free"
                                    })]
                                }, v.id))
                            })
                        })]
                    })
                })]
            })]
        })]
    })
}
  , xf = y.forwardRef( ({className: t, activeClassName: e, pendingClassName: r, to: n, ...s}, i) => d.jsx(WP, {
    ref: i,
    to: n,
    className: ({isActive: o, isPending: a}) => me(t, o && e, a && r),
    ...s
}));
xf.displayName = "NavLink";
const _L = iu("inline-flex items-center rounded-full border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2", {
    variants: {
        variant: {
            default: "border-transparent bg-primary text-primary-foreground hover:bg-primary/80",
            secondary: "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
            destructive: "border-transparent bg-destructive text-destructive-foreground hover:bg-destructive/80",
            outline: "text-foreground"
        }
    },
    defaultVariants: {
        variant: "default"
    }
});
function SL({className: t, variant: e, ...r}) {
    return d.jsx("div", {
        className: me(_L({
            variant: e
        }), t),
        ...r
    })
}
const kL = t => t === 0 ? {
    count: t,
    label: "Out of Stock",
    color: "text-red-500",
    icon: ""
} : t <= 9 ? {
    count: t,
    label: "Almost Gone",
    color: "text-orange-500",
    icon: ""
} : t <= 49 ? {
    count: t,
    label: "Low Stock",
    color: "text-yellow-500",
    icon: ""
} : {
    count: t,
    label: "In Stock",
    color: "text-green-500",
    icon: ""
}
  , EL = () => Yx({
    queryKey: ["premium-stock"],
    queryFn: async () => {
        const {data: t, error: e} = await gt.from("premium_stock").select("stock_count").eq("product_name", "premium").single();
        if (e)
            throw e;
        return (t == null ? void 0 : t.stock_count) ?? 0
    }
    ,
    staleTime: 3e4
})
  , Nl = "https://discord.gg/perplexhub"
  , Pl = {
    btc: {
        name: "Bitcoin",
        symbol: "",
        color: "bg-orange-500 hover:bg-orange-600"
    },
    eth: {
        name: "Ethereum",
        symbol: "",
        color: "bg-blue-500 hover:bg-blue-600"
    },
    ltc: {
        name: "Litecoin",
        symbol: "",
        color: "bg-gray-500 hover:bg-gray-600"
    }
};
function CL() {
    const [t,e] = y.useState(null)
      , [r,n] = y.useState(null)
      , [s] = qP()
      , {data: i, isLoading: o} = EL()
      , a = i !== void 0 ? kL(i) : null
      , l = s.get("status")
      , c = async u => {
        e(u),
        n(null);
        try {
            const {data: h, error: p} = await gt.functions.invoke("nowpayments-create-invoice", {
                body: {
                    currency: u
                }
            });
            if (p)
                throw new Error(p.message || "Failed to create invoice");
            if (h != null && h.invoice_url)
                window.location.href = h.invoice_url;
            else
                throw new Error("No invoice URL received")
        } catch (h) {
            console.error("Payment error:", h),
            n(h instanceof Error ? h.message : "Failed to create payment"),
            e(null)
        }
    }
    ;
    return d.jsxs("div", {
        className: "min-h-screen bg-background text-foreground relative overflow-hidden",
        children: [d.jsx("div", {
            className: "absolute inset-0 bg-[radial-gradient(ellipse_at_top,hsl(var(--primary)/0.15),transparent_50%)]"
        }), d.jsx("div", {
            className: "absolute top-0 left-1/2 -translate-x-1/2 w-[800px] h-[400px] bg-[radial-gradient(ellipse,hsl(var(--primary)/0.1),transparent_70%)] blur-3xl"
        }), d.jsxs("nav", {
            className: "relative z-50 flex items-center justify-between px-8 py-6 border-b border-border/50",
            children: [d.jsxs("div", {
                className: "flex items-center gap-3",
                children: [d.jsx("div", {
                    className: "p-2 rounded-lg bg-primary/10 border border-primary/20 glow-primary",
                    children: d.jsx(Wa, {
                        className: "w-6 h-6 text-primary"
                    })
                }), d.jsx("span", {
                    className: "text-xl font-heading font-bold text-gradient",
                    children: "PerplexHub"
                })]
            }), d.jsxs("div", {
                className: "flex items-center gap-6",
                children: [d.jsx(xf, {
                    to: "/",
                    className: "text-muted-foreground hover:text-foreground transition-colors",
                    children: "Home"
                }), d.jsx(xf, {
                    to: "/premium",
                    className: "text-muted-foreground hover:text-foreground transition-colors",
                    children: "Premium"
                }), d.jsx("a", {
                    href: Nl,
                    target: "_blank",
                    rel: "noopener noreferrer",
                    className: "text-muted-foreground hover:text-foreground transition-colors",
                    children: "Discord"
                })]
            })]
        }), d.jsxs("main", {
            className: "relative z-10 container mx-auto px-6 py-16",
            children: [d.jsxs("div", {
                className: "text-center mb-16",
                children: [d.jsxs(SL, {
                    className: "mb-4 bg-primary/20 text-primary border-primary/30",
                    children: [d.jsx(_i, {
                        className: "w-3 h-3 mr-1"
                    }), "Premium Access"]
                }), d.jsx("h1", {
                    className: "text-4xl md:text-5xl font-heading font-bold mb-4 text-gradient glow-text",
                    children: "Upgrade to Premium"
                }), d.jsx("p", {
                    className: "text-muted-foreground text-lg max-w-2xl mx-auto",
                    children: "Unlock exclusive features and premium scripts. Pay with crypto, then redeem your license key in Discord."
                })]
            }), l === "success" && d.jsxs("div", {
                className: "max-w-2xl mx-auto mb-8 p-6 glass rounded-xl border border-[hsl(var(--status-operational))]/30",
                children: [d.jsxs("div", {
                    className: "flex items-center gap-3 mb-3",
                    children: [d.jsx(JE, {
                        className: "w-6 h-6 text-[hsl(var(--status-operational))]"
                    }), d.jsx("h3", {
                        className: "text-xl font-semibold text-[hsl(var(--status-operational))]",
                        children: "Payment Received!"
                    })]
                }), d.jsx("p", {
                    className: "text-muted-foreground mb-4",
                    children: "Your payment has been received. To activate your premium access:"
                }), d.jsxs("ol", {
                    className: "list-decimal list-inside text-muted-foreground space-y-2 mb-4",
                    children: [d.jsx("li", {
                        children: "Join our Discord server"
                    }), d.jsxs("li", {
                        children: ["Use the ", d.jsx("code", {
                            className: "bg-secondary px-2 py-1 rounded text-primary",
                            children: "/redeem"
                        }), " command"]
                    }), d.jsx("li", {
                        children: "Enter your license key when prompted"
                    })]
                }), d.jsxs(Ye, {
                    onClick: () => window.open(Nl, "_blank"),
                    variant: "glow",
                    children: [d.jsx(Do, {
                        className: "w-4 h-4 mr-2"
                    }), "Join Discord to Redeem"]
                })]
            }), l === "cancelled" && d.jsxs("div", {
                className: "max-w-2xl mx-auto mb-8 p-6 glass rounded-xl border border-[hsl(var(--status-degraded))]/30",
                children: [d.jsxs("div", {
                    className: "flex items-center gap-3 mb-3",
                    children: [d.jsx(ZE, {
                        className: "w-6 h-6 text-[hsl(var(--status-degraded))]"
                    }), d.jsx("h3", {
                        className: "text-xl font-semibold text-[hsl(var(--status-degraded))]",
                        children: "Payment Cancelled"
                    })]
                }), d.jsx("p", {
                    className: "text-muted-foreground",
                    children: "Your payment was cancelled. Feel free to try again when you're ready."
                })]
            }), r && d.jsx("div", {
                className: "max-w-2xl mx-auto mb-8 p-4 glass rounded-xl border border-[hsl(var(--status-maintenance))]/30",
                children: d.jsx("p", {
                    className: "text-[hsl(var(--status-maintenance))]",
                    children: r
                })
            }), d.jsxs("div", {
                className: "grid md:grid-cols-2 gap-8 max-w-4xl mx-auto",
                children: [d.jsxs(jt, {
                    className: "glass hover-glow border-primary/30",
                    children: [d.jsxs(Jt, {
                        className: "text-center pb-4",
                        children: [d.jsx("div", {
                            className: "w-16 h-16 bg-primary/10 border border-primary/20 rounded-2xl flex items-center justify-center mx-auto mb-4 glow-primary",
                            children: d.jsx(_i, {
                                className: "w-8 h-8 text-primary"
                            })
                        }), d.jsx(Zt, {
                            className: "text-2xl text-foreground",
                            children: "PerplexHub Premium"
                        }), d.jsx(oo, {
                            className: "text-muted-foreground",
                            children: "Full access to all premium scripts and features"
                        })]
                    }), d.jsxs(Ot, {
                        className: "space-y-6",
                        children: [a && d.jsxs("div", {
                            className: `flex items-center justify-center gap-2 py-2 px-4 rounded-lg ${a.count === 0 ? "bg-red-500/10 border border-red-500/30" : a.count <= 9 ? "bg-orange-500/10 border border-orange-500/30" : a.count <= 49 ? "bg-yellow-500/10 border border-yellow-500/30" : "bg-green-500/10 border border-green-500/30"}`,
                            children: [d.jsx(iC, {
                                className: `w-4 h-4 ${a.color}`
                            }), d.jsxs("span", {
                                className: `text-sm font-medium ${a.color}`,
                                children: [a.icon, " ", a.label, " (", a.count, " remaining)"]
                            })]
                        }), o && d.jsxs("div", {
                            className: "flex items-center justify-center gap-2 py-2 px-4 rounded-lg bg-muted/20",
                            children: [d.jsx(Un, {
                                className: "w-4 h-4 animate-spin text-muted-foreground"
                            }), d.jsx("span", {
                                className: "text-sm text-muted-foreground",
                                children: "Loading stock..."
                            })]
                        }), d.jsxs("div", {
                            className: "text-center",
                            children: [d.jsx("span", {
                                className: "text-5xl font-heading font-bold text-primary",
                                children: "$4"
                            }), d.jsx("span", {
                                className: "text-muted-foreground ml-2",
                                children: "USD"
                            })]
                        }), d.jsxs("div", {
                            className: "space-y-3",
                            children: [d.jsxs("div", {
                                className: "flex items-center gap-2 text-muted-foreground",
                                children: [d.jsx(Ai, {
                                    className: "w-4 h-4 text-primary"
                                }), d.jsx("span", {
                                    children: "Premium script access"
                                })]
                            }), d.jsxs("div", {
                                className: "flex items-center gap-2 text-muted-foreground",
                                children: [d.jsx(wc, {
                                    className: "w-4 h-4 text-primary"
                                }), d.jsx("span", {
                                    children: "Priority updates"
                                })]
                            }), d.jsxs("div", {
                                className: "flex items-center gap-2 text-muted-foreground",
                                children: [d.jsx(_i, {
                                    className: "w-4 h-4 text-primary"
                                }), d.jsx("span", {
                                    children: "Exclusive features"
                                })]
                            })]
                        }), d.jsxs("div", {
                            className: "space-y-3 pt-4",
                            children: [d.jsx("p", {
                                className: "text-sm text-muted-foreground text-center mb-2",
                                children: "Pay with Crypto"
                            }), Object.keys(Pl).map(u => d.jsxs(Ye, {
                                onClick: () => c(u),
                                disabled: t !== null || (a == null ? void 0 : a.count) === 0,
                                className: `w-full ${Pl[u].color} text-white ${(a == null ? void 0 : a.count) === 0 ? "opacity-50 cursor-not-allowed" : ""}`,
                                children: [t === u ? d.jsx(Un, {
                                    className: "w-4 h-4 mr-2 animate-spin"
                                }) : d.jsx("span", {
                                    className: "mr-2",
                                    children: Pl[u].symbol
                                }), "Pay with ", Pl[u].name]
                            }, u))]
                        }), d.jsxs("p", {
                            className: "text-xs text-muted-foreground text-center pt-2",
                            children: ["After payment, redeem your key in Discord using ", d.jsx("code", {
                                className: "bg-secondary px-1 rounded text-primary",
                                children: "/redeem"
                            })]
                        })]
                    })]
                }), d.jsxs(jt, {
                    className: "glass hover-glow border-border/50",
                    children: [d.jsxs(Jt, {
                        className: "text-center pb-4",
                        children: [d.jsx("div", {
                            className: "w-16 h-16 bg-blue-500/10 border border-blue-500/20 rounded-2xl flex items-center justify-center mx-auto mb-4",
                            children: d.jsx(Do, {
                                className: "w-8 h-8 text-blue-400"
                            })
                        }), d.jsx(Zt, {
                            className: "text-2xl text-foreground",
                            children: "Custom Script"
                        }), d.jsx(oo, {
                            className: "text-muted-foreground",
                            children: "Need something specific? Let's talk!"
                        })]
                    }), d.jsxs(Ot, {
                        className: "space-y-6",
                        children: [d.jsx("div", {
                            className: "text-center",
                            children: d.jsx("span", {
                                className: "text-3xl font-heading font-bold text-foreground",
                                children: "Custom Pricing"
                            })
                        }), d.jsxs("div", {
                            className: "space-y-3",
                            children: [d.jsxs("div", {
                                className: "flex items-center gap-2 text-muted-foreground",
                                children: [d.jsx(Ai, {
                                    className: "w-4 h-4 text-blue-400"
                                }), d.jsx("span", {
                                    children: "Tailored to your needs"
                                })]
                            }), d.jsxs("div", {
                                className: "flex items-center gap-2 text-muted-foreground",
                                children: [d.jsx(wc, {
                                    className: "w-4 h-4 text-blue-400"
                                }), d.jsx("span", {
                                    children: "Direct communication"
                                })]
                            }), d.jsxs("div", {
                                className: "flex items-center gap-2 text-muted-foreground",
                                children: [d.jsx(_i, {
                                    className: "w-4 h-4 text-blue-400"
                                }), d.jsx("span", {
                                    children: "Priority support"
                                })]
                            })]
                        }), d.jsx("div", {
                            className: "pt-4",
                            children: d.jsxs(Ye, {
                                onClick: () => window.open(Nl, "_blank"),
                                className: "w-full bg-[#5865F2] hover:bg-[#4752C4] text-white",
                                children: [d.jsx(Do, {
                                    className: "w-4 h-4 mr-2"
                                }), "Contact us on Discord"]
                            })
                        }), d.jsx("p", {
                            className: "text-xs text-muted-foreground text-center pt-2",
                            children: "Join our Discord and open a ticket to discuss your project"
                        })]
                    })]
                })]
            }), d.jsx("div", {
                className: "mt-16 text-center",
                children: d.jsxs("div", {
                    className: "flex items-center justify-center gap-8 text-muted-foreground flex-wrap",
                    children: [d.jsxs("div", {
                        className: "flex items-center gap-2",
                        children: [d.jsx(Ai, {
                            className: "w-5 h-5 text-primary"
                        }), d.jsx("span", {
                            children: "Secure Payments"
                        })]
                    }), d.jsxs("div", {
                        className: "flex items-center gap-2",
                        children: [d.jsx("span", {
                            className: "font-bold text-primary",
                            children: ""
                        }), d.jsx("span", {
                            children: "Crypto Only"
                        })]
                    }), d.jsxs("div", {
                        className: "flex items-center gap-2",
                        children: [d.jsx(Do, {
                            className: "w-5 h-5 text-primary"
                        }), d.jsx("span", {
                            children: "Discord Support"
                        })]
                    })]
                })
            }), d.jsxs("div", {
                className: "mt-16 max-w-2xl mx-auto",
                children: [d.jsx("h2", {
                    className: "text-2xl font-heading font-bold text-center mb-8 text-foreground",
                    children: "How It Works"
                }), d.jsxs("div", {
                    className: "grid grid-cols-3 gap-4",
                    children: [d.jsxs("div", {
                        className: "text-center p-4",
                        children: [d.jsx("div", {
                            className: "w-12 h-12 bg-primary/20 rounded-full flex items-center justify-center mx-auto mb-3 border border-primary/30",
                            children: d.jsx("span", {
                                className: "text-xl font-bold text-primary",
                                children: "1"
                            })
                        }), d.jsx("h3", {
                            className: "font-semibold text-foreground mb-1",
                            children: "Pay with Crypto"
                        }), d.jsx("p", {
                            className: "text-sm text-muted-foreground",
                            children: "Choose BTC, ETH, or LTC"
                        })]
                    }), d.jsxs("div", {
                        className: "text-center p-4",
                        children: [d.jsx("div", {
                            className: "w-12 h-12 bg-primary/20 rounded-full flex items-center justify-center mx-auto mb-3 border border-primary/30",
                            children: d.jsx("span", {
                                className: "text-xl font-bold text-primary",
                                children: "2"
                            })
                        }), d.jsx("h3", {
                            className: "font-semibold text-foreground mb-1",
                            children: "Get Your Key"
                        }), d.jsx("p", {
                            className: "text-sm text-muted-foreground",
                            children: "Receive license via Discord"
                        })]
                    }), d.jsxs("div", {
                        className: "text-center p-4",
                        children: [d.jsx("div", {
                            className: "w-12 h-12 bg-primary/20 rounded-full flex items-center justify-center mx-auto mb-3 border border-primary/30",
                            children: d.jsx("span", {
                                className: "text-xl font-bold text-primary",
                                children: "3"
                            })
                        }), d.jsx("h3", {
                            className: "font-semibold text-foreground mb-1",
                            children: "Redeem & Enjoy"
                        }), d.jsx("p", {
                            className: "text-sm text-muted-foreground",
                            children: "Use /redeem in Discord"
                        })]
                    })]
                })]
            })]
        }), d.jsx("footer", {
            className: "relative z-10 border-t border-border/50 mt-16 py-8",
            children: d.jsxs("div", {
                className: "container mx-auto px-6 text-center text-muted-foreground",
                children: [d.jsx("p", {
                    children: " 2024 PerplexHub. All rights reserved."
                }), d.jsxs("p", {
                    className: "mt-2 text-sm",
                    children: ["Questions? ", d.jsx("a", {
                        href: Nl,
                        target: "_blank",
                        rel: "noopener noreferrer",
                        className: "text-primary hover:underline",
                        children: "Join our Discord"
                    })]
                })]
            })
        })]
    })
}
const TL = () => {
    const t = Ws();
    return y.useEffect( () => {
        console.error("404 Error: User attempted to access non-existent route:", t.pathname)
    }
    , [t.pathname]),
    d.jsx("div", {
        className: "flex min-h-screen items-center justify-center bg-muted",
        children: d.jsxs("div", {
            className: "text-center",
            children: [d.jsx("h1", {
                className: "mb-4 text-4xl font-bold",
                children: "404"
            }), d.jsx("p", {
                className: "mb-4 text-xl text-muted-foreground",
                children: "Oops! Page not found"
            }), d.jsx("a", {
                href: "/",
                className: "text-primary underline hover:text-primary/90",
                children: "Return to Home"
            })]
        })
    })
}
  , RL = new TN
  , NL = () => d.jsx(jN, {
    client: RL,
    children: d.jsxs(lN, {
        children: [d.jsx(WC, {}), d.jsx(_T, {}), d.jsx(UP, {
            children: d.jsxs(AP, {
                children: [d.jsx(ii, {
                    path: "/",
                    element: d.jsx(n2, {})
                }), d.jsx(ii, {
                    path: "/auth",
                    element: d.jsx(G2, {})
                }), d.jsx(ii, {
                    path: "/admin",
                    element: d.jsx(bL, {})
                }), d.jsx(ii, {
                    path: "/premium",
                    element: d.jsx(CL, {})
                }), d.jsx(ii, {
                    path: "*",
                    element: d.jsx(TL, {})
                })]
            })
        })]
    })
});
bw(document.getElementById("root")).render(d.jsx(NL, {}));
